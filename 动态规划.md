#  动态规划 

## 动态规划基础

1. 确定dp数组（dp table）以及下标的含义 

2. 确定递推公式 

3. dp数组如何初始化 

4. 确定遍历顺序 

5. 举例推导dp数组



### 01背包问题

**题目：**有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用⼀次，求解将哪些物品装入背包里物品价值总和最大。

**思路1**：二维动态规划。

* 1.确定数组下标以及下标的含义。使用二维数组，`dp[i][j]`表示选择第`i`件物体放到容量为`j`的背包时，价值总和是多少。

* 2.递推公式。`dp[i][j]`是选第i件物体的时候，那么上一步应该是选择第`j-1`件物体。当不选择第j件物体时，容量不变，价值总和不变，`dp[i][j] = dp[i-1][j]`；当选择第j件物体时，上一时刻的背包容量应该为`j-weight[j]`，`dp[i][j]=d[i][j-weight[j]] + value[i]`。综上：

`dp[i][j] = max(dp[i-1][j], d[i][j-weight[j]] + value[i])`

* 3.初始化。当背包容量为时，价值总和也为0，则`dp[i][0] = 0`。当选择第0件物品时，当背包容量小于weight[0]时，价值总和为0。当背包容量大于等于weight[0]时，价值总和为value[0]。

* 4.变量顺序。外层循环变量物体，内层循环变量容量。

* 5.举例。



**思路2**：一维动态规划。（滚动数组）

* 1.确定dp数组的定义。
  	在⼀维dp数组中，`dp[j]`表示：容量为j的背包，所背的物品价值可以最大为`dp[j]`。

* 2.递归公式。

  如何得到dp[j]，在迭代i中，dp[j]要么不选物体i，此时`dp[j]=dp[j]`；要么选物体i，此时`d[j] = d[j- weight[i]]+value[i]`。选择其中最有价值的一个，即：`dp[j] = max(dp[j], d[j- weight[i]]+value[i])`。

* 3.初始化。

  初始化时，表示选择物体0时，此时对于容量j 小于weight[0]时，dp[j]=0；对于容量j 大于等于weight[0]时，`dp[j]=value[0]`。

* 4.遍历。

  外层循环表示物体选择的顺序，`i=0 -> n`；

  内层循环表示背包容量的变化，遍历方式从大到小，`j=bagweight -> weight[i]`。这样才能保证物体i只被放入到背包一次。





### 完全背包

​	有N件物品和⼀个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品都有⽆限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。完全背包和01背包问题唯⼀不同的地方就是，每种物品有⽆限件。

回顾01背包的核心代码：

```C++
for(int i = 0; i < weight.size(); i++) // 遍历物品
	for(int j = bagWeight; j >= weight[i]; j--) // 遍历背包容量
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

​	01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加⼀次。

​	而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```C++
for(int i = 0; i < weight.size(); i++) // 遍历物品
	for(int j = weight[i]; j < bagWeight ; j++) // 遍历背包容量
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```





**如果求组合数就是外层for循环遍历物品，内层for遍历背包。**
**如果求排列数就是外层for遍历背包，内层for循环遍历物品。**





## 基础题目

### L509. 斐波那契数

**题目**：斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。

**思路1**：递归。

```C++
int fib(int n) {
    if(n==0)
        return 0;
    else if(n==1)
        return 1;
    else
        return fib(n-1)+fib(n-2);
}
```

**思路2**：迭代。

```C++
int fib(int n) {
    int last_1=1;
    int last_2=0;
    if(n==1)return 1;
    int curr=0;
    for(int i=1;i<n;++i){
        curr=last_1+last_2;
        last_2=last_1;
        last_1=curr;
    }
    return curr;
}
```

**思路3**：一维动态规划。

1 dp数组中元素a[i]表示斐波那契数F(i)。

2 递推公式：a[i]=a[i-1]+a[i-2]

3 初始化：a[0]=0, a[1]=1

4 遍历顺序：i=0->i=n

```C++
int fib(int n) {
    if(n==0) return 0;
    else if(n==1) return 1;
    vector<int> dp(n+1);
    dp[0]=0;
    dp[1]=1;
    for(int i=2;i<=n;++i) dp[i]=dp[i-1]+dp[i-2];
    return dp[n];
}
```



### J10-I. 斐波那契数列

**[题目](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)**: 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：
输入：n = 2
输出：1

示例 2：
输入：n = 5
输出：5

提示：
    0 <= n <= 100
```



**思路1**：迭代。(会超时)

```C++
int fib(int n) {
    if(n==0) 
        return 0;
    else if(n==1) 
        return 1;
    else
        return fib(n-1)+fib(n-2);
}
```



**思路2**：动态规划。

注意：需要取模，否则会溢出。

```C++
int fib(int n) {
    if(n==0) return 0;
    else if(n==1) return 1;
    vector<int> dp(n+1);
    dp[0]=0;
    dp[1]=1;
    for(int i=2;i<=n;++i)
        dp[i]=(dp[i-1]+dp[i-2])%(1000000007);
    return dp[n];
}
```





### J10-II. 青蛙跳台阶问题

**[题目](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)**: 写一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：
输入：n = 2
输出：2

示例 2：
输入：n = 7
输出：21

示例 3：
输入：n = 0
输出：1
```

提示：

    0 <= n <= 100



**思路1**：动态规划。

注意：需要取模，否则会溢出。

```C++
int numWays(int n) {
    if(n==0) return 1;
    else if(n==1) return 1;
    else if(n==2) return 2;
    
    vector<int> dp(n+1);
    dp[1]=1;
    dp[2]=2;
    
    for(int i=3;i<=n;++i)
        dp[i] = (dp[i-1]+dp[i-2]) % (1000000007);
    
    return dp[n];
}
```





### L70. 爬楼梯

**题目**：假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 *n* 是一个正整数。



**思路1**：一维动态规划。

1 dp元素：dp[i]表示爬升到第 i 个台阶的所有方法。

2 递归公式： `dp[i] = dp[i-1]+dp[i-2]`

3 初始化：`dp[0]=0,dp[1]=1,dp[2]=2;`

4 遍历顺序：i=0到i=n

```C++
int climbStairs(int n) {
    if(n==0)return 0;
    else if(n==1) return 1;
    else if(n==2) return 2;
    vector<int> dp(n+1);
    dp[0]=0;
    dp[1]=1;
    dp[2]=2;
    for(int i=3;i<=n;++i)
        dp[i]=dp[i-1]+dp[i-2];
    return dp[n];
}
```

**思路2**：一维动态规划，但是不构造dp数组。

**思路3**：矩阵快速幂。

**思路4**：通项公式。









### L746. 使用最小花费爬楼梯

**题目**：给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。



**思路1**：动态规划。

1 数组元素：dp[i]表示到达第 i 阶所需要的最小花费。

2 递归公式：`dp[i]= min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])`

3 初始化：`dp[0] = 0, dp[1]=0`. 这是因为可以选择从第0阶或第1阶开始爬楼梯。

4 遍历：从i=0到i=n

5 举例

```C++
int minCostClimbingStairs(vector<int>& cost) {
    vector<int> dp(cost.size()+1);
    dp[0]=0;
    dp[1]=0;
    for(int i=2;i<=cost.size();++i)
        dp[i] = std::min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
    return dp[cost.size()];
}
```

优化：可以将时间复杂度优化为O(3)





### L62. 不同路径

**题目**：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？



**思路1**：动态规划。二维动态规划。

1 每个元素`dp[i][j]`表示第`(i,j)`网格的路径的数量。

2 递归公式：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

3 初始化： `dp[0][0] = 1, dp[i][0] = 1,  dp[0][j] = 1`。

4 遍历：从左到右，从上到下遍历。

5 举例。

代码：

```C++
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m,vector<int>(n));
    //初始化
    dp[0][0]=1;
    for(int i=1;i<m;++i)dp[i][0] = 1;
    for(int j=1;j<n;++j)dp[0][j] = 1;
    //遍历
    for(int i=1;i<m;++i)
        for(int j=1;j<n;++j)
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
    return dp[m-1][n-1];
}
```



**思路2**：组合数学。





### L63. 不同路径 II

**题目**：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

 网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。 



**思路1**：动态规划。二维动态规划。

这道题和上一题差不多，唯一的区别是，在计算dp[i] [j]的时候，需要判断其 上方网格 左方网格 和当前网格是否存在障碍物。

```C++
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    int m=obstacleGrid.size();
    int n=obstacleGrid[0].size();
    vector<vector<int>> dp(m,vector<int>(n));
    //初始化
    if(obstacleGrid[0][0]==1) dp[0][0]=0;
    else dp[0][0]=1;
    for(int i=1;i<m;++i){
        if(obstacleGrid[i][0]==1) 
            dp[i][0]=0;
        else 
            dp[i][0]=dp[i-1][0];
    }
    for(int i=1;i<n;++i){
        if(obstacleGrid[0][i]==1) 
            dp[0][i]=0;
        else 
            dp[0][i]=dp[0][i-1];
    }  
	//遍历
    for(int i=1;i<m;++i){
        for(int j=1;j<n;++j){
            if(obstacleGrid[i-1][j]==1 && obstacleGrid[i][j-1]==0 && obstacleGrid[i][j]==0)
                dp[i][j] = dp[i][j-1];
            else if(obstacleGrid[i-1][j]==0 && obstacleGrid[i][j-1]==1 && obstacleGrid[i][j]==0)
                dp[i][j] = dp[i-1][j];
            else if(obstacleGrid[i-1][j]==0 && obstacleGrid[i][j-1]==0 && obstacleGrid[i][j]==0)
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            else
                dp[i][j] = 0;
        }
    }
    return dp[m-1][n-1];
}
```



### L64. 最小路径和

**题目**：给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。



**思路1**：动态规划。

1 dp元素。

​	dp[i] [j]表示从起点到网格(i,j)的最小路径和。

2 递推公式。

```
dp[i][j] = std::min(dp[i][j-1],dp[i-1][j]) + grid[i][j];
```

3 初始化

​	初始化第一列和第一行，其值均为该行或该列的累积和。

4 遍历方式

​	外层：从上到下

​	内层：从左到右。

5 举例。

代码：

```C++
int minPathSum(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    //dp[i][j]表示到位置i,j的最小路径和
    vector<vector<int>> dp(m,vector<int>(n));
    //初始化
    dp[0][0] = grid[0][0];
    for(int i=1;i<n;++i) 
        dp[0][i] = dp[0][i-1] + grid[0][i];
    for(int i=1;i<m;++i) 
        dp[i][0] = dp[i-1][0] + grid[i][0];
    //遍历
    for(int i=1;i<m;++i){
        for(int j=1;j<n;++j){
            dp[i][j] = std::min(dp[i][j-1],dp[i-1][j]) + grid[i][j];
        }
    }
    return dp[m-1][n-1];
}
```



### J47. 礼物的最大价值

**[题目](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)**：在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

 ```
示例 1:
输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
 ```


提示：

0 < grid.length <= 200
0 < grid[0].length <= 200



**思路1**：动态规划。

题目说明：从棋盘的左上角开始拿格子里的礼物，并每次 向右 或者 向下 移动一格、直到到达棋盘的右下角。
根据题目说明，易得某单元格只可能从上边单元格或左边单元格到达。

设 f(i, j)f(i,j) 为从棋盘左上角走至单元格 `(i,j)` 的礼物最大累计价值，易得到以下递推关系：`f(i,j)` 等于 `f(i,j−1)` 和 `f(i-1,j)` 中的较大值加上当前单元格礼物价值 `grid(i,j)` 。

`f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j)`
因此，可用动态规划解决此问题，以上公式便为转移方程。

```C++
int maxValue(vector<vector<int>>& grid) {
    int rows=grid.size(), cols=grid[0].size();
    vector<vector<int>> dp(rows,vector<int>(cols));//dp[i][j]表示到网格(i,j)时的最多礼物
    //初始化
    dp[0][0]=grid[0][0];
    for(int i=1;i<cols;++i) dp[0][i] = dp[0][i-1]+grid[0][i];
    for(int i=1;i<rows;++i) dp[i][0] = dp[i-1][0]+grid[i][0];
    //递推
    for(int i=1;i<rows;++i){
        for(int j=1;j<cols;++j){
            dp[i][j] = std::max(dp[i-1][j],dp[i][j-1]) + grid[i][j];
        }
    }
    return dp[rows-1][cols-1];
}
```



若允许修改输出的二维输入，则可将该数组作为dp数组用， 省去了额外的空间开销。

```C++
int maxValue(vector<vector<int>>& grid) {
	int rows=grid.size(), cols=grid[0].size();
    //初始化
    for(int i=1;i<cols;++i) grid[0][i] = grid[0][i-1]+grid[0][i];
    for(int i=1;i<rows;++i) grid[i][0] = grid[i-1][0]+grid[i][0];
    //递推
    for(int i=1;i<rows;++i){
        for(int j=1;j<cols;++j)
            grid[i][j] = std::max(grid[i-1][j],grid[i][j-1]) + grid[i][j];
    }
    return grid[rows-1][cols-1];
}
```







### L343. 整数拆分

**题目：**给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

```C++
示例 1:
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```



**思路1**：一维动态规划。时间复杂度O(n^2)，空间复杂度O(n)

1 数组元素：dp[i]表示正整数i 拆分后的最大乘积。

2 递推公式： 假设正整数 num 分解为 两个正整数 x 和 y ，为了寻找最大乘积，需要遍历所有的x和y，并取最大乘积。对于每个x,y，其最大乘积为：`x*max(dp[y],y)`。拆分x的情况，在遍历x的过程中其实都计算过了。

3 初始化：由于0不是正整数，因此不用管。dp[1]=1, dp[2] = 1。为什么dp[1]=1? 这是因为1无法分解为两个正整数，因此其最大乘积和为其本身。

4 遍历：从i=0 到 i=n

5 举例。

代码：

```C++
int integerBreak(int n) {
    vector<int> dp(n+1);
    dp[1] = 1;
    dp[2] = 1;
    //dp[i] = 数值i拆分后的最大乘积
    for(int i=3;i<=n;++i){
        int m_max = 0;
        for(int j=1;j<=i/2;++j){
            m_max = std::max(m_max, j*std::max(dp[i-j],i-j));
        }
        dp[i] = m_max;
    }
    return dp[n];
}
```



**思路2**：优化的动态规划。时间复杂度和空间复杂度均为O(n)。



**思路3**：数学方法。时间复杂度和空间复杂度均为O(1)。





### J14-I 剪绳子

**[题目](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/jian-zhi-offer-14-i-jian-sheng-zi-dong-t-06aw/)**：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

```
示例 1：
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

提示：

2 <= n <= 58



**思路1**：动态规划。

思路同 L343整数拆分

```C++
int cuttingRope(int n) {
    //动态规划，dp[i]表示长度为i的绳子剪成段的最大乘积 
    vector<int> dp(n+1);
    dp[1]=1;
    for(int i=2;i<=n;++i){
        int max_value=0;
        for(int j=1;j<i;j++){
            max_value=std::max(max_value,std::max(j*(i-j),j*dp[i-j]));
        }
        dp[i]=max_value;
    }
    return dp[n];
}
```



**思路2**：贪心。

如果绳子的长度大于 5，则每次都剪出一段长度为3的绳子。如果剩下的绳子的长度仍然大于5，则接着剪出一段长度为3的绳子。接下来重复这个步骤，直到剩下的绳子的长度小于5。剪出一段长度为3的绳子，就是我们在每一步做出的贪婪选择。为什么这样的贪婪选择能得到最优解?这是我们应用贪婪算法时都需要问的问题，需要用数学方式来证明贪婪选择是正确的。





### J14-II 剪绳子 II

**[题目](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)**：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。



**思路1**：动态规划。

这道题与J14-I不同之处在于，n可能很大，以至于乘积超出数据范围。因此数据结构int、int64_t不足以存放乘积。

解决办法是可以用不限制整数大小的python3实现，或使用JAVA的大数类型实现。

这题再用动态规划的话惨不忍睹，还是要看贪心
核心思路是：尽可能把绳子分成长度为3的小段，这样乘积最大

步骤如下：

如果 n == 2，返回1，如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1
如果 n == 4，返回4
如果 n > 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段；每次乘法操作后记得取余就行
以上2和3可以合并



**思路2**：贪心。

```C++
int cuttingRope(int n) {
    if(n<=3)  
        return n-1;
    long long sum=1;
    while(n>4){
        sum=sum*3%1000000007;
        n-=3;
    }
    return sum*n%1000000007;
}
```







### L96. 不同的二叉搜索树

**题目：** 给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。 

```
示例：
输入：n = 3
输出：5
```

![示例](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)



**思路1**：动态规划。时间复杂度O(n^2)，空间复杂度O(n)

​    核心难点是如何推导递归公式，即如何将原问题分解为子问题，子问题如何推导出原问题。

可知，**i个节点组成的二叉树数量dp[i] 等于不同的 $k \in (1,...,n)$作为 头节点时二叉树的数量和。**当k作为头节点时，二叉树的数量为$dp[k-1] * dp[ i - k]$。

​	这是因为当k作为头节点时，左子树中存在的值为$[1,...,k-1]$，因此该左子树的数量为$dp[k-1]$。右子树中存在的值为$[k+1,...,i]$，右子树的数量等价于$dp[ i - k]$，这是因为题目只关心二叉树的数量，而不关心每个节点的值，因此右子树的二叉树数量为$dp[ i - k]$。

​	代码如下：

```C++
int numTrees(int n) {
    if(n==1) return 1;
    vector<int> dp(n+1,0);//dp[i]表示由i个节点组成的二叉搜索树的数量
    dp[0] = 1;
    dp[1] = 1;
    for(int i=2;i<=n;++i)
        for(int j=0;j<i;++j) //将i个节点划分为左子树的长度
        	dp[i] += dp[j] * dp[i-j-1];
    return dp[n];
}
```



**思路2**：数学方法。卡塔兰数。





### J42. 连续子数组的最大和

同L53.

### L53. 最大子数组和

**[题目](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)**：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

```
示例1:
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

提示：

1 <= arr.length <= 10^5
-100 <= arr[i] <= 100



**思路1**：动态规划。

​    假设 nums 数组的长度是 n，下标从 0 到 n−1。

​    我们用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：$\max_{0 \leq i \leq n-1} \{ f(i) \}$
​	因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：

`f(i)=max{f(i−1)+nums[i],nums[i]}`

​     不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 f 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。

```C++
int maxSubArray(vector<int>& nums) {
    vector<int> dp(nums.size());
    dp[0]=nums[0];
    for(int i=1;i<nums.size();++i)
        dp[i] = std::max(dp[i-1]+nums[i],nums[i]);
    return *std::max_element(dp.begin(),dp.end());
}
```



**思路2**：分治。



**思路3**：贪心。

```C++
int maxSubArray(vector<int>& nums) {
    int max=INT_MIN;
    int cnt=0;
    for(int i=0;i<nums.size();++i){
        cnt+=nums[i];
        if(cnt>max)
            max=cnt;
        if(cnt<0)
            cnt=0;
    }
    return max;
}
```





## 01背包题目

### L494. 目标和

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。



**思路1**：动态规划。转换为01背包问题。

在每个整数前添加"+"或"-"号，相当于存在 **子集left的和 - 子集right的和 = target**，且left + right = sum。即：
$$
left - (sum-left) = target \\
即：left = (target + sum) / 2
$$
​	target是固定的，sum是固定的，left可以求出来。

​	于是接下来的工作就是在nums中寻找和为left的子集。

1 `dp[j]` 表示填满`j`大小的背包，有`dp[j]`种方法。

2 递推公式。

​	填满容量为 `j-num[i]` 的背包，有`dp[j-nums[i]]`中的方法。那么只要存在`nums[i]`，则凑成`dp[j]`就有 `dp[j-num[i]]`种方法。

`dp[j] += dp[j-nums[i]]​ `

​	求组合类问题的公式，都是类似这样的：`dp[j] += dp[j-nums[i]] ​`。

3 初始化

在初始化的时候`dp[0]` ⼀定要初始化为1，因为`dp[0]`是在公式中⼀切递推结果的起源，如果`dp[0]`是0的话，递归结果将都是0。`dp[0] = 1`，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。

`dp[j]`其他下标对应的数值应该初始化为0，从递归公式也可以看出，`dp[j]`要保证是0的初始值，才能正确
的由`dp[j - nums[i]]`推导出来。

4 遍历顺序。

5 举例。



```C++
int findTargetSumWays(vector<int>& nums, int target) {
    //这可以转换为0-1背包问题,问题转换为数组子集和为 (target+sum)/2 有多少种方法。
    //dp[j] 在选择元素时，数组子集的目标和为j的表达式的数目
    int sum=0;
    for(int i=0;i<nums.size();++i) 
        sum+= nums[i];
    if(target > sum)
        return 0;
    if((target + sum)%2 == 1)
        return 0;
    if(target+sum<0)
        return 0;
    
    int bagSize = (target+sum)/2;
    vector<int> dp(bagSize+1);
    dp[0]=1;
    
    for(int i=0;i<nums.size();++i){
        for(int j=bagSize;j>=nums[i];--j){
            dp[j] += dp[j-nums[i]];//那么只要存在nums[i]，则凑成dp[j]就有 dp[j-num[i]]种方法。
        }
    }
    return dp[bagSize];
}
```



### L416. 分割等和子集

**[题目](https://leetcode-cn.com/problems/partition-equal-subset-sum/)**: 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 ```
示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

示例 2：
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
 ```


提示：

1 <= nums.length <= 200
1 <= nums[i] <= 100



**思路1**：动态规划。







### L1049. 最后一块石头的重量II







### L474. 一和零







## 完全背包题目



### L518. 零钱兑换 II

**题目：**给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。



**思路1**：动态规划。

这是一个完全背包问题。

1 **dp[i]表示总和为 i 的coins的组合数**。

2 递推公式：

当填满容量为 j-num[i] 的背包，有dp[j-nums[i]]中的方法。那么只要存在nums[i]，则凑成dp[j]就有 dp[j-num[i]]种方法。

$dp[j] += dp[j - coins[i]];$

3 初始化：dp[0] = 1，装满容量为0的背包，有1种方法，就是装0件物品。

4 遍历：外层循转遍历物体，内层循环遍历背包容量（这里是总和）。

5.举例。



代码：

```C++
int change(int amount, vector<int>& coins) {
    vector<int> dp(amount+1);//dp[i]表示总和为i的coins的组合数
    dp[0] = 1;
    for(int i=0;i<coins.size();++i)
        for(int j=coins[i];j<=amount;++j)
            dp[j] += dp[j - coins[i]];
    return dp[amount];
}
```



### L377. 组合总和 Ⅳ

**[题目](https://leetcode-cn.com/problems/combination-sum-iv/)**：给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

示例 1：

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

示例 2：

```
输入：nums = [9], target = 3
输出：0
```



**思路1**：动态规划。

这道题和L518不一样，这道题中求的是排列总数，而上一题求的是组合总数。组合不强调顺序，(1,5)和(5,1)是同⼀个组合。排列强调顺序，(1,5)和(5,1)是两个不同的排列。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包。**
**如果求排列数就是外层for遍历背包，内层for循环遍历物品。**

​        如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举⼀个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后⾯！所以本题遍历顺序最终遍历顺序：target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历。

```C++
int combinationSum4(vector<int>& nums, int target) {
    vector<int> dp(target+1);//dp[i]表示容量为i的背包的排列个数
    dp[0] = 1;
    for(int i=1;i<=target;++i){//外层遍历背包
        for(int j=0;j<nums.size();++j){//内层遍历物品
            if(i>=nums[j] && dp[i] < INT_MAX - dp[i - nums[j]])//只有当背包容量大于物体时，且dp[i] += dp[i - nums[j]]小于INT_MAX时
                dp[i] += dp[i - nums[j]];
        }
    }
    return dp[target];
}
```

C++测试用例有超过两个树相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]。







### L70. 爬楼梯（进阶）

**题目**：将原题改为：⼀步⼀个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？



**思路1**：动态规划。

1阶，2阶，.... m阶就是物品，楼顶就是背包。
每⼀阶可以重复使用，例如跳了1阶，还可以继续跳1阶。
问跳到楼顶有⼏种方法其实就是问装满背包有⼏种方法。

此时大家应该发现这就是⼀个完全背包问题了。

做法与L377一致。



### L322. 零钱兑换

**[题目](https://leetcode-cn.com/problems/coin-change/)**：给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

 ```
示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1

示例 2：
输入：coins = [2], amount = 3
输出：-1

示例 3：
输入：coins = [1], amount = 0
输出：0

示例 4：
输入：coins = [1], amount = 1
输出：1

示例 5：
输入：coins = [1], amount = 2
输出：2
 ```


提示：

1 <= coins.length <= 12
1 <= coins[i] <= 2^31 - 1
0 <= amount <= 10^4



**思路1**：动态规划。

题⽬中说每种硬币的数量是⽆限的，可以看出是典型的完全背包问题。
动规五部曲分析如下：

1. 确定dp数组以及下标的含义
dp[j]：凑⾜总额为j所需钱币的最少个数为dp[j]
2. 确定递推公式
得到dp[j]（考虑coins[i]），只有⼀个来源，dp[j - coins[i]]（没有考虑coins[i]）。
凑⾜总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上⼀个钱币coins[i]即dp[j - coins[i]] +
1就是dp[j]（考虑coins[i]）
所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。
递推公式：**dp[j] = min(dp[j - coins[i]] + 1, dp[j])**;
3. dp数组如何初始化
⾸先凑⾜总金额为0所需钱币的个数⼀定是0，那么dp[0] = 0;
其他下标对应的数值呢？
考虑到递推公式的特性，dp[j]必须初始化为⼀个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比
较的过程中被初始值覆盖。
所以下标⾮0的元素都是应该是最大值。
代码如下：
4. 确定遍历顺序
本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。。

所以本题并不强调集合是组合还是排列。
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。
所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内
层for循环遍历物品都是可以的！
那么我采用coins放在外循环，target在内循环的方式。
本题钱币数量可以⽆限使用，那么是完全背包。所以遍历的内循环是正序
综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。

5. 举例推导dp数组

代码：

```C++
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, INT_MAX);
    dp[0] = 0;
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        for (int j = coins[i]; j <= amount; j++) { // 遍历背包
            if (dp[j - coins[i]] != INT_MAX) // 如果dp[j - coins[i]]是初始值则跳过
                dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
        }
    }
    if (dp[amount] == INT_MAX) 
        return -1;
    else
	    return dp[amount];
}
```



### L279. 完全平方数

**[题目](https://leetcode-cn.com/problems/perfect-squares/)**：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

​	给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

​	完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

 ```
示例 1：

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：

输入：n = 13
输出：2
解释：13 = 4 + 9
 ```

提示：

1 <= n <= 104



**思路1**：动态规划。完全背包问题。

这道题的思路和上一题差不多。不同的是，需要自己找出“物品”，这里的数字可以选择的是，从1 -> sqrt(n)，每个数字的“价格”是 i*i。

```C++
int numSquares(int n) {
    vector<int> dp(n+1,INT_MAX);//dp[i]表示和为 i 的完全平方和的最少数量
    int max_sqrt = static_cast<int>(std::sqrt(n));
    dp[0]=0;
    for(int i=1;i<=max_sqrt;++i){//物品
        for(int j=i*i;j<=n;++j){//容量
            if(dp[j-i*i]!=INT_MAX)
                dp[j] = std::min(dp[j],dp[j-i*i]+1);
        }
    }
    return dp[n];
}
```



动规五部曲分析如下：
1. 确定dp数组（dp table）以及下标的含义
dp[i]：和为i的完全平方数的最少数量为dp[i]
2. 确定递推公式
dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。
此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);
3. dp数组如何初始化
dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]⼀定是0。
有同学问题，那0 * 0 也算是⼀种啊，为啥dp[0] 就是 0呢？
看题⽬描述，找到若⼲个完全平方数（比如 1, 4, 9, 16, ...），题⽬描述中可没说要从0开始，dp[0]=0完
全是为了递推公式。
⾮0下标的dp[j]应该是多少呢？
从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，所以⾮0下标的dp[i]⼀
定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。
4. 确定遍历顺序
我们知道这是完全背包，所以本题外层for遍历背包，里层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！



### L139. 单词拆分



## 打家劫舍

### L198. 打家劫舍



### L213. 打家劫舍II



### L337. 打家劫舍III





## 买股票



### J64. 股票的最大利润

[题目](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)：同L121。

### L121. 买卖股票的最佳时机

**[题目](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)**：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 ```
示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 ```


提示：

1 <= prices.length <= 105
0 <= prices[i] <= 104



**思路1**：暴力法（超时）。



**思路2**：贪心算法。

遍历时记录最小值，并记录获取的最大收益即可。

```C++
int maxProfit(vector<int>& prices) {
    int low=prices[0];
    int max_value=0;
    for(int i=1;i<prices.size();++i){
        low=std::min(low,prices[i]);
        max_value=std::max(max_value,prices[i]-low);
    }
    return max_value;
}
```

或：

```C++
int maxProfit(vector<int>& prices) {
    if(prices.empty()) return 0;
    //一次遍历
    int ans=0;
    int min=prices[0];
    for(int x : prices){
        int d = x-min;
        if(d<0) min=x;
        else if(d > ans) ans=d;
    }
    return ans;
}
```



**思路3**：动态规划。



**3.1 转换为最大连续子数组和。**

最大连续子数组和的值即为最高收益。注意需要判断是否收益是否小于0

```C++
int maxProfit(vector<int>& prices) {
    if(prices.size()==1) return 0;
    //转换为最大连续子数组问题
    vector<int> arr(prices.size()-1);
    for(int i=0;i<prices.size()-1;++i)
        arr[i]=prices[i+1]-prices[i];
    vector<int> dp(arr.size(),0);
    dp[0]=arr[0];
    for(int i=1;i<arr.size();++i){
        dp[i] = std::max(dp[i-1]+arr[i],arr[i]);
    }
    int max=*std::max_element(dp.begin(),dp.end());
    return max>0?max:0;
}
```



**3.2 直接使用动态规划。**

使用「现金数」这个说法主要是为了体现 买入股票手上的现金数减少，卖出股票手上的现金数增加 这个事实；
「现金数」等价于题目中说的「利润」，即先买入这只股票，后买入这只股票的差价；因此在刚开始的时候，我们的手上肯定是有一定现金数能够买入这只股票，即刚开始的时候现金数肯定不为 0，但是写代码的时候可以设置为 0。

(1).**确定dp数组（dp table）以及下标的含义**
`dp[i][0] `表示第i天**持有**股票所得最多现金 。这里可能有同学疑惑，本题中只能买卖⼀次，持有股票之后哪还有现金呢？其实⼀开始现金是0，那么加入第i天买入股票现金就是 `-prices[i]`， 这是⼀个负数。
`dp[i][1]` 表示第i天**不持有**股票所得最多现金。注意这里说的是“持有”。“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态。

(2).**确定递推公式**
第i天结束后**持有**股票即`dp[i][0]`， 那么可以由两个状态推出来：第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`； 之前不持有股票，且第i天买入股票，所得现金就是买入今天的股票后所得现金即：`-prices[i]`。那么`dp[i][0]`应该选所得现金最大的，所以`dp[i][0] = max(dp[i - 1][0], -prices[i]);`
第i天结束后**不持有**股票即`dp[i][1]`， 也可以由两个状态推出来：第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金，即：`dp[i - 1][1]`；之前已经持有股票了，则第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`,同样`dp[i][1]`取最大的，`dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`。

**(3) dp数组如何初始化**
	由递推公式 `dp[i][0] = max(dp[i - 1][0], -prices[i]);` 和 `dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`可以看出，其基础都是要从`dp[0][0]`和`dp[0][1]`推导出来。那么`dp[0][0]`表示第0天持有股票，此时的持有股票就⼀定是买入股票了，因为不可能有前⼀天推出来，所以`dp[0][0] -= prices[0]`；`dp[0][1]`表示第0天不持有股票，不持有股票那么现金就是0，所以`dp[0][1] = 0`。

**(4)确定遍历顺序**
	从递推公式可以看出`dp[i]`都是有`dp[i - 1]`推导出来的，那么⼀定是从前向后遍历。

**(5)举例推导dp数组**

```C++
int maxProfit(vector<int>& prices) {
    int len = prices.size();
    if (len == 0) return 0;
    vector<vector<int>> dp(len, vector<int>(2));//`dp[i][0] `**表示第i天持有股票所得最多现金** 。`dp[i][1]` **表示第i天不持有股票所得最多现金**。
    dp[0][0] -= prices[0];
    dp[0][1] = 0;
    for (int i = 1; i < len; i++) {
        dp[i][0] = max(dp[i - 1][0], -prices[i]);//情况1：第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金； 情况2：第i天买入股票，所得现金就是买入今天的股票后所得现金即：`-prices[i]`。
        dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);//情况1：第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`；第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`
    }
    return dp[len - 1][1];
}
```





### L122. 买卖股票的最佳时机II

**[题目](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)**：给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。
返回 你能获得的 最大 利润 。

 ```C++
示例 1:
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:
输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:
输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
 ```


提示：

1 <= prices.length <= 3 * 104
0 <= prices[i] <= 104



**思路1**：贪心。

```C++
int maxProfit(vector<int>& prices) {
    int earning=0;
    int start=-1;
    for(int i=0;i<prices.size()-1;++i){
        if(start<0 && prices[i+1]>prices[i]){
            start=i;
        }
        else if(start>=0 && prices[i+1]<prices[i]){
            earning += prices[i]-prices[start];
            start=-1;
        }
    }
    if(start>=0)
        earning += *(prices.end()-1)-prices[start];
    return earning;
}
```



**思路2**：转换为差分数组。

只要 prices[i+1]-prices[i]>0，则sum+=prices[i+1]-prices[i]；

```C++
int maxProfit(vector<int>& prices) {
    const int N = prices.size();
    if(N==1) return 0;
    int sum = 0;
    for(int i=0;i<N-1;++i){
        if(int differ = prices[i+1]-prices[i];differ>0)
            sum+=differ;
    }
    return sum;
}
```



**思路3**：动态规划。

注意这里和L121唯⼀不同的地方，就是推导`dp[i][0]`的时候，第i天买入股票的情况。在L121中，因为股票全程只能买卖⼀次，所以如果买入股票，那么第i天持有股票即`dp[i][0]`⼀定就是` -prices[i]`。而本题，因为⼀只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。那么第i天持有股票即`dp[i][0]`，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`。



(1).**确定dp数组（dp table）以及下标的含义**
`dp[i][0] `表示第i天**持有**股票所得最多现金 。
`dp[i][1]` 表示第i天**不持有**股票所得最多现金。

(2).**确定递推公式**
第i天结束后**持有**股票即`dp[i][0]`， 那么可以由两个状态推出来：

​	第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`； 

​	之前不持有股票，且第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`

第i天结束后**不持有**股票即`dp[i][1]`， 也可以由两个状态推出来：

​	第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金，即：`dp[i - 1][1]`；

​	之前已经持有股票了，则第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`,同样`dp[i][1]`取最大的，`dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`。

**(3) dp数组如何初始化**
	由递推公式 `dp[i][0] = max(dp[i - 1][0], -prices[i]);` 和 `dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`可以看出，其基础都是要从`dp[0][0]`和`dp[0][1]`推导出来。那么`dp[0][0]`表示第0天持有股票，此时的持有股票就⼀定是买入股票了，因为不可能有前⼀天推出来，所以`dp[0][0] -= prices[0]`；`dp[0][1]`表示第0天不持有股票，不持有股票那么现金就是0，所以`dp[0][1] = 0`。

**(4)确定遍历顺序**
	从递推公式可以看出`dp[i]`都是有`dp[i - 1]`推导出来的，那么⼀定是从前向后遍历。

**(5)举例推导dp数组**

代码：

```C++
int maxProfit(vector<int>& prices) {
    if(prices.size()==1) return 0;
    vector<vector<int>> dp(prices.size(),vector<int>(2));
    dp[0][0] = -prices[0];
    dp[0][1] = 0;
    for(int i=1;i<prices.size();++i){
        dp[i][0] = std::max(dp[i-1][0],dp[i-1][1]-prices[i]);//保持或买入
        dp[i][1] = std::max(dp[i-1][1],dp[i-1][0]+prices[i]);//保持或卖出
    }
    return dp[prices.size()-1][1];
}
```





### L123. 买卖股票的最佳时机 III

**[题目](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)**：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
示例 1:
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

示例 2：
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3：
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。

示例 4：
输入：prices = [1]
输出：0
```

提示：

1 <= prices.length <= 105
0 <= prices[i] <= 105



**思路1**：动态规划。



### L188. 买卖股票的最佳时机IV



### L309. 买卖股票的最佳时机含冷冻期



### L714. 买卖股票的最佳时机含手续费







## 子序列



### L300.最长递增子序列

**[题目](https://leetcode-cn.com/problems/longest-increasing-subsequence/)**：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```
示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2：
输入：nums = [0,1,0,3,2,3]
输出：4

示例 3：
输入：nums = [7,7,7,7,7,7,7]
输出：1
```


提示：

1 <= nums.length <= 2500
-104 <= nums[i] <= 104



**思路1**：动态规划。

​    定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。

我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：

```
dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]
```

​    即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。

​    最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。

$\text{LIS}_{\textit{length}}= \max(\textit{dp}[i])$, 其中 , $0\leq i < n$

```C++
int lengthOfLIS(vector<int>& nums) {
    int n = (int)nums.size();
    if (n == 0) {
        return 0;
    }
    vector<int> dp(n, 0);//定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。
    for (int i = 0; i < n; ++i) {
        dp[i] = 1;
        for (int j = 0; j < i; ++j) {
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    return *max_element(dp.begin(), dp.end());
}
```



**思路2**：贪心+二分查找



```C++
int lengthOfLIS(vector<int>& nums) {
    int len = 1, n = (int)nums.size();
    if (n == 0) {
        return 0;
    }
    vector<int> d(n + 1, 0);
    d[len] = nums[0];
    for (int i = 1; i < n; ++i) {
        if (nums[i] > d[len]) {
            d[++len] = nums[i];
        } 
        else {
            int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
            while (l <= r) {
                int mid = (l + r) >> 1;
                if (d[mid] < nums[i]) {
                    pos = mid;
                    l = mid + 1;
                } 
                else {
                    r = mid - 1;
                }
            }
            d[pos + 1] = nums[i];
        }
    }
    return len;
}
```





### L674.最长连续递增序列

**[题目](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)**：给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

 ```
示例 1：
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 

示例 2：
输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
 ```


提示：

1 <= nums.length <= 10^4
-10^9 <= nums[i] <= 10^9



**思路1**：贪心。

遍历每个元素nums[i]，一旦nums[i] <= nums[i-1]，则表明到 前面的上升子序列到nums[i-1]为止。记录最长的上升子序列max_len。

```C++
int findLengthOfLCIS(vector<int>& nums) {
    int start=0;
    int max_len=1;
    for(int i=1;i<nums.size();++i){
        if(nums[i] <= nums[i-1]){
            max_len = std::max(max_len , i - start);
            start = i;
        }
    }
    max_len = std::max(max_len,(int)nums.size()-start);//若整个数组全部是上升序列
    return max_len;
}
```



**思路2**：动态规划。

1. 确定dp数组（dp table）以及下标的含义
dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]。
注意这里的定义，⼀定是以下标i为结尾，并不是说⼀定以下标0为起始位置。
2. 确定递推公式
如果 nums[i + 1] > nums[i]，那么以 i+1 为结尾的数组的连续递增的子序列长度 ⼀定等于 以i为结尾的
数组的连续递增的子序列长度 + 1 。
即：dp[i + 1] = dp[i] + 1;
注意这里就体现出和动态规划：300.最长递增子序列的区别！
因为本题要求连续递增子序列，所以就必要比较nums[i + 1]与nums[i]，而不用去比较nums[j]与
nums[i] （j是在0到i之间遍历）。
既然不用j了，那么也不用两层for循环，本题⼀层for循环就行，比较nums[i + 1] 和 nums[i]。
这里大家要好好体会⼀下！
3. dp数组如何初始化
以下标i为结尾的数组的连续递增的子序列长度最少也应该是1，即就是nums[i]这⼀个元素。所以dp[i]应该初始1;
4. 确定遍历顺序
    从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以⼀定是从前向后遍历。

```C++
int findLengthOfLCIS(vector<int>& nums) {
    if (nums.size() == 0) return 0;
    int result = 1;
    vector<int> dp(nums.size() ,1);
    for (int i = 0; i < nums.size() - 1; i++) {
        if (nums[i + 1] > nums[i]) { // 连续记录
            dp[i + 1] = dp[i] + 1;
        }
        result = std::max(result,dp[i+1]);
    }
    return result;
}
```



### L718.最长重复子数组

**[题目](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)**：给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。

 ```
示例 1：
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。

示例 2：
输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
 ```


提示：

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 100



**思路1**：动态规划。

我的代码：

```C++
int findLength(vector<int>& nums1, vector<int>& nums2) {
    int nums1_size = nums1.size();
    int nums2_size = nums2.size();
    int max_common=0;

    //dp[i][j]表示到nums1[i]相等nums2[j]，且对应的公共子数组的长度
    vector<vector<int>> dp(nums1_size,vector<int>(nums2_size));
    //初始化
    for(int i=0;i<nums1_size;++i){
        if(nums1[i]==nums2[0]){
            dp[i][0]=1;
            max_common = std::max(max_common,dp[i][0]);
        }
    }
    for(int i=0;i<nums2_size;++i){
        if(nums1[0]==nums2[i]){
            dp[0][i]=1;
            max_common = std::max(max_common,dp[0][i]);
        }
    }
    //迭代
    for(int i=1;i<nums1_size;++i){
        for(int j=1;j<nums2_size;++j){
            if(nums1[i]==nums2[j]){
                dp[i][j] = dp[i-1][j-1]+1;
                max_common = std::max(max_common,dp[i][j]);
            }
        }
    }
    return max_common;
}
```

代码随想录：（跟我自己定义的dp数组略有区别）

1. 确定dp数组（dp table）以及下标的含义
`dp[i][j]` ：以下标i-1为结尾的A，和以下标j-1为结尾的B，最长重复子数组长度为`dp[i][j]`。
此时细⼼的同学应该发现，那`dp[0][0]`是什么含义呢？总不能是以下标-1为结尾的A数组吧。
其实`dp[i][j]`的定义也就决定着，我们在遍历`dp[i][j]`的时候i 和 j都要从1开始。
那有同学问了，我就定义dp`[i][j]`为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。不
行么？
行倒是行！ 但实现起来就麻烦⼀点，大家看下⾯的dp数组状态图就明⽩了。
2. 确定递推公式
根据`dp[i][j]`的定义，`dp[i][j]`的状态只能由`dp[i - 1][j - 1]`推导出来。
即当`A[i - 1]` 和`B[j - 1]`相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1`;
根据递推公式可以看出，遍历i 和 j 要从1开始！
3. dp数组如何初始化
根据`dp[i][j]`的定义，`dp[i][0]` 和`dp[0][j]`其实都是没有意义的！
但`dp[i][0]` 和`dp[0][j]`要初始值，因为 为了方便递归公式`dp[i][j] = dp[i - 1][j - 1] + 1`;
所以`dp[i][0]` 和`dp[0][j]`初始化为0。

4. 确定遍历顺序
外层for循环遍历A，内层for循环遍历B。
那⼜有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？
也行，⼀样的，我这里就用外层for循环遍历A，内层for循环遍历B了。
同时题⽬要求长度最长的子数组的长度。所以在遍历的时候顺便把`dp[i][j]`的最大值记录下来。

5. 举例推导dp数组
拿示例1中，`A: [1,2,3,2,1]，B: [3,2,1,4,7]`为例，画⼀个dp数组的状态变化。



Carl的代码：

```C++
int findLength(vector<int>& A, vector<int>& B) {
    vector<vector<int>> dp (A.size() + 1, vector<int>(B.size() + 1, 0));
    int result = 0;
    for (int i = 1; i <= A.size(); i++) {
        for (int j = 1; j <= B.size(); j++) {
            if (A[i - 1] == B[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            if (dp[i][j] > result) result = dp[i][j];
        }
    }
    return result;
}
```





### L1143.最长公共子序列

**[题目](https://leetcode-cn.com/problems/longest-common-subsequence/)**：给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

 ```
示例 1：
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。

示例 2：
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。

示例 3：
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
 ```


提示：
1 <= text1.length, text2.length <= 1000
text1 和 text2 仅由小写英文字符组成。



**思路1**：动态规划。

1. 确定dp数组（dp table）以及下标的含义
`dp[i][j]`：长度为`[0, i - 1]`的字符串text1与长度为`[0, j - 1]`的字符串text2的最长公共子序列为`dp[i][j]`
有同学会问：为什么要定义长度为`[0, i - 1]`的字符串text1，定义为长度为`[0, i]`的字符串text1不⾹么？
这样定义是为了后⾯代码实现方便，如果⾮要定义为为长度为[0, i]的字符串text1也可以，大家可以试⼀试！
2. 确定递推公式
主要就是两大情况： `text1[i - 1]` 与 `text2[j - 1]`相同，`text1[i - 1]` 与 `text2[j - 1]`不相同
* 如果`text1[i - 1]` 与 `text2[j - 1]`相同，那么找到了⼀个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1;`
* 如果`text1[i - 1]` 与 `text2[j - 1]`不相同，那就看看`text1[0, i - 2]`与`text2[0, j - 1]`的最长公共子序列 和 `text1[0, i - 1]`与`text2[0, j - 2]`的最长公共子序列，取最大的。
即：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);`

```C++
if (text1[i - 1] == text2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + 1;
} else {
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
}
```

3. dp数组如何初始化
先看看`dp[i][0]`应该是多少呢？
`test1[0, i-1]`和空串的最长公共子序列⾃然是0，所以`dp[i][0] = 0`;
同理`dp[0][j]`也是0。
其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统⼀初始为0。
代码：

```C++
vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
```

4. 确定遍历顺序
从递推公式，可以看出，有三个方向可以推出`dp[i][j]`，如图：

那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩
阵。

5. 举例推导dp数组
以输入：`text1 = "abcde", text2 = "ace"` 为例

```C++
int longestCommonSubsequence(string text1, string text2) {
    vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
    for (int i = 1; i <= text1.size(); i++) {
        for (int j = 1; j <= text2.size(); j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[text1.size()][text2.size()];
}
```







### L392. 判断子序列

**[题目](https://leetcode-cn.com/problems/is-subsequence/)**：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

```
示例 1：
输入：s = "abc", t = "ahbgdc"
输出：true

示例 2：
输入：s = "axc", t = "ahbgdc"
输出：false
```


提示：

0 <= s.length <= 100
0 <= t.length <= 10^4
两个字符串都只由小写字符组成。



**思路1**：双指针。

本题询问的是，s 是否是 t 的子序列，因此只要能找到任意一种 s 在 t 中出现的方式，即可认为 s 是 t 的子序列。

而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。

假定当前需要匹配字符 c，而字符 c 在 t 中的位置 $x_1$ 和 $x_2$  出现（$x_1 < x_2$ ），那么贪心取 $x_1$  是最优解，因为 $x_2$  后面能取到的字符，$x_1$  也都能取到，并且通过 $x_1$  与 $x_2$  之间的可选字符，更有希望能匹配成功。

这样，我们初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 tt 的下一个字符匹配 s。

最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。

```C++
bool isSubsequence(string s, string t) {
    int s_i=0,t_i=0;
    while(s_i<s.size() && t_i<t.size()){
        if(s[s_i]==t[t_i]){
            s_i++;
            t_i++;
        }
        else{
            t_i++;
        }
    }
    if(s_i==s.size())
        return true;
    else
        return false;
}
```



**思路2**：动态规划。

我的代码：

```C++
bool isSubsequence(string s, string t) {
    if(s.empty()) 
        return true;
    else if(s.size()>t.size())
        return false;
    //定义：dp[i][j]表示s[0,i]是否t[0,j]的公共子序列的长度
    vector<vector<int>> dp(s.size(),vector<int>(t.size()));
    //初始化
    for(int i=0;i<t.size();++i){
        if(s[0]==t[i])
            dp[0][i]=1;
        else
            if(i>0) dp[0][i]=dp[0][i-1];
    }
    //迭代
    for(int i=1;i<s.size();++i){
        for(int j=1;j<t.size();++j){
            if(s[i]==t[j])
                dp[i][j] = dp[i-1][j-1]+1;
            else
                dp[i][j] = dp[i][j-1];
        }
    }
    return dp[s.size()-1][t.size()-1]==s.size();
}
```

1. 确定dp数组（dp table）以及下标的含义
    `dp[i][j]` 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为`dp[i][j]`。
    注意这里是判断s是否为t的子序列。即t的长度是大于等于s的。有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？用i来表示也可以！但我统⼀以下标i-1为结尾的字符串来计算，这样在下⾯的递归公式中会容易理解⼀些，如果还有疑惑，可以继续往下看。
2. 确定递推公式
    在确定递推公式的时候，⾸先要考虑如下两种操作，整理如下：
  * `if (s[i - 1] == t[j - 1])` ：t中找到了⼀个字符在s中也出现了
  * `if (s[i - 1] != t[j - 1])`：  相当于t要删除元素，继续匹配

   `if (s[i - 1] == t[j - 1])`，那么`dp[i][j] = dp[i - 1][j - 1] + 1;`，因为找到了⼀个相同的字符，相同子序列长度⾃然要在`dp[i-1][j-1]`的基础上加1（如果不理解，在回看⼀下`dp[i][j]`的定义）
   `if (s[i - 1] != t[j - 1])`，此时相当于t要删除元素，t如果把当前元素`t[j - 1]`删除，那么`dp[i][j]`的数值就是 看`s[i - 1]`与 `t[j - 2]`的比较结果了，即：`dp[i][j] = dp[i][j - 1];`

3. dp数组如何初始化
    从递推公式可以看出`dp[i][j]`都是依赖于`dp[i - 1][j - 1]` 和 `dp[i][j - 1]`，所以`dp[0][0]`和`dp[i][0]`是⼀定要初始化的。
    这里大家已经可以发现，在定义`dp[i][j]`含义的时候为什么要表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为`dp[i][j]`。
    如果要是定义的`dp[i][j]`是以下标i为结尾的字符串s和以下标j为结尾的字符串t，初始化就比较麻烦了。这里`dp[i][0]`和`dp[0][j]`是没有含义的，仅仅是为了给递推公式做前期铺垫，所以初始化为0。
4. 确定遍历顺序
同理从从递推公式可以看出`dp[i][j]`都是依赖于`dp[i - 1][j - 1]` 和 `dp[i][j - 1]`，那么遍历顺序也应该是从上到下，从左到右
5. 举例推导dp数组
以示例⼀为例，输入：`s = "abc", t = "ahbgdc`



```C++
bool isSubsequence(string s, string t) {
    vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
    for (int i = 1; i <= s.size(); i++) {
        for (int j = 1; j <= t.size(); j++) {
            if (s[i - 1] == t[j - 1]) 
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else 
                dp[i][j] = dp[i][j - 1];
        }
    }
    if (dp[s.size()][t.size()] == s.size()) return true;
    return false;
}
```








### L115. 不同的子序列

**[题目](https://leetcode-cn.com/problems/distinct-subsequences/)**：给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。

```
示例 1：
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabb b it
ra b bbit
rab b bit

示例 2：
输入：s = "babgbag", t = "bag"
输出：5
解释：
如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
ba b g bag
ba bgba g
b abgb ag
ba b gb ag
babg bag
```


提示：

0 <= s.length, t.length <= 1000
s 和 t 由英文字母组成



**思路1**：暴力法(超时)。

通过回溯得到s的所有子序列，判断其中与t相等的子序列的数量。

```C++
class Solution {
private:
    string path;
    int counter{0};
    void backtrack(string &s,int index, string &t){
        for(int i=0;i<path.size();++i){//剪枝
            if(path[i]!=t[i])
                return;
        }
        if(path.size()>=t.size()){
            if(path==t){
                counter++;
            }
            return ;
        }
        for(int i=index;i<s.size();++i){
            path.push_back(s[i]);
            backtrack(s,i+1,t);
            path.pop_back();
        }
    }
public:
    int numDistinct(string s, string t) {
        backtrack(s,0,t);
        return counter;
    }
};
```



**思路2**：动态规划。









### L1035.不相交的线

**[题目](https://leetcode-cn.com/problems/uncrossed-lines/)**：在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：

`nums1[i] == nums2[j]`

且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

 ```
示例 1：
输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。

示例 2：
输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出：3

示例 3：
输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2
 ```


提示：

1 <= nums1.length, nums2.length <= 500
1 <= nums1[i], nums2[j] <= 2000





### L583. 两个字符串的删除操作

**[题目](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)**：给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。

每步 可以删除任意一个字符串中的一个字符。

```
示例 1：
输入: word1 = "sea", word2 = "eat"
输出: 2
解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"

示例  2:
输入：word1 = "leetcode", word2 = "etco"
输出：4
```


提示：

1 <= word1.length, word2.length <= 500
word1 和 word2 只包含小写英文字母



**思路1**：动态规划。

1. 确定dp数组（dp table）以及下标的含义
dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。
2. 确定递推公式
* 当`word1[i - 1]` 与 `word2[j - 1]`相同的时候
* 当`word1[i - 1]` 与 `word2[j - 1]`不相同的时候

​    当`word1[i - 1]` 与 `word2[j - 1]`相同的时候，`dp[i][j] = dp[i - 1][j - 1]`; 
`当word1[i - 1]` 与 `word2[j - 1]`不相同的时候，有三种情况：

* 情况⼀：删`word1[i - 1]`，最少操作次数为`dp[i - 1][j] + 1`
* 情况⼆：删`word2[j - 1]`，最少操作次数为`dp[i][j - 1] + 1`
* 情况三：同时删`word1[i - 1]`和`word2[j - 1]`，操作的最少次数为`dp[i - 1][j - 1] + 2`

  那最后当然是取最⼩值，所以当`word1[i - 1]` 与 `word2[j - 1]`不相同的时候，递推公式：

`dp[i][j] =min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});`

3. dp数组如何初始化
    从递推公式中，可以看出来，`dp[i][0]` 和 `dp[0][j]`是⼀定要初始化的。`dp[i][0]`：word2为空字符串，以i-1为结尾的字符串word2要删除多少个元素，才能和word1相同呢，很明显`dp[i][0] = i`。

4. 确定遍历顺序
从递推公式 `dp[i][j] = min(dp[i - 1][j - 1] + 2, min(dp[i - 1][j], dp[i][j - 1]) + 1);` 和`dp[i][j] = dp[i - 1][j - 1]`可以看出`dp[i][j]`都是根据左上⽅、正上⽅、正左⽅推出来的。所以遍历的时候⼀定是从上到下，从左到右，这样保证`dp[i][j]`可以根据之前计算出来的数值进⾏计算。
5. 举例推导dp数组
以word1:"sea"，word2:"eat"为例

```C++
int minDistance(string word1, string word2) {
    int n = word1.size();
    int m = word2.size();
    //dp[i][j]表示使word1[0,i-1]和word2[0,j-1]的相同的最小步数
    vector<vector<int>> dp(n+1,vector<int>(m+1));
    //初始化
    for(int i=0;i<=n;++i)dp[i][0] = i;
    for(int i=0;i<=m;++i)dp[0][i] = i;
    //迭代
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(word1[i-1]==word2[j-1])//相等，步数不变
                dp[i][j]= dp[i-1][j-1];
            else //步数要么是删除word1，要么删除word2，要么都删除
                dp[i][j] = std::min(std::min(dp[i][j-1],dp[i-1][j])+1,dp[i-1][j-1]+2);
        }
    }
    return dp[n][m];
}
```







### L72. 编辑距离

**[题目](https://leetcode-cn.com/problems/edit-distance/)**：给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

* 插入一个字符
* 删除一个字符
* 替换一个字符

```
示例 1：
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

示例 2：
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```


提示：

0 <= word1.length, word2.length <= 500
word1 和 word2 由小写英文字母组成



**思路1**：动态规划。

1. 确定dp数组（dp table）以及下标的含义
    `dp[i][j]` 表示以下标`i-1`为结尾的字符串word1，和以下标`j-1`为结尾的字符串word2，最近编辑距离为`dp[i][j]`。
2. 确定递推公式
    在确定递推公式的时候，⾸先要考虑清楚编辑的⼏种操作，整理如下：
```C++
if (word1[i - 1] == word2[j - 1])
	不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```
  也就是如上4种情况。
  `if (word1[i - 1] == word2[j - 1])` 那么说明不⽤任何编辑， `dp[i][j]` 就应该是 `dp[i - 1][j - 1]` ，即 `dp[i][j] = dp[i - 1][j - 1];`
  `if (word1[i - 1] != word2[j - 1])` ，此时就需要编辑了，如何编辑呢？
* 操作⼀：word1删除⼀个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上⼀个操作。即 `dp[i][j] = dp[i - 1][j] + 1;`
* 操作⼆：word2删除⼀个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上⼀个操作。即 `dp[i][j] = dp[i][j - 1] + 1;`
  这⾥有同学发现了，怎么都是删除元素，添加元素去哪了。word2添加⼀个元素，相当于word1删除⼀个元素，例如 word1 = "ad" ，word2 = "a" ， word1 删除元素 'd' 和 word2 添加⼀个元素 'd' ，变成 word1="a", word2="ad" ， 最终的操作数是⼀样！
* 操作三：替换元素， word1 替换 word1[i - 1] ，使其与 word2[j - 1] 相同，此时不⽤增加元素，那么以下标 i-2 为结尾的 word1 与 j-2 为结尾的 word2 的最近编辑距离 加上⼀个替换元素的操作。即 `dp[i][j] = dp[i - 1][j - 1] + 1;`
  综上，当 `if (word1[i - 1] != word2[j - 1])` 时取最⼩的，即： `dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;`,递归公式代码如下：
```
  if (word1[i - 1] == word2[j - 1]) {
   dp[i][j] = dp[i - 1][j - 1];
  }
  else {
   dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1; }
```
  3. dp数组如何初始化

  在回顾⼀下`dp[i][j]`的定义。
```
dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。
```
  那么`dp[i][0]` 和 `dp[0][j]` 表示什么呢？  `dp[i][0]` ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为`dp[i][0]`。
  那么`dp[i][0]`就应该是i，对word1⾥的元素全部做删除操作，即：`dp[i][0] = i`;同理`dp[0][j] = j`;所以C++代码如下：

```C++
    for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
    for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
```
  4. 确定遍历顺序

  从如下四个递推公式：
```
dp[i][j] = dp[i - 1][j - 1]
dp[i][j] = dp[i - 1][j - 1] + 1
dp[i][j] = dp[i][j - 1] + 1
dp[i][j] = dp[i - 1][j] + 1
```
    可以看出`dp[i][j]`是依赖左⽅，上⽅和左上⽅元素的

  5. 举例推导dp数组

  以示例1，输⼊：word1 = "horse", word2 = "ros"为例。

代码：

```C++
int minDistance(string word1, string word2) {
    if(word1.size()==0) return word2.size();
    else if(word2.size()==0) return word1.size();
    int n = word1.size();
    int m = word2.size();
    //dp数组, dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，的最近编辑距离
    vector<vector<int>> dp(n+1,vector<int>(m+1));
    //初始化
    for(int i=0;i<=n;++i) dp[i][0]=i;
    for(int i=0;i<=m;++i) dp[0][i]=i;
    //递推公式：
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            if(word1[i-1]==word2[j-1])
                dp[i][j] = dp[i-1][j-1];
            else
                dp[i][j] = std::min(dp[i][j-1]+1,min(dp[i-1][j]+1,dp[i-1][j-1]+1));
        }
    }
    return dp[n][m];
}
```





### L647. 回文子串

**[题目](https://leetcode-cn.com/problems/palindromic-substrings/)**：给给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

```
示例 1：
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"

示例 2：
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

提示：

1 <= s.length <= 1000
s 由小写英文字母组成



**思路1**：动态规划。

1. 确定dp数组（dp table）以及下标的含义
    布尔类型的`dp[i][j]`：表示区间范围`[i,j]` （注意是左闭右闭）的⼦串是否是回回文子串，如果是`dp[i][j]`为true，否则为false。

2. 确定递推公式
在确定递推公式时，就要分析如下⼏种情况。
整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。当s[i]与s[j]不相等，那没啥好说的了，`dp[i][j]`⼀定是false。 当`s[i]`与`s[j]`相等时，这就复杂⼀些了，有如下三种情况
* 情况⼀：下标i 与 j相同，同⼀个字符例如a，当然是回文串
* 情况⼆：下标i 与 j相差为1，例如aa，也是回文串
* 情况三：下标：i 与 j相差⼤于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文⼦串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看`dp[i + 1][j - 1]`是否为true。
以上三种情况分析完了，那么递归公式如下：
```C++
if (s[i] == s[j]) {
    if (j - i <= 1) { // 情况⼀ 和 情况⼆
        result++;
        dp[i][j] = true;
    } else if (dp[i + 1][j - 1]) { // 情况三
        result++;
        dp[i][j] = true;
    }
}
```
   result就是统计回文子串的数量。注意这⾥我没有列出当s[i]与s[j]不相等的时候，因为在下⾯`dp[i][j]`初始化的时候，就初始为false。
3. dp数组如何初始化
    `dp[i][j]`可以初始化为true么？ 当然不⾏，怎能刚开始就全都匹配上了。所以`dp[i][j]`初始化为false。

4. 确定遍历顺序
    遍历顺序可有有点讲究了。⾸先从递推公式中可以看出，情况三是根据`dp[i + 1][j - 1]`是否为true，在对`dp[i][j]`进⾏赋值true的。`dp[i + 1][j - 1]` 在 `dp[i][j]`的左下⻆，如果这矩阵是从上到下，从左到右遍历，那么会⽤到没有计算过的`dp[i + 1][j - 1]`，也就是根据不确定是不是回文的区间`[i+1,j-1]`，来判断了`[i,j]`是不是回文，那结果⼀定是不对的。
    
    **所以⼀定要从下到上，从左到右遍历**，这样保证`dp[i + 1][j - 1]`都是经过计算的。有的代码实现是优先遍历列，然后遍历⾏，其实也是⼀个道理，都是为了保证`dp[i + 1][j - 1]`都是经过计算的。
    
5. 举例推导dp数组
     举例，输⼊："aaa"，

```C++
int countSubstrings(string s) {
    int n=s.size();
    //dp[i][j]表示s[i,j]是否是回文
    vector<vector<bool>> dp(n,vector<bool>(n));
    //迭代,递推公式：
    //if(j==i) dp[i][j] = true;
    //if(j-i == 1) dp[i][j] = dp[i]==dp[j];
    //else dp[i][j] = dp[i]==dp[j] && dp[i+1][j-1];
    for(int i=n-1;i>=0;i--){
        for(int j=0;j<n;j++){
            if(j<i)
                continue;
            if(i==j)
                dp[i][j]=true;
            else if(j-i==1)
                dp[i][j] = (s[i]==s[j]);
            else
                dp[i][j] = (s[i]==s[j]) && dp[i+1][j-1];
        }
    }
    int counter=0;
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j)
            if(dp[i][j]) counter++;
    return counter;
}
```



**思路2**：双指针法。



### L516. 最长回文子序列
































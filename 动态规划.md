#  动态规划 

## 动态规划基础

1. 确定dp数组（dp table）以及下标的含义 

2. 确定递推公式 

3. dp数组如何初始化 

4. 确定遍历顺序 

5. 举例推导dp数组



### 01背包问题

**题目：**有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。

**思路1**：二维动态规划。

* 1.确定数组下标以及下标的含义。使用二维数组，`dp[i][j]`表示选择第`i`件物体放到容量为`j`的背包时，价值总和是多少。

* 2.递推公式。`dp[i][j]`是选第i件物体的时候，那么上一步应该是选择第`j-1`件物体。当不选择第j件物体时，容量不变，价值总和不变，`dp[i][j] = dp[i-1][j]`；当选择第j件物体时，上一时刻的背包容量应该为`j-weight[j]`，`dp[i][j]=d[i][j-weight[j]] + value[i]`。综上：

`dp[i][j] = max(dp[i-1][j], d[i][j-weight[j]] + value[i])`

* 3.初始化。当背包容量为时，价值总和也为0，则`dp[i][0] = 0`。当选择第0件物品时，当背包容量小于weight[0]时，价值总和为0。当背包容量大于等于weight[0]时，价值总和为value[0]。

* 4.变量顺序。外层循环变量物体，内层循环变量容量。

* 5.举例。



**思路2**：一维动态规划。（滚动数组）

* 1.确定dp数组的定义。
  	在⼀维dp数组中，`dp[j]`表示：容量为j的背包，所背的物品价值可以最⼤为`dp[j]`。

* 2.递归公式。

  如何得到dp[j]，在迭代i中，dp[j]要么不选物体i，此时`dp[j]=dp[j]`；要么选物体i，此时`d[j] = d[j- weight[i]]+value[i]`。选择其中最有价值的一个，即：`dp[j] = max(dp[j], d[j- weight[i]]+value[i])`。

* 3.初始化。

  初始化时，表示选择物体0时，此时对于容量j 小于weight[0]时，dp[j]=0；对于容量j 大于等于weight[0]时，`dp[j]=value[0]`。

* 4.遍历。

  外层循环表示物体选择的顺序，`i=0 -> n`；

  内层循环表示背包容量的变化，遍历方式从大到小，`j=bagweight -> weight[i]`。这样才能保证物体i只被放入到背包一次。





### 完全背包

​	有N件物品和⼀个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品都有⽆限个（也就是可以放⼊背包多次），求解将哪些物品装⼊背包⾥物品价值总和最⼤。完全背包和01背包问题唯⼀不同的地⽅就是，每种物品有⽆限件。

回顾01背包的核心代码：

```C++
for(int i = 0; i < weight.size(); i++) // 遍历物品
	for(int j = bagWeight; j >= weight[i]; j--) // 遍历背包容量
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

​	01背包内嵌的循环是从⼤到⼩遍历，为了保证每个物品仅被添加⼀次。

​	⽽完全背包的物品是可以添加多次的，所以要从⼩到⼤去遍历，即：

```C++
for(int i = 0; i < weight.size(); i++) // 遍历物品
	for(int j = weight[i]; j < bagWeight ; j++) // 遍历背包容量
 		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```





**如果求组合数就是外层for循环遍历物品，内层for遍历背包。**
**如果求排列数就是外层for遍历背包，内层for循环遍历物品。**





## 基础题目

### L509. 斐波那契数

**题目**：斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。

**思路1**：递归。

```C++
int fib(int n) {
    if(n==0)
        return 0;
    else if(n==1)
        return 1;
    else
        return fib(n-1)+fib(n-2);
}
```

**思路2**：迭代。

```C++
int fib(int n) {
    int last_1=1;
    int last_2=0;
    if(n==1)return 1;
    int curr=0;
    for(int i=1;i<n;++i){
        curr=last_1+last_2;
        last_2=last_1;
        last_1=curr;
    }
    return curr;
}
```

**思路3**：一维动态规划。

1 dp数组中元素a[i]表示斐波那契数F(i)。

2 递推公式：a[i]=a[i-1]+a[i-2]

3 初始化：a[0]=0, a[1]=1

4 遍历顺序：i=0->i=n

```C++
int fib(int n) {
    if(n==0) return 0;
    else if(n==1) return 1;
    vector<int> dp(n+1);
    dp[0]=0;
    dp[1]=1;
    for(int i=2;i<=n;++i) dp[i]=dp[i-1]+dp[i-2];
    return dp[n];
}
```



### L70. 爬楼梯

**题目**：假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 *n* 是一个正整数。

**思路1**：一维动态规划。

1 dp元素：dp[i]表示爬升到第 i 个台阶的所有方法。

2 递归公式： dp[i] = dp[i-1]+dp[i-2]

3 初始化：dp[0]=0,dp[1]=1,dp[2]=2;

4 遍历顺序：i=0到i=n

```C++
int climbStairs(int n) {
    if(n==0)return 0;
    else if(n==1) return 1;
    else if(n==2) return 2;
    vector<int> dp(n+1);
    dp[0]=0;
    dp[1]=1;
    dp[2]=2;
    for(int i=3;i<=n;++i)
        dp[i]=dp[i-1]+dp[i-2];
    return dp[n];
}
```

**思路2**：一维动态规划，但是不构造dp数组。

**思路3**：矩阵快速幂。

**思路4**：通项公式。









### L746. 使用最小花费爬楼梯

**题目**：给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**思路1**：动态规划。

1 数组元素：dp[i]表示到达第 i 阶所需要的最小花费。

2 递归公式：dp[i]= min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])

3 初始化：dp[0] = 0, dp[1]=0.这是因为可以选择从第0阶或第1阶开始爬楼梯。

4 遍历：从i=0到i=n

5 举例

```C++
int minCostClimbingStairs(vector<int>& cost) {
    vector<int> dp(cost.size()+1);
    dp[0]=0;
    dp[1]=0;
    for(int i=2;i<=cost.size();++i)
        dp[i] = std::min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
    return dp[cost.size()];
}
```

优化：可以将时间复杂度优化为O(3)





### L62. 不同路径

**题目**：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**思路1**：动态规划。二维动态规划。

1 每个元素`dp[i][j]`表示第(i,j)网格的路径的数量。

2 递归公式：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

3 初始化： `dp[0][0] = 1, dp[i][0] = 1,  dp[0][j] = 1`。

4 遍历：从左到右，从上到下遍历。

5 举例。

代码：

```C++
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m,vector<int>(n));
    //初始化
    dp[0][0]=1;
    for(int i=1;i<m;++i)dp[i][0] = 1;
    for(int j=1;j<n;++j)dp[0][j] = 1;
    //遍历
    for(int i=1;i<m;++i)
        for(int j=1;j<n;++j)
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
    return dp[m-1][n-1];
}
```



**思路2**：组合数学。





### L63. 不同路径 II

**题目**：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

 网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。 

**思路1**：动态规划。二维动态规划。

这道题和上一题差不多，唯一的区别是，在计算dp[i] [j]的时候，需要判断其 上方网格 左方网格 和当前网格是否存在障碍物。

```C++
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    int m=obstacleGrid.size();
    int n=obstacleGrid[0].size();
    vector<vector<int>> dp(m,vector<int>(n));
    //初始化
    if(obstacleGrid[0][0]==1) dp[0][0]=0;
    else dp[0][0]=1;
    for(int i=1;i<m;++i){
        if(obstacleGrid[i][0]==1) dp[i][0]=0;
        else dp[i][0]=dp[i-1][0];
    }
    for(int i=1;i<n;++i){
        if(obstacleGrid[0][i]==1) dp[0][i]=0;
        else dp[0][i]=dp[0][i-1];
    }  
	//遍历
    for(int i=1;i<m;++i){
        for(int j=1;j<n;++j){
            if(obstacleGrid[i-1][j]==1 && obstacleGrid[i][j-1]==0 && obstacleGrid[i][j]==0)
                dp[i][j] = dp[i][j-1];
            else if(obstacleGrid[i-1][j]==0 && obstacleGrid[i][j-1]==1 && obstacleGrid[i][j]==0)
                dp[i][j] = dp[i-1][j];
            else if(obstacleGrid[i-1][j]==0 && obstacleGrid[i][j-1]==0 && obstacleGrid[i][j]==0)
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            else
                dp[i][j] = 0;
        }
    }
    return dp[m-1][n-1];
}
```



### L64. 最小路径和

**题目**：给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。



**思路1**：动态规划。

1 dp元素。

​	dp[i] [j]表示从起点到网格(i,j)的最小路径和。

2 递推公式。

```
dp[i][j] = std::min(dp[i][j-1],dp[i-1][j]) + grid[i][j];
```

3 初始化

​	初始化第一列和第一行，其值均为该行或该列的累积和。

4 遍历方式

​	外层：从上到下

​	内层：从左到右。

5 举例。

代码：

```C++
int minPathSum(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    //dp[i][j]表示到位置i,j的最小路径和
    vector<vector<int>> dp(m,vector<int>(n));
    //初始化
    dp[0][0] = grid[0][0];
    for(int i=1;i<n;++i) dp[0][i] = dp[0][i-1] + grid[0][i];
    for(int i=1;i<m;++i) dp[i][0] = dp[i-1][0] + grid[i][0];
    //遍历
    for(int i=1;i<m;++i){
        for(int j=1;j<n;++j){
            dp[i][j] = std::min(dp[i][j-1],dp[i-1][j]) + grid[i][j];
        }
    }
    return dp[m-1][n-1];
}
```







### L343. 整数拆分

**题目：**给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

```C++
示例 1:
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```



**思路1**：一维动态规划。时间复杂度O(n^2)，空间复杂度O(n)

1 数组元素：dp[i]表示正整数i 拆分后的最大乘积。

2 递推公式： 假设正整数 num 分解为 两个正整数 x 和 y ，为了寻找最大乘积，需要遍历所有的x和y，并取最大乘积。对于每个x,y，其最大乘积为：`x*max(dp[y],y)`。拆分x的情况，在遍历x的过程中其实都计算过了。

3 初始化：由于0不是正整数，因此不用管。dp[1]=1, dp[2] = 1。为什么dp[1]=1? 这是因为1无法分解为两个正整数，因此其最大乘积和为其本身。

4 遍历：从i=0 到 i=n

5 举例。

代码：

```C++
int integerBreak(int n) {
    vector<int> dp(n+1);
    dp[1] = 1;
    dp[2] = 1;
    //dp[i] = 数值i拆分后的最大乘积
    for(int i=3;i<=n;++i){
        int m_max = 0;
        for(int j=1;j<=i/2;++j){
            int tmp=j*std::max(dp[i-j],i-j);
            m_max = std::max(m_max,tmp);
        }
        dp[i] = m_max;
    }
    return dp[n];
}
```



**思路2**：优化的动态规划。时间复杂度和空间复杂度均为O(n)。



**思路3**：数学方法。时间复杂度和空间复杂度均为O(1)。





### L96. 不同的二叉搜索树

**题目：** 给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。 

```
示例：
输入：n = 3
输出：5
```

![示例](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

**思路1**：动态规划。时间复杂度O(n^2)，空间复杂度O(n)

核心难点是如何推导递归公式，即如何将原问题分解为子问题，子问题如何推导出原问题。

可知，**i个节点组成的二叉树数量dp[i] 等于不同的 $k \in (1,...,n)$作为 头节点时二叉树的数量和。**当k作为头节点时，二叉树的数量为$dp[k-1] * dp[ i - k]$。

​	这是因为当k作为头节点时，左子树中存在的值为$[1,...,k-1]$，因此该左子树的数量为$dp[k-1]$。右子树中存在的值为$[k+1,...,i]$，右子树的数量等价于$dp[ i - k]$，这是因为题目只关心二叉树的数量，而不关心每个节点的值，因此右子树的二叉树数量为$dp[ i - k]$。

​	代码如下：

```C++
int numTrees(int n) {
    if(n==1) return 1;
    vector<int> dp(n+1,0);//dp[i]表示由i个节点组成的二叉搜索树的数量
    dp[0] = 1;
    dp[1] = 1;
    for(int i=2;i<=n;++i)
        for(int j=0;j<i;++j)
        	dp[i] += dp[j] * dp[i-j-1];
    return dp[n];
}
```



**思路2**：数学方法。卡塔兰数。





## 01背包题目

### L494. 目标和

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。



**思路1**：动态规划。转换为01背包问题。

在每个整数前添加"+"或"-"号，相当于存在 子集left的和 - 子集right的和 = target，且left + right = sum。即：
$$
left - (sum-left) = target \\
即：left = (target + sum) / 2
$$
​	target是固定的，sum是固定的，left可以求出来。

​	于是接下来的工作就是在nums中寻找和为left的子集。

1 dp[j] 表示填满$j$大小的背包，有dp[j]种方法。

2 递推公式。

​	填满容量为 j-num[i] 的背包，有dp[j-nums[i]]中的方法。那么只要存在nums[i]，则凑成dp[j]就有 dp[j-num[i]]种方法。

​	$dp[i] += dp[j-nums[i]]$ 。

​	求组合类问题的公式，都是类似这样的：$ dp[i] += dp[j-nums[i]] $。

3 初始化

在初始化的时候dp[0] ⼀定要初始化为1，因为dp[0]是在公式中⼀切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。dp[0] = 1，理论上也很好解释，装满容量为0的背包，有1种⽅法，就是装0件物品。

dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出，dp[j]要保证是0的初始值，才能正确
的由dp[j - nums[i]]推导出来。

4 遍历顺序。

5 举例。

代码：

```C++
int findTargetSumWays(vector<int>& nums, int target) {
    //这可以转换为0-1背包问题,问题转换为数组子集和为 (target+sum)/2 有多少种方法。
    //dp[j] 在选择元素时，数组子集的目标和为j的表达式的数目
    int sum=0;
    for(int i=0;i<nums.size();++i) sum+= nums[i];
    if(target > sum)
        return 0;
    if((target + sum)%2 == 1)
        return 0;
    if(target+sum<0)
        return 0;
    int bagSize = (target+sum)/2;
    vector<int> dp(bagSize+1);
    dp[0]=1;
    for(int i=0;i<nums.size();++i){
        for(int j=bagSize;j>=nums[i];--j){
            dp[j] += dp[j-nums[i]];//那么只要存在nums[i]，则凑成dp[j]就有 dp[j-num[i]]种方法。
        }
    }
    return dp[bagSize];
}
```





## 完全背包题目



### L518. 零钱兑换 II

**题目：**给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。



**思路1**：动态规划。

这是一个完全背包问题。

1 **dp[i]表示总和为 i 的coins的组合数**。

2 递推公式：

当填满容量为 j-num[i] 的背包，有dp[j-nums[i]]中的方法。那么只要存在nums[i]，则凑成dp[j]就有 dp[j-num[i]]种方法。

$dp[j] += dp[j - coins[i]];$

3 初始化：dp[0] = 1，装满容量为0的背包，有1种⽅法，就是装0件物品。

4 遍历：外层循转遍历物体，内层循环遍历背包容量（这里是总和）。

5.举例。



代码：

```C++
int change(int amount, vector<int>& coins) {
    vector<int> dp(amount+1);//dp[i]表示总和为i的coins的组合数
    dp[0] = 1;
    for(int i=0;i<coins.size();++i)
        for(int j=coins[i];j<=amount;++j)
            dp[j] += dp[j - coins[i]];
    return dp[amount];
}
```



### L377. 组合总和 Ⅳ

**[题目](https://leetcode-cn.com/problems/combination-sum-iv/)**：给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

示例 1：

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

示例 2：

```
输入：nums = [9], target = 3
输出：0
```



**思路1**：动态规划。

这道题和L518不一样，这道题中求的是排列总数，而上一题求的是组合总数。组合不强调顺序，(1,5)和(5,1)是同⼀个组合。排列强调顺序，(1,5)和(5,1)是两个不同的排列。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包。**
**如果求排列数就是外层for遍历背包，内层for循环遍历物品。**
如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举⼀个例⼦：计算dp[4]的时
候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后
⾯！
所以本题遍历顺序最终遍历顺序：target（背包）放在外循环，将nums（物品）放在内循环，内循环
从前到后遍历。

```C++
int combinationSum4(vector<int>& nums, int target) {
    vector<int> dp(target+1);//dp[i]表示容量为i的背包的排列个数
    dp[0] = 1;
    for(int i=1;i<=target;++i){//外层遍历背包
        for(int j=0;j<nums.size();++j){//内层遍历物品
            if(i>=nums[j] && dp[i] < INT_MAX - dp[i - nums[j]])//只有当背包容量大于物体时，且dp[i] += dp[i - nums[j]]小于INT_MAX时
                dp[i] += dp[i - nums[j]];
        }
    }
    return dp[target];
}
```

C++测试⽤例有超过两个树相加超过int的数据，所以需要在if⾥加上dp[i] < INT_MAX - dp[i - num]。







### L70. 爬楼梯（进阶）

**题目**：将原题改为：⼀步⼀个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的⽅法可以爬到楼顶呢？



**思路1**：动态规划。

1阶，2阶，.... m阶就是物品，楼顶就是背包。
每⼀阶可以重复使⽤，例如跳了1阶，还可以继续跳1阶。
问跳到楼顶有⼏种⽅法其实就是问装满背包有⼏种⽅法。

此时⼤家应该发现这就是⼀个完全背包问题了。

做法与L377一致。



### L322. 零钱兑换

**[题目](https://leetcode-cn.com/problems/coin-change/)**：给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

 ```
示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0
示例 4：

输入：coins = [1], amount = 1
输出：1
示例 5：

输入：coins = [1], amount = 2
输出：2
 ```


提示：

1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104



**思路1**：动态规划。

题⽬中说每种硬币的数量是⽆限的，可以看出是典型的完全背包问题。
动规五部曲分析如下：

1. 确定dp数组以及下标的含义
dp[j]：凑⾜总额为j所需钱币的最少个数为dp[j]
2. 确定递推公式
得到dp[j]（考虑coins[i]），只有⼀个来源，dp[j - coins[i]]（没有考虑coins[i]）。
凑⾜总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上⼀个钱币coins[i]即dp[j - coins[i]] +
1就是dp[j]（考虑coins[i]）
所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最⼩的。
递推公式：**dp[j] = min(dp[j - coins[i]] + 1, dp[j])**;
3. dp数组如何初始化
⾸先凑⾜总⾦额为0所需钱币的个数⼀定是0，那么dp[0] = 0;
其他下标对应的数值呢？
考虑到递推公式的特性，dp[j]必须初始化为⼀个最⼤的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])⽐
较的过程中被初始值覆盖。
所以下标⾮0的元素都是应该是最⼤值。
代码如下：
4. 确定遍历顺序
本题求钱币最⼩个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最⼩个数。。

所以本题并不强调集合是组合还是排列。
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。
所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内
层for循环遍历物品都是可以的！
那么我采⽤coins放在外循环，target在内循环的⽅式。
本题钱币数量可以⽆限使⽤，那么是完全背包。所以遍历的内循环是正序
综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。

5. 举例推导dp数组

代码：

```C++
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, INT_MAX);
    dp[0] = 0;
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        for (int j = coins[i]; j <= amount; j++) { // 遍历背包
            if (dp[j - coins[i]] != INT_MAX) // 如果dp[j - coins[i]]是初始值则跳过
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
        }
    }
    if (dp[amount] == INT_MAX) 
        return -1;
    else
	    return dp[amount];
}
```



### L279. 完全平方数

**[题目](https://leetcode-cn.com/problems/perfect-squares/)**：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

​	给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

​	完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

 ```
示例 1：

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：

输入：n = 13
输出：2
解释：13 = 4 + 9
 ```

提示：

1 <= n <= 104



**思路1**：动态规划。完全背包问题。

这道题的思路和上一题差不多。不同的是，需要自己找出“物品”，这里的数字可以选择的是，从1 -> sqrt(n)，每个数字的“价格”是 i*i。

```C++
int numSquares(int n) {
    vector<int> dp(n+1,INT_MAX);
    int max_sqrt = static_cast<int>(std::sqrt(n));
    dp[0]=0;
    for(int i=1;i<=max_sqrt;++i){
        for(int j=i*i;j<=n;++j){
            if(dp[j-i*i]!=INT_MAX)
                dp[j] = std::min(dp[j],dp[j-i*i]+1);
        }
    }
    return dp[n];
}
```



动规五部曲分析如下：
1. 确定dp数组（dp table）以及下标的含义
dp[i]：和为i的完全平⽅数的最少数量为dp[i]
2. 确定递推公式
dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。
此时我们要选择最⼩的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);
3. dp数组如何初始化
dp[0]表示 和为0的完全平⽅数的最⼩数量，那么dp[0]⼀定是0。
有同学问题，那0 * 0 也算是⼀种啊，为啥dp[0] 就是 0呢？
看题⽬描述，找到若⼲个完全平⽅数（⽐如 1, 4, 9, 16, ...），题⽬描述中可没说要从0开始，dp[0]=0完
全是为了递推公式。
⾮0下标的dp[j]应该是多少呢？
从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最⼩的，所以⾮0下标的dp[i]⼀
定要初始为最⼤值，这样dp[j]在递推的时候才不会被初始值覆盖。
4. 确定遍历顺序
我们知道这是完全背包，所以本题外层for遍历背包，⾥层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！

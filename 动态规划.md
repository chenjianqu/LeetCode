#  动态规划 

## 动态规划基础

1. 确定dp数组（dp table）以及下标的含义 

2. 确定递推公式 

3. dp数组如何初始化 

4. 确定遍历顺序 

5. 举例推导dp数组





## 题目

### L509. 斐波那契数

**题目**：斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。

**思路1**：递归。

```C++
int fib(int n) {
    if(n==0)
        return 0;
    else if(n==1)
        return 1;
    else
        return fib(n-1)+fib(n-2);
}
```

**思路2**：迭代。

```C++
int fib(int n) {
    int last_1=1;
    int last_2=0;
    if(n==1)return 1;
    int curr=0;
    for(int i=1;i<n;++i){
        curr=last_1+last_2;
        last_2=last_1;
        last_1=curr;
    }
    return curr;
}
```

**思路3**：一维动态规划。

1 dp数组中元素a[i]表示斐波那契数F(i)。

2 递推公式：a[i]=a[i-1]+a[i-2]

3 初始化：a[0]=0, a[1]=1

4 遍历顺序：i=0->i=n

```C++
int fib(int n) {
    if(n==0) return 0;
    else if(n==1) return 1;
    vector<int> dp(n+1);
    dp[0]=0;
    dp[1]=1;
    for(int i=2;i<=n;++i) dp[i]=dp[i-1]+dp[i-2];
    return dp[n];
}
```



### L70. 爬楼梯

**题目**：假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 *n* 是一个正整数。

**思路1**：一维动态规划。

1 dp元素：dp[i]表示爬升到第 i 个台阶的所有方法。

2 递归公式： dp[i] = dp[i-1]+dp[i-2]

3 初始化：dp[0]=0,dp[1]=1,dp[2]=2;

4 遍历顺序：i=0到i=n

```C++
int climbStairs(int n) {
    if(n==0)return 0;
    else if(n==1) return 1;
    else if(n==2) return 2;
    vector<int> dp(n+1);
    dp[0]=0;
    dp[1]=1;
    dp[2]=2;
    for(int i=3;i<=n;++i)
        dp[i]=dp[i-1]+dp[i-2];
    return dp[n];
}
```

**思路2**：一维动态规划，但是不构造dp数组。

**思路3**：矩阵快速幂。

**思路4**：通项公式。





### L746. 使用最小花费爬楼梯

**题目**：给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**思路1**：动态规划。

1 数组元素：dp[i]表示到达第 i 阶所需要的最小花费。

2 递归公式：dp[i]= min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])

3 初始化：dp[0] = 0, dp[1]=0.这是因为可以选择从第0阶或第1阶开始爬楼梯。

4 遍历：从i=0到i=n

5 举例

```C++
int minCostClimbingStairs(vector<int>& cost) {
    vector<int> dp(cost.size()+1);
    dp[0]=0;
    dp[1]=0;
    for(int i=2;i<=cost.size();++i)
        dp[i] = std::min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
    return dp[cost.size()];
}
```

优化：可以将时间复杂度优化为O(3)





### L62. 不同路径

**题目**：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**思路1**：动态规划。二维动态规划。

1 每个元素dp[i] [j]表示第(i,j)网格的路径的数量。

2 递归公式：dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]

3 初始化： dp[0] [0] = 1, dp[i] [0] = 1,  dp[0] [j] = 1。

4 遍历：从左到右，从上到下遍历。

5 举例。

代码：

```C++
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m,vector<int>(n));
    //初始化
    dp[0][0]=1;
    for(int i=1;i<m;++i)dp[i][0] = 1;
    for(int j=1;j<n;++j)dp[0][j] = 1;
    //遍历
    for(int i=1;i<m;++i)
        for(int j=1;j<n;++j)
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
    return dp[m-1][n-1];
}
```



**思路2**：组合数学。





### L63. 不同路径 II

**题目**：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

 网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。 

**思路1**：动态规划。二维动态规划。

这道题和上一题差不多，唯一的区别是，在计算dp[i] [j]的时候，需要判断其 上方网格 左方网格 和当前网格是否存在障碍物。

```C++
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    int m=obstacleGrid.size();
    int n=obstacleGrid[0].size();
    vector<vector<int>> dp(m,vector<int>(n));
    //初始化
    if(obstacleGrid[0][0]==1) dp[0][0]=0;
    else dp[0][0]=1;
    for(int i=1;i<m;++i){
        if(obstacleGrid[i][0]==1) dp[i][0]=0;
        else dp[i][0]=dp[i-1][0];
    }
    for(int i=1;i<n;++i){
        if(obstacleGrid[0][i]==1) dp[0][i]=0;
        else dp[0][i]=dp[0][i-1];
    }  
	//遍历
    for(int i=1;i<m;++i){
        for(int j=1;j<n;++j){
            if(obstacleGrid[i-1][j]==1 && obstacleGrid[i][j-1]==0 && obstacleGrid[i][j]==0)
                dp[i][j] = dp[i][j-1];
            else if(obstacleGrid[i-1][j]==0 && obstacleGrid[i][j-1]==1 && obstacleGrid[i][j]==0)
                dp[i][j] = dp[i-1][j];
            else if(obstacleGrid[i-1][j]==0 && obstacleGrid[i][j-1]==0 && obstacleGrid[i][j]==0)
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            else
                dp[i][j] = 0;
        }
    }
    return dp[m-1][n-1];
}
```





### L343. 整数拆分

**题目：**给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

```C++
示例 1:
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```



**思路1**：一维动态规划。时间复杂度O(n^2)，空间复杂度O(n)

1 数组元素：dp[i]表示正整数i 拆分后的最大乘积。

2 递推公式： 假设正整数 num 分解为 两个正整数 x 和 y ，为了寻找最大乘积，需要遍历所有的x和y，并取最大乘积。对于每个x,y，其最大乘积为：`x*max(dp[y],y)`。拆分x的情况，在遍历x的过程中其实都计算过了。

3 初始化：由于0不是正整数，因此不用管。dp[1]=1, dp[2] = 1。为什么dp[1]=1? 这是因为1无法分解为两个正整数，因此其最大乘积和为其本身。

4 遍历：从i=0 到 i=n

5 举例。

代码：

```C++
int integerBreak(int n) {
    vector<int> dp(n+1);
    dp[1] = 1;
    dp[2] = 1;
    //dp[i] = 数值i拆分后的最大乘积
    for(int i=3;i<=n;++i){
        int m_max = 0;
        for(int j=1;j<=i/2;++j){
            int tmp=j*std::max(dp[i-j],i-j);
            m_max = std::max(m_max,tmp);
        }
        dp[i] = m_max;
    }
    return dp[n];
}
```



**思路2**：优化的动态规划。时间复杂度和空间复杂度均为O(n)。



**思路3**：数学方法。时间复杂度和空间复杂度均为O(1)。
















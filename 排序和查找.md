# 排序

## 基础知识

### 时间复杂度O(n^2)



#### 冒泡排序

冒泡排序是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。

> 一般情况下，称某个排序算法稳定，指的是当待排序序列中有相同的元素时，它们的相对位置在排序前后不会发生改变。

假设待排序序列为 (5,1,4,2,8)，如果采用冒泡排序对其进行升序（由小到大）排序，则整个排序过程如下所示：![img](http://c.biancheng.net/uploads/allimg/191114/2-19111411414M58.gif)
图 1 第一轮排序（白色字体表示参与比较的一对相邻元素）

从图 1 可以看到，经过第一轮冒泡排序，从待排序序列中找出了最大数 8，并将其放到了待排序序列的尾部，并入已排序序列中。
![img](http://c.biancheng.net/uploads/allimg/191114/2-191114114213154.gif)
图 2 第二轮排序

可以看到，经过第二轮冒泡排序，从待排序序列中找出了最大数 5，并将其放到了待排序序列的尾部，并入已排序序列中。
![img](http://c.biancheng.net/uploads/allimg/191114/2-191114114231129.gif)
图 3 第三轮排序


经过本轮冒泡排序，从待排序序列中找出了最大数 4，并将其放到了待排序序列的尾部，并入已排序序列中。


![img](http://c.biancheng.net/uploads/allimg/191114/2-19111411424RU.gif)
图 4 第四轮排序


经过本轮冒泡排序，从待排序序列中找出了最大数 2，并将其放到了待排序序列的尾部，并入已排序序列中。![img](http://c.biancheng.net/uploads/allimg/191114/2-191114114311M1.gif)
图 5 冒泡排序好的序列

```C++
void BubbleSort(vector<int> &arr){
    int N=arr.size();
	for (int i = 0; i < N; i++){
		for (int j = 0; j < N-i; j++){
			if (a[j] > a[j + 1]) 
                std::swap(a[j],a[j+1]);
        }
	}
}
```





#### 选择排序

 选择排序(Selection sort)是一种简单直观的排序算法。其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

```C++
void select_sort(int a[], int n){
    for(int i=0; i<n; i++){
        int min=i;// 无序区中最小元素位置
        //找"a[i+1]..a[n]"之间最小元素，并赋给min
        for(j=i+1; j<n; j++)
            if(a[j] < a[min])
                min=j;
        if(min != i)
            swap(a[i], a[min]);
    }
}
```





#### 插入排序

插入排序(InsertionSort)，一般也被称为直接插入排序。

对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想**是将一个记录插入到已经排好序的有序表中**，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

插入排序的平均时间复杂度也是 **O(n^2)**，空间复杂度为常数阶 **O(1)**，具体时间复杂度和数组的有序性也是有关联的。

插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 **N-1** 次，时间复杂度为 **O(N)**。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 **O(n^2)**。



```C++
void StraightSort(vector<int> &arr)
{
	for (int i = 1;i < arr.size();i++){
		int tmp = arr[i];
		for (j = i - 1;j >= 0 && arr[j] > tmp;j--) //从0到i-1中寻找可插入的位置，同时移动元素
			arr[j + 1] = arr[j];
		arr[j + 1] = tmp;
	}
}
```





### 时间复杂度O(nlogn)

#### 快速排序

```C++
int Partition(vector<int> &arr,int low,int high){
    int key = arr[low];//以第一个位置作为枢轴
    while(low<high){
        while(low<high && arr[high]>=key)
            --high;
        arr[low] = arr[high];
        while(low<high && arr[low]<=key)
            ++low;
        arr[high] = arr[low];
    }
    arr[low] = key;
    return low; //返回划分后轴枢的位置
}


void QSort(vector<int> &arr,int low,int high){
    if(low<high){
        int part = Partition(arr,low,high);
        QSort(arr,low,part-1);
        QSort(arr,part+1,high);
    }
}

int main() {
    vector<int> arr={3,6,7,4,3,9,30,6,1};
    QSort(arr,0,arr.size()-1);

    for(int i=0;i<arr.size();++i){
        cout<<arr[i]<<endl;
    }
    return 0;
}
```





#### 堆排序

```C++
// 递归方式调整大根堆(len是arr的长度，index是第一个非叶子节点的下标)
void adjust(vector<int> &arr, int len, int index)
{
    int left = 2*index + 1; // index的左子节点
    int right = 2*index + 2;// index的右子节点
    //判断是否需要调整，即叶子节点是否大于根节点
    int maxIdx = index;
    if(left<len && arr[left] > arr[maxIdx])
        maxIdx = left;
    if(right<len && arr[right] > arr[maxIdx])
        maxIdx = right;
    //递归调整
    if(maxIdx != index){
        std::swap(arr[maxIdx], arr[index]);
        adjust(arr, len, maxIdx);
    }
}

// 堆排序
void heapSort(vector<int> &arr, int size)
{
    // 构建大根堆（从最后一个非叶子节点向上）
    for(int i=size/2 - 1; i >= 0; i--)
        adjust(arr, size, i);
    //将大跟堆顶节点从堆中移出，并调整大根堆
    for(int len = size - 1; len >= 1; len--){
        std::swap(arr[0], arr[len]); // 将当前最大的放置到数组末尾
        adjust(arr, len, 0);     //重新修正大顶堆
    }
}
int main() {
    vector<int> arr={8,1,14,3,21};
    heapSort(arr,arr.size());
    for(int i=0;i<arr.size();++i){
        cout<<arr[i]<<" ";
    }
    return 0;
}
```







#### 希尔排序





#### 归并排序





### 时间复杂度O(n)

#### 计数排序



#### 基数排序



#### 桶排序





## 题目

### L215. 数组中的第K个最大元素

**[题目](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)**: 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

 ```
示例 1:
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5

示例 2:
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
 ```


提示：

1 <= k <= nums.length <= 10^4
-10^4 <= nums[i] <= 10^4



**思路1**：对数组进行排序。

选择排序。

```C++
int findKthLargest(vector<int>& nums, int k) {
    int len=nums.size();
    for(int i=0;i<k;++i){
        int max=i;
        for(int j=i+1;j<len;++j)
            if(nums[j]>nums[max])max=j;
        if(max!=i)std::swap(nums[i],nums[max]);
    }
    return nums[k-1];
}
```

时间复杂度O(kn)

空间复杂度O(1)



**思路2**：排序整个数组。

```C++
//快速排序，从大到小
int Partition(vector<int> &arr,int low,int high){
    //枢轴
    int key = arr[low];//以第一个位置作为枢轴
    while(low<high){
        while(low<high && arr[high] <= key) 
            --high;
        arr[low] = arr[high];
        while(low<high && arr[low] >=key)
            ++low;
        arr[high] = arr[low];
    }
    arr[low] = key;
    return low; //返回划分后轴枢的位置
}

void QSort(vector<int> &arr,int low,int high){
    if(low<high){
        int part = Partition(arr,low,high);
        QSort(arr,low,part-1);
        QSort(arr,part+1,high);
    }
}

int findKthLargest(vector<int>& nums, int k) {
    if(k>nums.size()){
        return 0;
    }
    QSort(nums,0,nums.size()-1);
    return nums[k-1];
}
```

时间复杂度O(nlogn)



**思路2**：





### L283. 移动零

**[题目](https://leetcode-cn.com/problems/move-zeroes/)**：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

```
示例 1:
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

示例 2:
输入: nums = [0]
输出: [0]
```

提示:

1 <= nums.length <= 10^4
-2^31 <= nums[i] <= 2^31 - 1



**思路1**：快慢指针。

```C++
void moveZeroes(vector<int>& nums) {
    //快慢指针，把非零值交换到前面
    for(int slow=0,fast=1;fast<nums.size();){
        if(nums[slow]==0 && nums[fast]!=0){
            std::swap(nums[slow],nums[fast]);
            ++slow;
        }
        else if(nums[slow]!=0 && nums[fast]!=0){
            while(slow<fast && nums[slow]!=0)
                ++slow;
            if(slow<fast)
                std::swap(nums[slow],nums[fast]);
        }
        ++fast;
    }
}    
```



官方给的：

使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。

右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：

左指针左边均为非零数；

右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

```C++
void moveZeroes(vector<int>& nums) {
    int n = nums.size(), left = 0, right = 0;
    while (right < n) {
        if (nums[right]) {
            swap(nums[left], nums[right]);
            left++;
        }
        right++;
    }
}
```











### J45. 把数组排成最小的数

**[题目](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)**：输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

 ```
示例 1:
输入: [10,2]
输出: "102"

示例 2:
输入: [3,30,34,5,9]
输出: "3033459"
 ```


提示:

0 < nums.length <= 100



**思路1**：自定义排序。

此题求拼接起来的最小数字，本质上是一个排序问题。设数组nums 中任意两数字的字符串为 x 和 y ，则规定 排序判断规则 为：

* 若拼接字符串 `x + y > y + x` ，则 x “大于” y ；

* 反之，若 `x + y < y + x` ，则 x “小于” y ；

  x “小于” y 代表：排序完成后，数组中 x 应在 y 左边；“大于” 则反之。根据以上规则，套用任何排序方法对 nums 执行排序即可。

![](https://pic.leetcode-cn.com/95e81dbccc44f26292d88c509afd68204a86b37d342f83d109fa7aa0cd4a6049-Picture1.png)



**冒泡排序**：

```C++
string minNumber(vector<int>& nums) {
    int len=nums.size();
    vector<string> vec(len);
    for(int i=0;i<len;++i)
        vec[i]=std::to_string(nums[i]);
    //冒泡
    for(int i=0;i<len;++i){
        for(int j=0;j<len-i;++j){
            if(vec[j+1]+vec[j] < vec[j]+vec[j+1])
                std::swap(vec[j],vec[j+1]);
        }
    }
    string output;
    for(auto &x:vec) output+=x;
    return output;
}
```



**快速排序**：

```C++
class Solution {
private:
    int partition(vector<string> &vec,int left,int right){
        string key=vec[left];
        while(left < right){
            while(left<right && key+vec[right]<=vec[right]+key)
                --right;
            vec[left]=vec[right];
            while(left<right && vec[left]+key<=key+vec[left])
                ++left;
            vec[right]=vec[left];
        }
        vec[left]=key;
        return left;
    }

    void QSort(vector<string> &vec,int left,int right){
        if(left<right){
            int mid = partition(vec,left,right);
            QSort(vec,left,mid-1);
            QSort(vec,mid+1,right);
        }
    }
public:
    string minNumber(vector<int>& nums) {
        int len=nums.size();
        vector<string> vec(len);
        for(int i=0;i<len;++i)
            vec[i]=std::to_string(nums[i]);
        //快速排序
        QSort(vec,0,len-1);
        string output;
        for(auto &x:vec) output+=x;
        return output;
    }
};
```



**C++ STL排序**

```C++
string minNumber(vector<int>& nums) {
    vector<string> strs;
    string res;
    for(int i = 0; i < nums.size(); i++)
        strs.push_back(to_string(nums[i]));
    sort(strs.begin(), strs.end(), [](string& x, string& y){ return x + y < y + x; });
    for(int i = 0; i < strs.size(); i++)
        res.append(strs[i]);
    return res;
}
```



### L912. 排序数组

**[题目](https://leetcode-cn.com/problems/sort-an-array/)**：给你一个整数数组 nums，请你将该数组升序排列。

 ```
示例 1：
输入：nums = [5,2,3,1]
输出：[1,2,3,5]

示例 2：
输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
 ```


提示：

1 <= nums.length <= 5 * 10^4
-5 * 10^4 <= nums[i] <= 5 * 10^4



**思路1**：普通快速排序。（超时）

```C++
class Solution {
private:
    int partition(vector<int> &nums,int left,int right){
        int key=nums[left];
        while(left < right){
            while(left<right && nums[right]>=key)--right;
            nums[left]=nums[right];
            while(left<right && nums[left]<=key)++left;
            nums[right]=nums[left];
        }
        nums[left] = key;
        return left;
    }

    void QSort(vector<int> &nums,int left,int right){
        if(left<right){
            int mid = partition(nums,left,right);
            QSort(nums,left,mid-1);
            QSort(nums,mid+1,right);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        QSort(nums,0,nums.size()-1);
        return nums;
    }
};
```



**思路2**：随机快速排序。

与普通快排不同的地方在于，选主元的时候是随机选的。在[left,right]内选一个主元交换到left的位置。

```
int random_idx = rand()%(right-left+1) + left;
std::swap(nums[left],nums[random_idx]);
```

代码如下：
```C++
class Solution {
private:
    int partition(vector<int> &nums,int left,int right){
        //随机选一个主元放到nums[left]的位置
        int random_idx = rand()%(right-left+1) + left;
        std::swap(nums[left],nums[random_idx]);
        int key=nums[left];
        while(left < right){
            while(left<right && nums[right]>=key)--right;
            nums[left]=nums[right];
            while(left<right && nums[left]<=key)++left;
            nums[right]=nums[left];
        }
        nums[left] = key;
        return left;
    }

    void QSort(vector<int> &nums,int left,int right){
        if(left<right){
            int mid = partition(nums,left,right);
            QSort(nums,left,mid-1);
            QSort(nums,mid+1,right);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        QSort(nums,0,nums.size()-1);
        return nums;
    }
};
```



**思路3**：堆排序。





**思路4**：归并排序。





### L147. 对链表进行插入排序

**[题目](https://leetcode-cn.com/problems/insertion-sort-list/)**：插入排序 算法的步骤:

**插入排序**是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。

对链表进行插入排序。

```
示例 1：
输入: head = [4,2,1,3]
输出: [1,2,3,4]

示例 2：
输入: head = [-1,5,3,4,0]
输出: [-1,0,3,4,5]
```

提示：

列表中的节点数在 [1, 5000]范围内
-5000 <= Node.val <= 5000



**思路1**：插入排序。

```C++
ListNode* insertionSortList(ListNode* head) {
    auto curr = head->next;//待排序链表
    head->next = nullptr;//相当于新链表
    while(curr){
        auto tmp=curr;//从待排序链表中取出一个节点
        curr=curr->next;
        tmp->next=nullptr;
        if(tmp->val < head->val){//将tmp放到新链表的head前面
            tmp->next = head;
            head = tmp;
            continue;
        }
        else{
            //寻找合适的插入位置
            auto prev = head;
            while(prev->next && tmp->val > prev->next->val) prev = prev->next;
            //插入到新链表中
            if(prev->next){
                tmp->next = prev->next;
                prev->next = tmp;
            }
            else{
                prev->next=tmp;
            }
        }

    }
    return head;
}
```



官方解答：

插入排序的基本思想是，维护一个有序序列，初始时有序序列只有一个元素，每次将一个新的元素插入到有序序列中，将有序序列的长度增加 1，直到全部元素都加入到有序序列中。

如果是数组的插入排序，则数组的前面部分是有序序列，每次找到有序序列后面的第一个元素（待插入元素）的插入位置，将有序序列中的插入位置后面的元素都往后移动一位，然后将待插入元素置于插入位置。

对于链表而言，插入元素时只要更新相邻节点的指针即可，不需要像数组一样将插入位置后面的元素往后移动，因此插入操作的时间复杂度是 O(1)，但是找到插入位置需要遍历链表中的节点，时间复杂度是 O(n)，因此链表插入排序的总时间复杂度仍然是 O(n^2)，其中 n 是链表的长度。

对于单向链表而言，只有指向后一个节点的指针，因**此需要从链表的头节点开始往后遍历链表中的节点，寻找插入位置**。

对链表进行插入排序的具体过程如下。

1. 首先判断给定的链表是否为空，若为空，则不需要进行排序，直接返回。

2. 创建哑节点 `dummyHead`，令 `dummyHead.next = head`。引入哑节点是为了便于在 `head` 节点之前插入节点。

3. 维护 `lastSorted` 为链表的已排序部分的最后一个节点，初始时 `lastSorted = head`。

4. 维护 `curr` 为待插入的元素，初始时 `curr = head.next`。

5. 比较 `lastSorted` 和 `curr` 的节点值。

   * 若 `lastSorted.val <= curr.val`，说明 `curr` 应该位于 `lastSorted` 之后，将 `lastSorted` 后移一位，`curr` 变成新的 `lastSorted`。

   * 否则，从链表的头节点开始往后遍历链表中的节点，寻找插入 `curr` 的位置。令 `prev` 为插入 `curr` 的位置的前一个节点，进行如下操作，完成对 `curr` 的插入：

```
lastSorted.next = curr.next
curr.next = prev.next
prev.next = curr
```

6. 令 `curr = lastSorted.next`，此时 `curr` 为下一个待插入的元素。

7. 重复第 5 步和第 6 步，直到 `curr` 变成空，排序结束。

8. 返回 `dummyHead.next`，为排序后的链表的头节点。

```C++
ListNode* insertionSortList(ListNode* head) {
    if (head == nullptr) return head;
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;
    ListNode* lastSorted = head;
    ListNode* curr = head->next;
    while (curr != nullptr) {
        if (lastSorted->val <= curr->val) { //将curr插入到lastSorted之后
            lastSorted = lastSorted->next;
        } else {
            //查找插入到位置
            ListNode *prev = dummyHead;
            while (prev->next->val <= curr->val) prev = prev->next;
            //将curr插入到查找到的位置
            lastSorted->next = curr->next;
            curr->next = prev->next;
            prev->next = curr;
        }
        curr = lastSorted->next;
    }
    return dummyHead->next;
}
```








# 二分查找

## 基础知识



## 题目

### L35. 搜索插入位置

**题目**：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

**思路**：二分查找。

```C++
int searchInsert(vector<int>& nums, int target) {
    int low=0,high =nums.size()-1;
    if(target<=nums[low]) return 0;
    else if(target>nums[high]) return nums.size();
    
    while(low<high){
        int mid = (low+high)/2;
        if(nums[mid] == target) return mid;
        else if(target>nums[mid]) low = mid+1;
        else high = mid-1;
    }
    if(nums[low]>target) return low;
    else if(nums[low]<target) return low+1;
    return low;
}
```







### J11. 旋转数组的最小数字

**[题目](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)**: 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  

```
示例 1：
输入：[3,4,5,1,2]
输出：1

示例 2：
输入：[2,2,2,0,1]
输出：0
```



**思路1**：暴力法。

```C++
int minArray(vector<int>& numbers) {
    for(int i=0;i<numbers.size();++i)
        if(numbers[i]<numbers[0])
            return numbers[i];
    return numbers[0];
}
```



**题目变形**：将数组恢复为有序数组，并返回最小值。

​	首先找到数组的最小值，并将数组的最小值之前的元素保存到外部数组中，然后将数组的后半部分移动到前部，而将外部保存的元素放置到数组的后半部分。

```c++
int minArray(vector<int>& numbers) {
    vector<int> arr;
    int min_value=numbers[0];
    int min_index=0;
    for(int i=0;i<numbers.size();++i){
        arr.push_back(numbers[i]);
        if(numbers[i]<min_value){
            min_value=numbers[i];
            min_index=i;
            break;
        }
    }
    //将后半部分移动到前半部分
    int left_len = numbers.size()-min_index;
    for(int i=0;i<left_len;++i)
        numbers[i]=numbers[i+min_index];
    //将前半部分放回去
    for(int i=left_len;i<numbers.size();++i)
        numbers[i]=arr[i-left_len];
    return min_value;
}
```



**思路2**：二分查找。

我们考虑数组中的最后一个元素`x`：在最小值右侧的元素，它们的值一定都小于等于 `x`；而在最小值左侧的元素，它们的值一定都大于等于 `x`。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。

在二分查找的每一步中，左边界为`low`，右边界为 `high`，区间的中点为 `pivot`，最小值就在该区间内。我们将中轴元素 `numbers[pivot]` 与右边界元素 `numbers[high]` 进行比较，可能会有以下的三种情况：

**第一种情况**是 `numbers[pivot]<numbers[high]`。这说明 `numbers[pivot]`是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。

**第二种情况**是 `numbers[pivot]>numbers[high]`。这说明 `numbers[pivot]` 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。

**第三种情况**是 `numbers[pivot]==numbers[high]`。由于重复元素的存在，我们并不能确定 `numbers[pivot]` 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论`numbers[high]` 是不是最小值，都有一个它的「替代品」`numbers[pivot]`，因此我们可以忽略二分查找区间的右端点。

```C++
int minArray(vector<int>& numbers) {
    int low=0,high=numbers.size()-1;
    while(low<high){
        int mid=(high+low)/2;
        if(numbers[mid]<numbers[high])
            high=mid;
        else if(numbers[mid]>numbers[high])
            low=mid+1;
        else
            high--;
    }
    return numbers[low];
}
```






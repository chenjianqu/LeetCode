# 排序






# 二分查找

## 基础知识



## 题目

### L35. 搜索插入位置

**题目**：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

**思路**：二分查找。

```C++
int searchInsert(vector<int>& nums, int target) {
    int low=0,high =nums.size()-1;
    if(target<=nums[low]) return 0;
    else if(target>nums[high]) return nums.size();
    
    while(low<high){
        int mid = (low+high)/2;
        if(nums[mid] == target) return mid;
        else if(target>nums[mid]) low = mid+1;
        else high = mid-1;
    }
    if(nums[low]>target) return low;
    else if(nums[low]<target) return low+1;
    return low;
}
```







### J11. 旋转数组的最小数字

**[题目](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)**: 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  

```
示例 1：
输入：[3,4,5,1,2]
输出：1

示例 2：
输入：[2,2,2,0,1]
输出：0
```



**思路1**：暴力法。

```C++
int minArray(vector<int>& numbers) {
    for(int i=0;i<numbers.size();++i)
        if(numbers[i]<numbers[0])
            return numbers[i];
    return numbers[0];
}
```



**题目变形**：将数组恢复为有序数组，并返回最小值。

​	首先找到数组的最小值，并将数组的最小值之前的元素保存到外部数组中，然后将数组的后半部分移动到前部，而将外部保存的元素放置到数组的后半部分。

```c++
int minArray(vector<int>& numbers) {
    vector<int> arr;
    int min_value=numbers[0];
    int min_index=0;
    for(int i=0;i<numbers.size();++i){
        arr.push_back(numbers[i]);
        if(numbers[i]<min_value){
            min_value=numbers[i];
            min_index=i;
            break;
        }
    }
    //将后半部分移动到前半部分
    int left_len = numbers.size()-min_index;
    for(int i=0;i<left_len;++i)
        numbers[i]=numbers[i+min_index];
    //将前半部分放回去
    for(int i=left_len;i<numbers.size();++i)
        numbers[i]=arr[i-left_len];
    return min_value;
}
```



**思路2**：二分查找。

我们考虑数组中的最后一个元素`x`：在最小值右侧的元素，它们的值一定都小于等于 `x`；而在最小值左侧的元素，它们的值一定都大于等于 `x`。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。

在二分查找的每一步中，左边界为`low`，右边界为 `high`，区间的中点为 `pivot`，最小值就在该区间内。我们将中轴元素 `numbers[pivot]` 与右边界元素 `numbers[high]` 进行比较，可能会有以下的三种情况：

**第一种情况**是 `numbers[pivot]<numbers[high]`。这说明 `numbers[pivot]`是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。

**第二种情况**是 `numbers[pivot]>numbers[high]`。这说明 `numbers[pivot]` 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。

**第三种情况**是 `numbers[pivot]==numbers[high]`。由于重复元素的存在，我们并不能确定 `numbers[pivot]` 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论`numbers[high]` 是不是最小值，都有一个它的「替代品」`numbers[pivot]`，因此我们可以忽略二分查找区间的右端点。

```C++
int minArray(vector<int>& numbers) {
    int low=0,high=numbers.size()-1;
    while(low<high){
        int mid=(high+low)/2;
        if(numbers[mid]<numbers[high])
            high=mid;
        else if(numbers[mid]>numbers[high])
            low=mid+1;
        else
            high--;
    }
    return numbers[low];
}
```






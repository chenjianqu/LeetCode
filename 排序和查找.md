# 排序

## 基础知识

### 时间复杂度O(n^2)



#### 冒泡排序

冒泡排序是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。

> 一般情况下，称某个排序算法稳定，指的是当待排序序列中有相同的元素时，它们的相对位置在排序前后不会发生改变。

假设待排序序列为 (5,1,4,2,8)，如果采用冒泡排序对其进行升序（由小到大）排序，则整个排序过程如下所示：![img](http://c.biancheng.net/uploads/allimg/191114/2-19111411414M58.gif)
图 1 第一轮排序（白色字体表示参与比较的一对相邻元素）

从图 1 可以看到，经过第一轮冒泡排序，从待排序序列中找出了最大数 8，并将其放到了待排序序列的尾部，并入已排序序列中。
![img](http://c.biancheng.net/uploads/allimg/191114/2-191114114213154.gif)
图 2 第二轮排序

可以看到，经过第二轮冒泡排序，从待排序序列中找出了最大数 5，并将其放到了待排序序列的尾部，并入已排序序列中。
![img](http://c.biancheng.net/uploads/allimg/191114/2-191114114231129.gif)
图 3 第三轮排序


经过本轮冒泡排序，从待排序序列中找出了最大数 4，并将其放到了待排序序列的尾部，并入已排序序列中。


![img](http://c.biancheng.net/uploads/allimg/191114/2-19111411424RU.gif)
图 4 第四轮排序


经过本轮冒泡排序，从待排序序列中找出了最大数 2，并将其放到了待排序序列的尾部，并入已排序序列中。![img](http://c.biancheng.net/uploads/allimg/191114/2-191114114311M1.gif)
图 5 冒泡排序好的序列

```C++
void BubbleSort(vector<int> &arr){
    int N=arr.size();
	for (int i = 0; i < N; i++){
		for (int j = 0; j < N-i; j++){
			if (a[j] > a[j + 1]) 
                std::swap(a[j],a[j+1]);
        }
	}
}
```





#### 选择排序

 选择排序(Selection sort)是一种简单直观的排序算法。其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

```C++
void select_sort(int a[], int n){
    for(int i=0; i<n; i++){
        int min=i;// 无序区中最小元素位置
        //找"a[i+1]..a[n]"之间最小元素，并赋给min
        for(j=i+1; j<n; j++)
            if(a[j] < a[min])
                min=j;
        if(min != i)
            swap(a[i], a[min]);
    }
}
```





#### 插入排序

插入排序(InsertionSort)，一般也被称为直接插入排序。

对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想**是将一个记录插入到已经排好序的有序表中**，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

插入排序的平均时间复杂度也是 **O(n^2)**，空间复杂度为常数阶 **O(1)**，具体时间复杂度和数组的有序性也是有关联的。

插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 **N-1** 次，时间复杂度为 **O(N)**。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 **O(n^2)**。



```C++
void StraightSort(vector<int> &arr)
{
	for (int i = 1;i < arr.size();i++){
		int tmp = arr[i];
		for (j = i - 1;j >= 0 && arr[j] > tmp;j--) //从0到i-1中寻找可插入的位置，同时移动元素
			arr[j + 1] = arr[j];
		arr[j + 1] = tmp;
	}
}
```





### 时间复杂度O(nlogn)

#### 快速排序

```C++
int Partition(vector<int> &arr,int low,int high){
    int key = arr[low];//以第一个位置作为枢轴
    while(low<high){
        while(low<high && arr[high]>=key)
            --high;
        arr[low] = arr[high];
        while(low<high && arr[low]<=key)
            ++low;
        arr[high] = arr[low];
    }
    arr[low] = key;
    return low; //返回划分后轴枢的位置
}


void QSort(vector<int> &arr,int low,int high){
    if(low<high){
        int part = Partition(arr,low,high);
        QSort(arr,low,part-1);
        QSort(arr,part+1,high);
    }
}

int main() {
    vector<int> arr={3,6,7,4,3,9,30,6,1};
    QSort(arr,0,arr.size()-1);

    for(int i=0;i<arr.size();++i){
        cout<<arr[i]<<endl;
    }
    return 0;
}
```





#### 堆排序

```C++
// 递归方式调整大根堆(len是arr的长度，index是第一个非叶子节点的下标)
void adjust(vector<int> &arr, int len, int index)
{
    int left = 2*index + 1; // index的左子节点
    int right = 2*index + 2;// index的右子节点
    //判断是否需要调整，即叶子节点是否大于根节点
    int maxIdx = index;
    if(left<len && arr[left] > arr[maxIdx])
        maxIdx = left;
    if(right<len && arr[right] > arr[maxIdx])
        maxIdx = right;
    //递归调整
    if(maxIdx != index){
        std::swap(arr[maxIdx], arr[index]);
        adjust(arr, len, maxIdx);
    }
}

// 堆排序
void heapSort(vector<int> &arr, int size)
{
    // 构建大根堆（从最后一个非叶子节点向上）
    for(int i=size/2 - 1; i >= 0; i--)
        adjust(arr, size, i);
    //将大跟堆顶节点从堆中移出，并调整大根堆
    for(int len = size - 1; len >= 1; len--){
        std::swap(arr[0], arr[len]); // 将当前最大的放置到数组末尾
        adjust(arr, len, 0);     //重新修正大顶堆
    }
}
int main() {
    vector<int> arr={8,1,14,3,21};
    heapSort(arr,arr.size());
    for(int i=0;i<arr.size();++i){
        cout<<arr[i]<<" ";
    }
    return 0;
}
```







#### 希尔排序





#### 归并排序

代码：

```C++
void merge(vector<int>& nums,int left,int mid,int right){
    int i=left, j=mid+1, k=0;
    vector<int> tmp(right-left+1);
    while(i<=mid && j<=right){
        if(nums[i]<=nums[j]) tmp[k++]=nums[i++];
        else tmp[k++]=nums[j++];
    }
    while(i<=mid)tmp[k++]=nums[i++];
    while(j<=right)tmp[k++]=nums[j++];
    for(int i=0;i<tmp.size();++i)
        nums[i+left]=tmp[i];
}

void mergeSort(vector<int>& nums,int left,int right){
    if(left>=right) return ;
    int mid = (left+right)/2;
    mergeSort(nums,left,mid);
    mergeSort(nums,mid+1,right);
    merge(nums,left,mid,right);
}
```



在比较类排序中，归并排序号称最快，其次是快速排序和堆排序，两者不相伯仲，但是有一点需要注意，数据初始排序状态对堆排序不会产生太大的影响，而快速排序却恰恰相反。

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。

从下图可以看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。

![](https://pic3.zhimg.com/80/v2-6e055efd7e700c2992323689848d20fa_1440w.jpg)

![](https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.webp)

归并排序有两种实现方式： 基于**递归**的归并排序和基于**循环**的归并排序。（也叫自顶向下的归并排序和自底向上的归并排序）

这两种归并算法虽然实现方式不同，但还是有共同之处的：

\1. 无论是基于递归还是循环的归并排序， 它们调用的核心方法都是相同的：完成一趟合并的算法，即两个已经有序的数组序列合并成一个更大的有序数组序列 （前提是两个原序列都是有序的！）

\2. 从排序轨迹上看，合并序列的长度都是从小（一个元素）到大（整个数组）增长的



**基于递归的归并排序：**

![](https://pic3.zhimg.com/80/v2-b5d8f8e52ea646016cfd1408a378d80e_1440w.jpg)

代码：

```C++
//low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素
void Merge(vector<int>& arr,int low,int mid,int high){
    int i=low,j=mid+1,k=0;  //mid+1为第2有序区第1个元素
    vector<int> tmp(high-low+1);//temp数组暂存合并的有序序列
    while(i<=mid&&j<=high){
        if(arr[i]<=arr[j]) 
            tmp[k++]=arr[i++];
        else
            tmp[k++]=arr[j++];
    }
    while(i<=mid)//若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中
        tmp[k++]=arr[i++];
    while(j<=high)
        tmp[k++]=arr[j++];
    for(i=low,k=0;i<=high;i++,k++)
        arr[i]=tmp[k];//将排好序的存回arr中low到high这区间
}

void MergeSort (vector<int>& arr, int low,int high) {
    if(low>=high)return; // 终止递归的条件，子序列长度为1
    int mid =  (high + low)/2;  // 取得序列中间的元素
    MergeSort(arr,low,mid);  // 对左半边递归
    MergeSort(arr,mid+1,high);  // 对右半边递归
    if(a[mid]<=a[mid+1]) return; // 避免不必要的归并
    merge(arr,low,mid,high);  // 合并
}
```



归并排序的优化：

优化一：对小规模子数组使用**插入排序**

用不同的方法处理小规模问题能改进大多数递归算法的性能，因为递归会使小规模问题中方法调用太过频繁，所以改进对它们的处理方法就能改进整个算法。因为插入排序非常简单， 因此一般来说在小数组上比归并排序更快。 这种优化能使归并排序的运行时间缩短10%到15%。

怎么切换呢?只要把作为停止递归条件的

```text
if(low>=high) { return; }
```

改成

```C++
if(high - low <= 10) { // 数组长度小于10的时候
    InsertSort(int arr[], int low,int high); // 切换到插入排序
    return;
}
```

优化二: 测试待排序序列中左右半边是否已**有序**

通过测试待排序序列中左右半边是否已经有序， 在有序的情况下避免合并方法的调用。

因为`a[low...mid]`和`a[mid...high]`本来就是有序的，存在`a[low]<a[low+1]...<a[mid]`和`a[mid+1]<a[mid+2]...< a[high]`这两种关系， 如果判断出`a[mid]<=a[mid+1]`的话，我们就认为数组已经是有序的并跳过merge() 方法。

```C++
void sort (int a[], int low,int high) {
    if(low>=high) // 终止递归的条件
        return;
    int mid =  low + (high - low)/2;  // 取得序列中间的元素
    sort(a,low,mid);  // 对左半边递归
    sort(a,mid+1,high);  // 对右半边递归
    if(a[mid]<=a[mid+1]) return; // 避免不必要的归并
    merge(a,low,mid,high);  // 单趟合并
}
```

**优化三：去除原数组序列到辅助数组的拷贝**

在上面介绍的基于递归的归并排序的代码中， 我们在每次调用merge方法时候，我们都把arr对应的序列拷贝到辅助数组temp中去。

在递归调用的每个层次交换输入数组和输出数组的角色，从而不断地把输入数组排序到辅助数组，再将数据从辅助数组排序到输入数组，节省数组复制的时间。

注意， 外部的sort方法和内部sort方法接收的a和aux参数刚好是相反的

在上面介绍的基于递归的归并排序的代码中， 我们在每次调用merge方法时候，我们都把arr对应的序列拷贝到辅助数组temp中去。

在递归调用的每个层次交换输入数组和输出数组的角色，从而不断地把输入数组排序到辅助数组，再将数据从辅助数组排序到输入数组，节省数组复制的时间。

**注意， 外部的sort方法和内部sort方法接收的a和aux参数刚好是相反的**

![img](https://pic1.zhimg.com/80/v2-25ab66ed6762cb504a78595e060ea678_1440w.jpg)

在这里我们做了两个操作：

- **在排序前拷贝一个和原数组元素完全一样的辅助数组（不再是创建一个空数组了！）**
- **在递归调用的每个层次交换输入数组和输出数组的角色**

因为外部sort和merge的参数顺序是相同的，所以，无论递归过程中辅助数组和原数组的角色如何替换，对最后一次调用的merge而言（将整个数组左右半边合为有序的操作）， 最终被排为有序的都是原数组，而不是辅助数组！

![img](https://pic3.zhimg.com/80/v2-62bc4a20b1b82a00139b1257497d900e_1440w.jpg)



**基于循环的归并排序（自底向上）**

![img](https://pic4.zhimg.com/80/v2-7c7a32c1849652a85030cfb6603d7b63_1440w.jpg)

代码：

```C++
void sort(int a []){
    int N = a.size();
    for (int size = 1; size < N; size *= 2){
        //  low+size=mid+1,为第二个分区第一个元素，它 < N，确保最后一次合并有2个区间
        for(int low = 0; low + size < N;low += 2 * size) {
            mid = low + size - 1;
            high = low + 2 * size - 1;
            if(high > N-1) high = N - 1;
            merge(a,low, mid, high);
        }
    }
}
```





### 时间复杂度O(n)

#### 计数排序



#### 基数排序



#### 桶排序





## 题目

### L215. 数组中的第K个最大元素

**[题目](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)**: 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

 ```
示例 1:
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5

示例 2:
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
 ```


提示：

1 <= k <= nums.length <= 10^4
-10^4 <= nums[i] <= 10^4



**思路1**：对数组进行排序。

选择排序。

```C++
int findKthLargest(vector<int>& nums, int k) {
    int len=nums.size();
    for(int i=0;i<k;++i){
        int max=i;
        for(int j=i+1;j<len;++j)
            if(nums[j]>nums[max])max=j;
        if(max!=i)std::swap(nums[i],nums[max]);
    }
    return nums[k-1];
}
```

时间复杂度O(kn)

空间复杂度O(1)



**思路2**：排序整个数组。

```C++
//快速排序，从大到小
int Partition(vector<int> &arr,int low,int high){
    //枢轴
    int key = arr[low];//以第一个位置作为枢轴
    while(low<high){
        while(low<high && arr[high] <= key) 
            --high;
        arr[low] = arr[high];
        while(low<high && arr[low] >=key)
            ++low;
        arr[high] = arr[low];
    }
    arr[low] = key;
    return low; //返回划分后轴枢的位置
}

void QSort(vector<int> &arr,int low,int high){
    if(low<high){
        int part = Partition(arr,low,high);
        QSort(arr,low,part-1);
        QSort(arr,part+1,high);
    }
}

int findKthLargest(vector<int>& nums, int k) {
    if(k>nums.size()){
        return 0;
    }
    QSort(nums,0,nums.size()-1);
    return nums[k-1];
}
```

时间复杂度O(nlogn)



**思路2**：





### L283. 移动零

**[题目](https://leetcode-cn.com/problems/move-zeroes/)**：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

```
示例 1:
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

示例 2:
输入: nums = [0]
输出: [0]
```

提示:

1 <= nums.length <= 10^4
-2^31 <= nums[i] <= 2^31 - 1



**思路1**：快慢指针。

```C++
void moveZeroes(vector<int>& nums) {
    //快慢指针，把非零值交换到前面
    for(int slow=0,fast=1;fast<nums.size();){
        if(nums[slow]==0 && nums[fast]!=0){
            std::swap(nums[slow],nums[fast]);
            ++slow;
        }
        else if(nums[slow]!=0 && nums[fast]!=0){
            while(slow<fast && nums[slow]!=0)
                ++slow;
            if(slow<fast)
                std::swap(nums[slow],nums[fast]);
        }
        ++fast;
    }
}    
```



官方给的：

使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。

右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：

左指针左边均为非零数；

右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

```C++
void moveZeroes(vector<int>& nums) {
    int n = nums.size(), left = 0, right = 0;
    while (right < n) {
        if (nums[right]) {
            swap(nums[left], nums[right]);
            left++;
        }
        right++;
    }
}
```











### J45. 把数组排成最小的数

**[题目](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)**：输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

 ```
示例 1:
输入: [10,2]
输出: "102"

示例 2:
输入: [3,30,34,5,9]
输出: "3033459"
 ```


提示:

0 < nums.length <= 100



**思路1**：自定义排序。

此题求拼接起来的最小数字，本质上是一个排序问题。设数组nums 中任意两数字的字符串为 x 和 y ，则规定 排序判断规则 为：

* 若拼接字符串 `x + y > y + x` ，则 x “大于” y ；

* 反之，若 `x + y < y + x` ，则 x “小于” y ；

  x “小于” y 代表：排序完成后，数组中 x 应在 y 左边；“大于” 则反之。根据以上规则，套用任何排序方法对 nums 执行排序即可。

![](https://pic.leetcode-cn.com/95e81dbccc44f26292d88c509afd68204a86b37d342f83d109fa7aa0cd4a6049-Picture1.png)



**冒泡排序**：

```C++
string minNumber(vector<int>& nums) {
    int len=nums.size();
    vector<string> vec(len);
    for(int i=0;i<len;++i)
        vec[i]=std::to_string(nums[i]);
    //冒泡
    for(int i=0;i<len;++i){
        for(int j=0;j<len-i;++j){
            if(vec[j+1]+vec[j] < vec[j]+vec[j+1])
                std::swap(vec[j],vec[j+1]);
        }
    }
    string output;
    for(auto &x:vec) output+=x;
    return output;
}
```



**快速排序**：

```C++
class Solution {
private:
    int partition(vector<string> &vec,int left,int right){
        string key=vec[left];
        while(left < right){
            while(left<right && key+vec[right]<=vec[right]+key)
                --right;
            vec[left]=vec[right];
            while(left<right && vec[left]+key<=key+vec[left])
                ++left;
            vec[right]=vec[left];
        }
        vec[left]=key;
        return left;
    }

    void QSort(vector<string> &vec,int left,int right){
        if(left<right){
            int mid = partition(vec,left,right);
            QSort(vec,left,mid-1);
            QSort(vec,mid+1,right);
        }
    }
public:
    string minNumber(vector<int>& nums) {
        int len=nums.size();
        vector<string> vec(len);
        for(int i=0;i<len;++i)
            vec[i]=std::to_string(nums[i]);
        //快速排序
        QSort(vec,0,len-1);
        string output;
        for(auto &x:vec) output+=x;
        return output;
    }
};
```



**C++ STL排序**

```C++
string minNumber(vector<int>& nums) {
    vector<string> strs;
    string res;
    for(int i = 0; i < nums.size(); i++)
        strs.push_back(to_string(nums[i]));
    sort(strs.begin(), strs.end(), [](string& x, string& y){ return x + y < y + x; });
    for(int i = 0; i < strs.size(); i++)
        res.append(strs[i]);
    return res;
}
```



### L912. 排序数组

**[题目](https://leetcode-cn.com/problems/sort-an-array/)**：给你一个整数数组 nums，请你将该数组升序排列。

 ```
示例 1：
输入：nums = [5,2,3,1]
输出：[1,2,3,5]

示例 2：
输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
 ```


提示：

1 <= nums.length <= 5 * 10^4
-5 * 10^4 <= nums[i] <= 5 * 10^4



**思路1**：普通快速排序。（超时）

```C++
class Solution {
private:
    int partition(vector<int> &nums,int left,int right){
        int key=nums[left];
        while(left < right){
            while(left<right && nums[right]>=key)--right;
            nums[left]=nums[right];
            while(left<right && nums[left]<=key)++left;
            nums[right]=nums[left];
        }
        nums[left] = key;
        return left;
    }

    void QSort(vector<int> &nums,int left,int right){
        if(left<right){
            int mid = partition(nums,left,right);
            QSort(nums,left,mid-1);
            QSort(nums,mid+1,right);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        QSort(nums,0,nums.size()-1);
        return nums;
    }
};
```



**思路2**：随机快速排序。

与普通快排不同的地方在于，选主元的时候是随机选的。在[left,right]内选一个主元交换到left的位置。

```
int random_idx = rand()%(right-left+1) + left;
std::swap(nums[left],nums[random_idx]);
```

代码如下：
```C++
class Solution {
private:
    int partition(vector<int> &nums,int left,int right){
        //随机选一个主元放到nums[left]的位置
        int random_idx = rand()%(right-left+1) + left;
        std::swap(nums[left],nums[random_idx]);
        int key=nums[left];
        while(left < right){
            while(left<right && nums[right]>=key)--right;
            nums[left]=nums[right];
            while(left<right && nums[left]<=key)++left;
            nums[right]=nums[left];
        }
        nums[left] = key;
        return left;
    }

    void QSort(vector<int> &nums,int left,int right){
        if(left<right){
            int mid = partition(nums,left,right);
            QSort(nums,left,mid-1);
            QSort(nums,mid+1,right);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        QSort(nums,0,nums.size()-1);
        return nums;
    }
};
```



**思路3**：堆排序。





**思路4**：归并排序。





### L147. 对链表进行插入排序

**[题目](https://leetcode-cn.com/problems/insertion-sort-list/)**：插入排序 算法的步骤:

**插入排序**是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。

对链表进行插入排序。

```
示例 1：
输入: head = [4,2,1,3]
输出: [1,2,3,4]

示例 2：
输入: head = [-1,5,3,4,0]
输出: [-1,0,3,4,5]
```

提示：

列表中的节点数在 [1, 5000]范围内
-5000 <= Node.val <= 5000



**思路1**：插入排序。

```C++
ListNode* insertionSortList(ListNode* head) {
    auto curr = head->next;//待排序链表
    head->next = nullptr;//相当于新链表
    while(curr){
        auto tmp=curr;//从待排序链表中取出一个节点
        curr=curr->next;
        tmp->next=nullptr;
        if(tmp->val < head->val){//将tmp放到新链表的head前面
            tmp->next = head;
            head = tmp;
            continue;
        }
        else{
            //寻找合适的插入位置
            auto prev = head;
            while(prev->next && tmp->val > prev->next->val) prev = prev->next;
            //插入到新链表中
            if(prev->next){
                tmp->next = prev->next;
                prev->next = tmp;
            }
            else{
                prev->next=tmp;
            }
        }

    }
    return head;
}
```



官方解答：

插入排序的基本思想是，维护一个有序序列，初始时有序序列只有一个元素，每次将一个新的元素插入到有序序列中，将有序序列的长度增加 1，直到全部元素都加入到有序序列中。

如果是数组的插入排序，则数组的前面部分是有序序列，每次找到有序序列后面的第一个元素（待插入元素）的插入位置，将有序序列中的插入位置后面的元素都往后移动一位，然后将待插入元素置于插入位置。

对于链表而言，插入元素时只要更新相邻节点的指针即可，不需要像数组一样将插入位置后面的元素往后移动，因此插入操作的时间复杂度是 O(1)，但是找到插入位置需要遍历链表中的节点，时间复杂度是 O(n)，因此链表插入排序的总时间复杂度仍然是 O(n^2)，其中 n 是链表的长度。

对于单向链表而言，只有指向后一个节点的指针，因**此需要从链表的头节点开始往后遍历链表中的节点，寻找插入位置**。

对链表进行插入排序的具体过程如下。

1. 首先判断给定的链表是否为空，若为空，则不需要进行排序，直接返回。

2. 创建哑节点 `dummyHead`，令 `dummyHead.next = head`。引入哑节点是为了便于在 `head` 节点之前插入节点。

3. 维护 `lastSorted` 为链表的已排序部分的最后一个节点，初始时 `lastSorted = head`。

4. 维护 `curr` 为待插入的元素，初始时 `curr = head.next`。

5. 比较 `lastSorted` 和 `curr` 的节点值。

   * 若 `lastSorted.val <= curr.val`，说明 `curr` 应该位于 `lastSorted` 之后，将 `lastSorted` 后移一位，`curr` 变成新的 `lastSorted`。

   * 否则，从链表的头节点开始往后遍历链表中的节点，寻找插入 `curr` 的位置。令 `prev` 为插入 `curr` 的位置的前一个节点，进行如下操作，完成对 `curr` 的插入：

```
lastSorted.next = curr.next
curr.next = prev.next
prev.next = curr
```

6. 令 `curr = lastSorted.next`，此时 `curr` 为下一个待插入的元素。

7. 重复第 5 步和第 6 步，直到 `curr` 变成空，排序结束。

8. 返回 `dummyHead.next`，为排序后的链表的头节点。

```C++
ListNode* insertionSortList(ListNode* head) {
    if (head == nullptr) return head;
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;
    ListNode* lastSorted = head;
    ListNode* curr = head->next;
    while (curr != nullptr) {
        if (lastSorted->val <= curr->val) { //将curr插入到lastSorted之后
            lastSorted = lastSorted->next;
        } else {
            //查找插入到位置
            ListNode *prev = dummyHead;
            while (prev->next->val <= curr->val) prev = prev->next;
            //将curr插入到查找到的位置
            lastSorted->next = curr->next;
            curr->next = prev->next;
            prev->next = curr;
        }
        curr = lastSorted->next;
    }
    return dummyHead->next;
}
```



### J51. 数组中的逆序对

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)**：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

 ```
示例 1:
输入: [7,5,6,4]
输出: 5
 ```


限制：

0 <= 数组长度 <= 50000



**思路1**：暴力方法。

```C++
int reversePairs(vector<int>& nums) {
    int count=0;
    for(int i=0;i<nums.size();++i){
        for(int j=i+1;j<nums.size();++j){
            if(nums[i]>nums[j])
                count++;
        }
    }
    return count;
}
```



**思路2**：归并排序。

那么求逆序对和归并排序又有什么关系呢？关键就在于「归并」当中「并」的过程。我们通过一个实例来看看。假设我们有两个已排序的序列等待合并，分别是 `L={8,12,16,22,100} `和 `R={9,26,55,64,91}`。一开始我们用指针 `lPtr = 0` 指向 L 的首部，`rPtr = 0` 指向 R 的头部。记已经合并好的部分为 M。

```
L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = []
     |                          |
   lPtr                       rPtr
```

我们发现 lPtr 指向的元素小于 rPtr 指向的元素，于是把 lPtr 指向的元素放入答案，并把 lPtr 后移一位。

```
L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = [8]
        |                       |
      lPtr                     rPtr
```


这个时候我们把左边的 8 加入了答案，我们发现右边没有数比 8 小，所以 8 对逆序对总数的「贡献」为 0。

接着我们继续合并，把 9 加入了答案，此时 lPtr 指向 12，rPtr 指向 26。

```
L = [8, 12, 16, 22, 100]   R = [9, 26, 55, 64, 91]  M = [8, 9]
        |                          |
       lPtr                       rPtr
```


此时 `lPtr` 比 `rPtr` 小，把 `lPtr` 对应的数加入答案，并考虑它对逆序对总数的贡献为 `rPtr` 相对 R 首位置的偏移 1（即右边只有一个数比 12小，所以只有它和 12 构成逆序对），以此类推。

我们发现用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，**只在 lPtr 右移的时候计算**，是基于这样的事实：当前 `lPtr` 指向的数字比 `rPtr` 小，但是比 R 中 `[0 ... rPtr - 1]` 的其他数字大，`[0 ... rPtr - 1]` 的其他数字本应当排在 lPtr 对应数字的左边，但是它排在了右边，所以这里就贡献了 `rPtr` 个逆序对。

```C++
class Solution {
private:
    int count=0;
    void merge(vector<int>& nums,int left,int mid,int right){
        int i=left, j=mid+1, k=0;
        vector<int> tmp(right-left+1);
        while(i<=mid && j<=right){
            if(nums[i]<=nums[j]){//左数组的元素num[i] 比右数组的元素num[j] 更小
                count+=(j-(mid+1));
                tmp[k++]=nums[i++];
            }
            else{ 
                tmp[k++]=nums[j++];
            }
        }
        while(i<=mid){
            tmp[k++]=nums[i++];
            count+=(j-(mid+1));
        }
        while(j<=right){
            tmp[k++]=nums[j++];
        }
        for(int i=0;i<tmp.size();++i)
            nums[i+left]=tmp[i];
    }

    void mergeSort(vector<int>& nums,int left,int right){
        if(left>=right) return ;
        int mid = (left+right)/2;
        mergeSort(nums,left,mid);
        mergeSort(nums,mid+1,right);
        merge(nums,left,mid,right);
    }
public:
    int reversePairs(vector<int>& nums) {
        if(nums.size()<1) return 0;
        mergeSort(nums,0,nums.size()-1);
        return count;
    }
};
```



**思路2**：离散化树状数组。

树状数组」是一种可以动态维护序列前缀和的数据结构，它的功能是：

单点更新 update(i, v)： 把序列 i 位置的数加上一个值 v，这题 v=1
区间查询 query(i)： 查询序列 `[1⋯i]` 区间的区间和，即 i 位置的前缀和
修改和查询的时间代价都是 O(logn)，其中 n 为需要维护前缀和的序列的长度。

思路

记题目给定的序列为 a，我们规定 $a_i$ 的取值集合为 a 的「值域」。我们用桶来表示值域中的每一个数，桶中记录这些数字出现的次数。假设a={5,5,2,3,6}，那么遍历这个序列得到的桶是这样的：

```
index  ->  1 2 3 4 5 6 7 8 9
value  ->  0 1 1 0 2 1 0 0 0
```


​	我们可以看出它第 i−1 位的前缀和表示「有多少个数比 i 小」。那么我们可以从后往前遍历序列 a，记当前遍历到的元素为 $a_i$ ，我们把 $a_i$  对应的桶的值自增 1，把 i−1 位置的前缀和加入到答案中算贡献。为什么这么做是对的呢，因为我们在循环的过程中，我们把原序列分成了两部分，后半部部分已经遍历过（已入桶），前半部分是待遍历的（未入桶），那么我们求到的 i−1 位置的前缀和就是「已入桶」的元素中比 $a_i$  大的元素的总和，而这些元素在原序列中排在 $a_i$  的后面，但它们本应该排在 $a_i$  的前面，这样就形成了逆序对。

我们显然可以用数组来实现这个桶，可问题是如果 $a_i$  中有很大的元素，比如 10^9，我们就要开一个大小为 10^9   的桶，内存中是存不下的。这个桶数组中很多位置是 0，有效位置是稀疏的，我们要想一个办法让有效的位置全聚集到一起，减少无效位置的出现，这个时候我们就需要用到一个方法——离散化。

离散化一个序列的前提是我们只关心这个序列里面元素的相对大小，而不关心绝对大小（即只关心元素在序列中的排名）；离散化的目的是让原来分布零散的值聚集到一起，减少空间浪费。那么如何获得元素排名呢，我们可以对原序列排序后去重，对于每一个 $a_i$  通过二分查找的方式计算排名作为离散化之后的值。当然这里也可以不去重，不影响排名。

```C++
class BIT {
private:
    vector<int> tree;
    int n;
public:
    BIT(int _n): n(_n), tree(_n + 1) {}
    
    int lowbit(int x) {
        return x & (-x);
    }
    
    int query(int x) {
        int ret = 0;
        while (x) {
            ret += tree[x];
            x -= lowbit(x);
        }
        return ret;
    }

    void update(int x) {
        while (x <= n) {
            ++tree[x];
            x += lowbit(x);
        }
    }
};

class Solution {
public:
    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp = nums;
        // 离散化
        sort(tmp.begin(), tmp.end());
        for (int& num: nums) {
            num = lower_bound(tmp.begin(), tmp.end(), num) - tmp.begin() + 1;
        }
        // 树状数组统计逆序对
        BIT bit(n);
        int ans = 0;
        for (int i = n - 1; i >= 0; --i) {
            ans += bit.query(nums[i] - 1);
            bit.update(nums[i]);
        }
        return ans;
    }
};
```










# 二分查找

## 基础知识



## 题目

### L35. 搜索插入位置

**题目**：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

**思路**：二分查找。

```C++
int searchInsert(vector<int>& nums, int target) {
    int low=0,high =nums.size()-1;
    if(target<=nums[low]) return 0;
    else if(target>nums[high]) return nums.size();
    
    while(low<high){
        int mid = (low+high)/2;
        if(nums[mid] == target) return mid;
        else if(target>nums[mid]) low = mid+1;
        else high = mid-1;
    }
    if(nums[low]>target) return low;
    else if(nums[low]<target) return low+1;
    return low;
}
```







### J11. 旋转数组的最小数字

**[题目](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)**: 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  

```
示例 1：
输入：[3,4,5,1,2]
输出：1

示例 2：
输入：[2,2,2,0,1]
输出：0
```



**思路1**：暴力法。

```C++
int minArray(vector<int>& numbers) {
    for(int i=0;i<numbers.size();++i)
        if(numbers[i]<numbers[0])
            return numbers[i];
    return numbers[0];
}
```



**题目变形**：将数组恢复为有序数组，并返回最小值。

​	首先找到数组的最小值，并将数组的最小值之前的元素保存到外部数组中，然后将数组的后半部分移动到前部，而将外部保存的元素放置到数组的后半部分。

```c++
int minArray(vector<int>& numbers) {
    vector<int> arr;
    int min_value=numbers[0];
    int min_index=0;
    for(int i=0;i<numbers.size();++i){
        arr.push_back(numbers[i]);
        if(numbers[i]<min_value){
            min_value=numbers[i];
            min_index=i;
            break;
        }
    }
    //将后半部分移动到前半部分
    int left_len = numbers.size()-min_index;
    for(int i=0;i<left_len;++i)
        numbers[i]=numbers[i+min_index];
    //将前半部分放回去
    for(int i=left_len;i<numbers.size();++i)
        numbers[i]=arr[i-left_len];
    return min_value;
}
```



**思路2**：二分查找。

我们考虑数组中的最后一个元素`x`：在最小值右侧的元素，它们的值一定都小于等于 `x`；而在最小值左侧的元素，它们的值一定都大于等于 `x`。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。

在二分查找的每一步中，左边界为`low`，右边界为 `high`，区间的中点为 `pivot`，最小值就在该区间内。我们将中轴元素 `numbers[pivot]` 与右边界元素 `numbers[high]` 进行比较，可能会有以下的三种情况：

**第一种情况**是 `numbers[pivot]<numbers[high]`。这说明 `numbers[pivot]`是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。

**第二种情况**是 `numbers[pivot]>numbers[high]`。这说明 `numbers[pivot]` 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。

**第三种情况**是 `numbers[pivot]==numbers[high]`。由于重复元素的存在，我们并不能确定 `numbers[pivot]` 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论`numbers[high]` 是不是最小值，都有一个它的「替代品」`numbers[pivot]`，因此我们可以忽略二分查找区间的右端点。

```C++
int minArray(vector<int>& numbers) {
    int low=0,high=numbers.size()-1;
    while(low<high){
        int mid=(high+low)/2;
        if(numbers[mid]<numbers[high])
            high=mid;
        else if(numbers[mid]>numbers[high])
            low=mid+1;
        else
            high--;
    }
    return numbers[low];
}
```



### L34. 在排序数组中查找元素的第一个和最后一个位置

[题目](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

```
示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

示例 2：
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

示例 3：
输入：nums = [], target = 0
输出：[-1,-1]
```


提示：

0 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
nums 是一个非递减数组
-10^9 <= target <= 10^9



### J53. 在排序数组中查找数字 I

**[题目](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)**：统计一个数字在排序数组中出现的次数。

 ```
示例 1:
输入: nums = [5,7,7,8,8,10], target = 8

输出: 2
示例 2:
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
 ```


提示：

0 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
nums 是一个非递减数组
-10^9 <= target <= 10^9



**思路1**：二分法。先找到target，再从该位置往两边进行拓展。

```C++
int search(vector<int>& nums, int target) {
    if(nums.empty()) return 0;
    //二分法
    int low=0,high=nums.size()-1;
    int index=-1;
    while(low<=high){
        int mid=(low+high)/2;
        if(nums[mid]==target){
            index=mid;
            break;
        }
        else if(nums[mid]<target)
            low=mid+1;
        else
            high = mid-1;
    }
    if(index==-1){
        return 0;
    }
    else{//找到起点和终点
        high=index;
        while(high<nums.size() && nums[high]==target)high++;
        low=index;
        while(low>=0 && nums[low]==target)low--;
        return high-low-1;
    }
}
```

最差时间复杂度：O(n)



**思路2**：二分查找。

通过二分查找同时查找target在数组中的起点之前的位置和终点之后的位置

```C++
int search(vector<int>& nums, int target) {
    if(nums.empty()) return 0;
    else if(nums.size()==1){
        if(nums[0]==target) return 1;
        else return 0;
    }
    int N=nums.size();
    int start=-1,end=N;//设置初值
    //找到起点
    int low=0,high=N-1;
    if(nums[0]!=target){
        while(low<=high){
            int mid = (low+high)/2;
            if(mid==N-1)
                break;
            else if(nums[mid]!=target && nums[mid+1]==target){
                start=mid;
                break;
            }
            else if(nums[mid+1]<target)
                low = mid+1;
            else if(nums[mid+1]>target)
                high=mid-1;
            else if(nums[mid+1]==target && nums[mid]==target)
                high=mid-1;
        }
    }
    if(nums[start+1]!=target) //不存在target
        return 0;
    //找到终点
    low++,high=N-1;
    if(nums[N-1]!=target){
        while(low<=high){
            int mid = (low+high)/2;
            if(mid==0)
                break;
            else if(nums[mid]!=target && nums[mid-1]==target){
                end=mid;
                break;
            }
            else if(nums[mid-1]<target)
                low = mid+1;
            else if(nums[mid-1]>target)
                high=mid-1;
            else if(nums[mid-1]==target && nums[mid]==target)
                low=mid+1;
        }
    }
    return end-start-1;
}
```



**官方题解**：直观的思路肯定是从前往后遍历一遍。用两个变量记录第一次和最后一次遇见 target 的下标，但这个方法的时间复杂度为 O(n)，没有利用到数组升序排列的条件。

由于数组已经排序，因此整个数组是单调递增的，我们可以利用二分法来加速查找的过程。

考虑 target 在数组中出现的次数，其实我们要找的就是数组中「第一个等于 target 的位置」（记为 leftIdx）和「第一个大于 target 的位置减一」（记为 rightIdx）。当 target 在数组中存在时，target 在数组中出现的次数为 rightIdx−leftIdx+1。

二分查找中，寻找 leftIdx 即为在数组中寻找第一个大于等于 target 的下标，寻找 rightIdx 即为在数组中寻找第一个大于 target 的下标，然后将下标减一。两者的判断条件不同，为了代码的复用，我们定义 binarySearch(nums, target, lower) 表示在 nums 数组中二分查找 target 的位置，**如果 lower 为 true，则查找第一个大于等于 target 的下标，否则查找第一个大于 target 的下标**。

最后，因为 target 可能不存在数组中，因此我们需要重新校验我们得到的两个下标 leftIdx 和 rightIdx，看是否符合条件，如果符合条件就返回 rightIdx−leftIdx+1，不符合就返回 00。

```C++
int binarySearch(vector<int>& nums, int target, bool lower) {
    int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
    while (left <= right) {
        int mid = (left + right) / 2;
        if(lower){//找下界
            if(nums[mid] >= target){
                right = mid - 1;
            	ans = mid;
            }
            else{//小于
                left = mid + 1;
            }
        }
        else{//找上界
            if (nums[mid] > target) {//大于
                right = mid - 1;
                ans = mid;
            } else {//小于等于
                left = mid + 1;
            }            
        }
    }
    return ans;
}

int search(vector<int>& nums, int target) {
    int leftIdx = binarySearch(nums, target, true);
    int rightIdx = binarySearch(nums, target, false) - 1;
    if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {
        return rightIdx - leftIdx + 1;
    }
    return 0;
}
```





### J53. 0~n-1中缺失的数字 II

**[题目]()**：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

 ```
示例 1:
输入: [0,1,3]
输出: 2

示例 2:
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
 ```


限制：

1 <= 数组长度 <= 10000



**思路1**：二分查找。

根据题意，数组可以按照以下规则划分为两部分。

* 左子数组： `nums[i]=i` ；
* 右子数组： `nums[i] != i` ；
* 缺失的数字等于 “右子数组的首位元素” 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素”

算法解析：

1. 初始化： 左边界 `i=0` ，右边界 `j=len(nums)−1` ；代表闭区间 `[i, j]` 。
2. 循环二分： 当 i≤j 时循环 （即当闭区间 `[i,j]` 为空时跳出） ；
   * 计算中点 `m=(i+j)//2` ，其中 "//" 为向下取整除法；
   * 若 `nums[m]=m` ，则 “右子数组的首位元素” 一定在闭区间 `[m + 1, j]` 中，因此执行 `i = m + 1`；
   * 若 `nums[m]!= m` ，则 “左子数组的末位元素” 一定在闭区间 `[i, m - 1]`中，因此执行 `j=m−1`；

​	返回值： 跳出时，变量 i 和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。

```C++
int missingNumber(vector<int>& nums) {
    int left=0,right=nums.size()-1;
    while(left<=right){
        int mid = (left+right)/2;
        if(nums[mid]==mid) left=mid+1;
        else right=mid-1;
    }
    return left;
}
```




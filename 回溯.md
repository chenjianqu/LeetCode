# 回溯算法

## 基础知识

### 回溯算法要解决的问题

组合问题：N个数⾥⾯按⼀定规则找出k个数的集合
切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式
⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集
排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式
棋盘问题：N皇后，解数独等等



排列和组合的区别：**组合是不强调元素顺序的，排列是强调元素顺序**。





### 回溯算法的模板

**1 回溯函数模板返回值以及参数**  
因为回溯算法需要的参数可不像⼆叉树递归的时候那么容易⼀次性确定下来，所以⼀ 般是先写逻辑，然后需要什么参数，就填什么参数  

**2 回溯函数终⽌条件**
树中就可以看出，⼀般来说搜到叶⼦节点了，也就找到了满⾜条件的⼀条答 案，把这个答案存放起来，并结束本层递归。

**3 回溯搜索的遍历过程**  
 回溯法⼀般是在集合中递归搜索，集合的⼤⼩构成了树的宽度，递归的深度构成的 树的深度。出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，⼀般来说，搜索叶⼦节点就是找的其中⼀个结果了。

代码框架如下：

```C++
void backtracking(参数) {
    if (终⽌条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```









## 题目



## 组合问题



### L77. 组合

**题目**：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。



**思路1**：回溯。

回溯函数的参数：n,k和遍历起始值。

回溯终止条件：路径数组中的大小满足要求。

遍历过程：for循环搜索。

```C++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
private:
    void backtracking(int n,int k,int start){
        if(path.size()==k){
            result.push_back(path);
            return;
        }
        for(int i=start;i<=n;++i){
            path.push_back(i);
            backtracking(n,k,i+1);
            path.pop_back();//回溯
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```



### L216. 组合总和III

**题目**：找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。



**思路1**：回溯。

回溯函数的参数：n,k和遍历起始值。

回溯终止条件：路径数组中的大小满足要求 且 其和为目标值。

遍历过程：for循环搜索，从1到9。

```C++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        backtrack(k,n,1);
        return result;
    }
private:
    void backtrack(int k,int n,int start){
        if(path.size()==k){
            if(std::accumulate(path.begin(),path.end(),0)==n)
                result.push_back(path);
            return;
        }
        for(int i=start;i<10;++i){
            path.push_back(i);
            backtrack(k,n,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```





### L17. 电话号码的字母组合

**题目**：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。



**思路1**：回溯。

**回溯函数的参数**：输入的字符串digits，和当前选择到第几个数字的下标index。

这里不需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？如果是⼀个集合来求组合的话，就需要startIndex，例如L216、L77。 如果是多个集合取组合，各个集合之间相互不影响，那么就不⽤startIndex，例如L17。

**回溯终止条件**：index==digits.size。

**遍历过程**：在每次递归中，根据哈希表得到当前数字对应的字符串，遍历字符串的每个字符。

```C++
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return result;
        backtrack(digits,0);
        return result;
    }
private:
    void backtrack(string digits,int index){
        if(index==digits.size()){
            result.push_back(path);
            return;
        }
        string chars = keyboard[digits[index]];
        for(auto e: chars){
            path.push_back(e);
            backtrack(digits,index+1);
            path.pop_back();
        }
    }
    std::unordered_map<char,string> keyboard = {
        {'2',"abc"},{'3',"def"},{'4',"ghi"},{'5',"jkl"},{'6',"mno"},{'7',"pqrs"},
        {'8',"tuv"},{'9',"wxyz"}
    };
    vector<string> result;
    string path;
};
```







### L39. 组合总和

**题目**：给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。



**思路1**：回溯。

```C++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtrack(candidates,target,0);
        return result;
    }
private:
    void backtrack(vector<int>& candidates, int target,int start){
        if(int sum=std::accumulate(path.begin(),path.end(),0);sum == target){
            result.push_back(path);
            return;
        }
        else if(sum>target){
            return;
        }
        for(int i=start;i<candidates.size();++i){
            path.push_back(candidates[i]);
            backtrack(candidates,target,i);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```





### L40. 组合总和 II

**题目**：给你一个由候选元素组成的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个元素在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。 



**思路1**：回溯。

这道题⽬和39.组合总和如下区别：
1. 本题candidates 中的每个数字在每个组合中只能使⽤⼀次。
2. 本题数组candidates的元素是有重复的，⽽39.组合总和是⽆重复元素的数组candidates
最后本题和39.组合总和要求⼀样，解集不能包含重复的组合。

本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合。

	所谓**去重**，其实就是使⽤过的元素不能重复选取。 组合问题可以抽象为树形结构，那么“使⽤过”在这个树形结构上是有两个维度的，⼀个维度是同⼀树枝上使⽤过，⼀个维度是同⼀树层上使⽤过。回看⼀下题⽬，元素在同⼀个组合内是可以重复的，但两个组合不能相同。所以我们要去重的是同⼀树层上的“使⽤过”，同⼀树枝上的都是⼀个组合⾥的元素，不⽤去重。
	
	为了实现树层的去重，需要对候选数组进行排序，使得两个相等的元素相邻。此外，还需要定义一个used数组用来判断同一层循环中某个元素是否已经使用过了。
	
	如何使用used数组？将某个元素添加到path的时候，将对应位置的used数组元素设置为true，表示该元素已经在路径中了。
	
	当 candidates[i] == candidates[i - 1] && used[i - 1] == false 时，表示当前遍历的元素和上一个元素相等，但是used[i - 1] == false表示candidates[i-1]不在路径上，这表明之前已经遍历过了这条路径，因此此时跳过该元素。

代码：

```C++
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        std::sort(candidates.begin(),candidates.end());
        used.resize(candidates.size());
        backtrack(candidates,target,0);
        return result;
    }
private:
    void backtrack(vector<int>& candidates, int target,int start){
        if(int sum=std::accumulate(path.begin(),path.end(),0);sum==target){
            result.push_back(path);
            return;
        }
        else if(sum>target){
            return;
        }
        for(int i=start;i<candidates.size();++i){
            // used[i - 1] == true，说明同⼀树⽀candidates[i - 1]使⽤过
			// used[i - 1] == false，说明同⼀树层candidates[i - 1]使⽤过
            if(i>0 && candidates[i-1]==candidates[i] &&
            used[i-1]==false)
                continue;
            path.push_back(candidates[i]);
            used[i]=true;
            backtrack(candidates,target,i+1);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> result;
    vector<int> path;
    vector<bool> used;
};
```





## 分割问题

### L131. 分割回文串

**题目**：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。



**思路1**：回溯。

列出如下⼏个难点：
切割问题可以抽象为组合问题
如何模拟那些切割线
切割问题中递归如何终⽌
在递归循环中如何截取⼦串
如何判断回⽂



1. 切割问题，有不同的切割⽅式
2. 判断回⽂

切割问题：切割⼀个a之后，在bcdef中再去切割第⼆段，切割b之后在cdef中在切割第三段.....。

**递归函数参数：**
全局变量数组path存放切割后回⽂的⼦串，⼆维数组result存放结果集。 （这两个参数可以放到函数参数⾥）。本题递归函数参数还需要startIndex，因为切割过的地⽅，不能重复切割，和组合问题也是保持⼀致的。

**递归函数终⽌条件**：切割线切到了字符串最后⾯，说明找到了⼀种切割⽅法，此时就是本层递
归的终⽌终⽌条件。

**单层搜索的逻辑**：在 for (int i = startIndex; i < s.size(); i++) 循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的⼦串。⾸先判断这个⼦串是不是回⽂，如果是回⽂，就加⼊在 vector<string> path 中，path⽤来记录切割过的回⽂⼦串。

```C++
class Solution {
public:
    vector<vector<string>> partition(string s) {
        backtrack(s,0);
        return result;
    }
private:
    bool judge(string &s){
        for(int i=0;i<s.size()/2;++i)
            if(s[i]!=s[s.size()-1-i])
                return false;
        return true;
    }
    void backtrack(string &s,int start){
        if(start>=s.size()){
            result.push_back(path);
            return;
        }
        for(int i=start;i<s.size();++i){
            string substr = s.substr(start,i-start+1);
            if(!judge(substr))
                continue;
            path.push_back(substr);
            backtrack(s,i+1);
            path.pop_back();
        }
    }
    vector<vector<string>> result;
    vector<string> path;
};
```







### L93. 复原IP地址

**题目**：有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。



**思路1**：回溯。

同L31类似，这是一个分割问题。

**回溯函数的参数**：定义一个全局变量result用来保存分割的结果，定义一个path变量来保存每个遍历树的树枝上的变量结果。由于是切割问题，因此定义一个start参数来收缩遍历的范围。

**终止条件**：当分割的段数为4时，停止回溯。当切割已经完成时，将path保存到result中。

**单层的遍历过程**：从start遍历到s字符串的末尾。若num.size()>1 && num[0]=='0'时，取消遍历；若std::stoi(num)>255时，取消遍历。

```C++
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        backtrack(s,0);
        return result;
    }
private:
    void backtrack(string &s,int start){
        if(path.size()==4){
            if(start>=s.size())
                result.push_back(path[0]+"."+path[1]+"."+path[2]+"."+path[3]);
            return;
        }
        for(int i=start;i<s.size();++i){
            string num = s.substr(start,i-start+1);
            if(num.size()>1 && num[0]=='0')
                break;
            if(std::stoi(num)>255)
                break;
            path.push_back(num);
            backtrack(s,i+1);
            path.pop_back();
        }
    }
    vector<string> path;
    vector<string> result;
};
```





## 子集问题

如果把 ⼦集问题、组合问题、分割问题都抽象为⼀棵树的话，那么组合问题和分割问题都是收集树的叶⼦节点，⽽⼦集问题是找树的所有节点！

那么既然是⽆序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，⽽不是从0开始！ 有同学问了，什么时候for可以从0开始呢？求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合。



### L78. 子集

**题目**：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。



**思路1**：回溯。

这道题其实就是一个组合问题。由于需要遍历所有的节点，因此在回溯函数里面首先将当前节点添加到result中。再执行遍历。

```C++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        backtrack(nums,0);
        return result;
    }
private:
    void backtrack(vector<int>& nums, int index){
        result.push_back(path);
        if(index>=nums.size())
            return;
        for(int i = index;i<nums.size();++i){
            path.push_back(nums[i]);
            backtrack(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```



### L491. 递增子序列

**题目**：给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。



**思路1**：回溯。

题目是一个求子集的问题，但是又要求不能重复。

⽽本题求⾃增⼦序列，是不能对原数组经⾏排序的，排完序的数组都是⾃增⼦序列了。因此不能像 L40 那样对数组进行排序来去重。

这里使用的去重方式是 通过**哈希集合**去重。

**递归函数参数：**本题求⼦序列，很明显⼀个元素不能重复使⽤，所以需要startIndex，调整下⼀层递归的起始位置。

**终⽌条件**：题⽬要求递增⼦序列⼤⼩⾄少为2，或start > nums.size().

```C++
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        used.resize(nums.size());
        backtrack(nums,0,INT_MIN);
        return result;
    }
private:
    void backtrack(vector<int>& nums,int start,int last){
        if(path.size()>=2)
            result.push_back(path);
        if(start>=nums.size())
            return;
        std::unordered_set<int> hash_set;//用于同一树层内去重
        for(int i=start;i<nums.size();++i){
            if(nums[i]<last)
                continue;
            if(hash_set.find(nums[i])!=hash_set.end())
                continue;
            hash_set.insert(nums[i]);
            path.push_back(nums[i]);
            backtrack(nums,i+1,nums[i]);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```





### L90. 子集II

**题目**：给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

示例 1：

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
示例 2：

输入：nums = [0]
输出：[[],[0]]


提示：

1 <= nums.length <= 10
-10 <= nums[i] <= 10



**思路1**：回溯。

这道题和 L78 的不同之处在于 本题给定的nums可能包含重复元素。

这里采用的去重方法是首先对nums进行排序，然后使用哈希集合对同一个树层内的数字去重。

**注意**：对于求子集来说，一定要先排序。因为集合{1,2}和{2,1}是相等的。若不排序，则可能会出现这类等价的子集。

代码：

```C++
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        std::sort(nums.begin(),nums.end());
        backtrack(nums,0);
        return result;
    }
private:
    void backtrack(vector<int>& nums,int start){
        result.push_back(path);
        if(start>=nums.size()){
            return;
        }
        std::unordered_set<int> hash_set;
        for(int i=start;i<nums.size();++i){
            if(hash_set.find(nums[i])!=hash_set.end()) continue;
            path.push_back(nums[i]);
            hash_set.insert(nums[i]);
            backtrack(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```











## 排列问题





### L46. 全排列

**题目**：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

**思路1**：回溯。

**递归函数参数**
⾸先排列是有序的，也就是说[1,2] 和[2,1] 是两个集合，这和之前分析的⼦集以及组合所不同的地⽅。可以看出元素1在[1,2]中已经使⽤过了，但是在[2,1]中还要在使⽤⼀次1，所以处理排列问题就不⽤使⽤startIndex了。
但排列问题需要⼀个used数组，标记已经选择的元素。

**递归终⽌条件**

可以看出叶⼦节点，就是收割结果的地⽅。当收集元素的数组path的⼤⼩达到和nums数组⼀样⼤的时候，说明找到了⼀个全排列，也表示到达了叶⼦节点。

**单层搜索的逻辑**
这⾥和组合问题、切割问题和⼦集问题最⼤的不同就是for循环⾥不⽤startIndex了。因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使⽤过了，但是在[2,1]中还要再使⽤⼀次1。 ⽽used数组，其实就是记录此时path⾥都有哪些元素使⽤了，⼀个排列⾥⼀个元素只能使⽤⼀次。

排列问题的不同：
每层都是从0开始搜索⽽不是startIndex
需要used数组记录path⾥都放了哪些元素了

代码：

```C++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        used.resize(nums.size());
        backtrack(nums);
        return result;
    }
private:
    void backtrack(vector<int>& nums){
        if(path.size()==nums.size()){
            result.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();++i){
            if(used[i])continue;
            path.push_back(nums[i]);
            used[i]=true;
            backtrack(nums);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> result;
    vector<int> path;
    vector<bool> used;
};
```



### L47. 全排列II

**题目**：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。



**思路1**：回溯。哈希集合去重。

这道题和 L46 的不同之处在于 给定的nums可能含有重复的数字。这会导致回溯得到的数组会存在重复。重复的原因是 在同一个回溯函数的遍历中，遍历到两个重复的数字，最后会得到的重复的结果。

因此，这里的解决方法是使用哈希集合来防止在同一个循环内遍历重复的数字。

代码：

```C++
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        used.resize(nums.size());
        backtrack(nums);
        return result;
    }
private:
    void backtrack(vector<int>& nums){
        if(path.size() == nums.size()){
            result.push_back(path);
            return;
        }
        std::unordered_set<int> hash_set;
        for(int i=0;i<nums.size();++i){
            if(used[i])continue;
            if(hash_set.find(nums[i])!=hash_set.end()) continue;
            path.push_back(nums[i]);
            used[i]=true;
            hash_set.insert(nums[i]);
            backtrack(nums);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> result;
    vector<int> path;
    vector<bool> used;
};
```



**思路2**：回溯。排序去重。

这里首先对nums进行排序，然后根据used数组判断同一层内相同的数字是否被使用过。

```C++
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        used.resize(nums.size());
        std::sort(nums.begin(),nums.end());
        backtrack(nums);
        return result;
    }
private:
    void backtrack(vector<int>& nums){
        if(path.size() == nums.size()){
            result.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();++i){
            if(used[i])continue;
            if(i>0 && nums[i]==nums[i-1] &&used[i-1]==false) continue;
            path.push_back(nums[i]);
            used[i]=true;
            backtrack(nums);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> result;
    vector<int> path;
    vector<bool> used;
};
```





## 其它

### L332. 重新安排行程

**题目**：给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。
假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。





### L51. N皇后

**[题目](https://leetcode-cn.com/problems/n-queens/)**：n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

不能相互攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。



**思路1**：回溯。

首先先将path初始化为棋盘的大小，并设置每个位置为 '.' 。

回溯参数：棋盘格大小n ，和回溯到的行序号row

停止条件：当row==n时，将棋盘格放入结果数组result

单层迭代：遍历第row行，从0到n。并判断每个位置是否满足N皇后的约束。

这个判断是否满足约束，需要判断同一列、45度、135度是否存在Q。

代码：

```C++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        path = std::vector<string>(n,string(n,'.'));//创建棋盘
        backward(n,0);
        return result;
    }
private:
    bool IsValid(int row,int col,int n){
        //判断同列是否已经存在了Q点
        for(int i=0;i<row;++i){
            if(path[i][col]=='Q')
                return false;
        }
        //判断正45度是否已经存在Q点
        for(int i=row,j=col;i>=0 && j>=0;--i,--j){
            if(path[i][j]=='Q')
                return false;
        }
        //判断135读是否存在Q点
        for(int i=row,j=col;i>=0 && j<n;--i,++j){
            if(path[i][j]=='Q')
                return false;
        }
        return true;
    }
    void backward(int n,int row){
        if(row>=n){
            result.push_back(path);
            return;
        }
        for(int col=0;col<n;++col){
            //判断是否和n皇后的条件冲突了
            if(!IsValid(row,col,n))continue;
            path[row][col]='Q';
            backward(n,row+1);
            path[row][col]='.';
        }
    }
    vector<vector<string>> result;
    vector<string> path;
};
```





### L52. N皇后II

**题目**：n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。



**思路1**：回溯。

解法类似于L51。不过输出的结果是方案的数量，而不是每个方案。

代码：

```C++
class Solution {
public:
    int totalNQueens(int n) {
        path = vector<vector<bool>>(n,vector<bool>(n,false));
        backtrack(n,0);
        return number;
    }
private:
    bool IsValid(int row,int col,int n){
        for(int i=0;i<row;++i)
            if(path[i][col])
                return false;
        for(int i=row,j=col;i>=0 && j>=0;--i,--j)
            if(path[i][j])
                return false;
        for(int i=row,j=col;i>=0 && j<n;--i,++j)
            if(path[i][j])
                return false;
        return true;
    }
    void backtrack(int n,int row){
        if(row==n){
            number++;
            return;
        }
        for(int i=0;i<n;++i){
            if(!IsValid(row,i,n))
                continue;
            path[row][i]=true;
            backtrack(n,row+1);
            path[row][i]=false;
        }
    }

    vector<vector<bool>> path;
    int number{0};
};
```














# 回溯算法

## 基础知识

### 回溯算法要解决的问题

组合问题：N个数⾥⾯按⼀定规则找出k个数的集合
切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式
⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集
排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式
棋盘问题：N皇后，解数独等等



排列和组合的区别：**组合是不强调元素顺序的，排列是强调元素顺序**。





### 回溯算法的模板

**1 回溯函数模板返回值以及参数**  
因为回溯算法需要的参数可不像⼆叉树递归的时候那么容易⼀次性确定下来，所以⼀ 般是先写逻辑，然后需要什么参数，就填什么参数  

**2 回溯函数终⽌条件**
树中就可以看出，⼀般来说搜到叶⼦节点了，也就找到了满⾜条件的⼀条答 案，把这个答案存放起来，并结束本层递归。

**3 回溯搜索的遍历过程**  
 回溯法⼀般是在集合中递归搜索，集合的⼤⼩构成了树的宽度，递归的深度构成的 树的深度。出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，⼀般来说，搜索叶⼦节点就是找的其中⼀个结果了。

代码框架如下：

```C++
void backtracking(参数) {
    if (终⽌条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```









## 题目



## 组合问题



### L77. 组合

**题目**：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。



**思路1**：回溯。

回溯函数的参数：n,k和遍历起始值。

回溯终止条件：路径数组中的大小满足要求。

遍历过程：for循环搜索。

```C++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
private:
    void backtracking(int n,int k,int start){
        if(path.size()==k){
            result.push_back(path);
            return;
        }
        for(int i=start;i<=n;++i){
            path.push_back(i);
            backtracking(n,k,i+1);
            path.pop_back();//回溯
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```



### L216. 组合总和III

**题目**：找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。



**思路1**：回溯。

回溯函数的参数：n,k和遍历起始值。

回溯终止条件：路径数组中的大小满足要求 且 其和为目标值。

遍历过程：for循环搜索，从1到9。

```C++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        backtrack(k,n,1);
        return result;
    }
private:
    void backtrack(int k,int n,int start){
        if(path.size()==k){
            if(std::accumulate(path.begin(),path.end(),0)==n)
                result.push_back(path);
            return;
        }
        for(int i=start;i<10;++i){
            path.push_back(i);
            backtrack(k,n,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```





### L17. 电话号码的字母组合

**题目**：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。



**思路1**：回溯。

**回溯函数的参数**：输入的字符串digits，和当前选择到第几个数字的下标index。

这里不需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？如果是⼀个集合来求组合的话，就需要startIndex，例如L216、L77。 如果是多个集合取组合，各个集合之间相互不影响，那么就不⽤startIndex，例如L17。

**回溯终止条件**：index==digits.size。

**遍历过程**：在每次递归中，根据哈希表得到当前数字对应的字符串，遍历字符串的每个字符。

```C++
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return result;
        backtrack(digits,0);
        return result;
    }
private:
    void backtrack(string digits,int index){
        if(index==digits.size()){
            result.push_back(path);
            return;
        }
        string chars = keyboard[digits[index]];
        for(auto e: chars){
            path.push_back(e);
            backtrack(digits,index+1);
            path.pop_back();
        }
    }
    std::unordered_map<char,string> keyboard = {
        {'2',"abc"},{'3',"def"},{'4',"ghi"},{'5',"jkl"},{'6',"mno"},{'7',"pqrs"},
        {'8',"tuv"},{'9',"wxyz"}
    };
    vector<string> result;
    string path;
};
```







### L39. 组合总和

**题目**：给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。



**思路1**：回溯。

```C++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtrack(candidates,target,0);
        return result;
    }
private:
    void backtrack(vector<int>& candidates, int target,int start){
        if(int sum=std::accumulate(path.begin(),path.end(),0);sum == target){
            result.push_back(path);
            return;
        }
        else if(sum>target){
            return;
        }
        for(int i=start;i<candidates.size();++i){
            path.push_back(candidates[i]);
            backtrack(candidates,target,i);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```





### L40. 组合总和 II

**题目**：给你一个由候选元素组成的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个元素在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。 



**思路1**：回溯。

这道题⽬和39.组合总和如下区别：
1. 本题candidates 中的每个数字在每个组合中只能使⽤⼀次。
2. 本题数组candidates的元素是有重复的，⽽39.组合总和是⽆重复元素的数组candidates
最后本题和39.组合总和要求⼀样，解集不能包含重复的组合。

本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合。

​	所谓**去重**，其实就是使⽤过的元素不能重复选取。 组合问题可以抽象为树形结构，那么“使⽤过”在这个树形结构上是有两个维度的，⼀个维度是同⼀树枝上使⽤过，⼀个维度是同⼀树层上使⽤过。回看⼀下题⽬，元素在同⼀个组合内是可以重复的，但两个组合不能相同。所以我们要去重的是同⼀树层上的“使⽤过”，同⼀树枝上的都是⼀个组合⾥的元素，不⽤去重。

​	为了实现树层的去重，需要对候选数组进行排序，使得两个相等的元素相邻。此外，还需要定义一个used数组用来判断同一层循环中某个元素是否已经使用过了。

​	如何使用used数组？将某个元素添加到path的时候，将对应位置的used数组元素设置为true，表示该元素已经在路径中了。

​	当 candidates[i] == candidates[i - 1] && used[i - 1] == false 时，表示当前遍历的元素和上一个元素相等，但是used[i - 1] == false表示candidates[i-1]不在路径上，这表明之前已经遍历过了这条路径，因此此时跳过该元素。

代码：

```C++
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        std::sort(candidates.begin(),candidates.end());
        used.resize(candidates.size());
        backtrack(candidates,target,0);
        return result;
    }
private:
    void backtrack(vector<int>& candidates, int target,int start){
        if(int sum=std::accumulate(path.begin(),path.end(),0);sum==target){
            result.push_back(path);
            return;
        }
        else if(sum>target){
            return;
        }
        for(int i=start;i<candidates.size();++i){
            // used[i - 1] == true，说明同⼀树⽀candidates[i - 1]使⽤过
			// used[i - 1] == false，说明同⼀树层candidates[i - 1]使⽤过
            if(i>0 && candidates[i-1]==candidates[i] &&
            used[i-1]==false)
                continue;
            path.push_back(candidates[i]);
            used[i]=true;
            backtrack(candidates,target,i+1);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> result;
    vector<int> path;
    vector<bool> used;
};
```





### L131. 分割回文串

**题目**：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。



**思路1**：回溯。

列出如下⼏个难点：
切割问题可以抽象为组合问题
如何模拟那些切割线
切割问题中递归如何终⽌
在递归循环中如何截取⼦串
如何判断回⽂



1. 切割问题，有不同的切割⽅式
2. 判断回⽂

切割问题：切割⼀个a之后，在bcdef中再去切割第⼆段，切割b之后在cdef中在切割第三段.....。

**递归函数参数：**
全局变量数组path存放切割后回⽂的⼦串，⼆维数组result存放结果集。 （这两个参数可以放到函数参数⾥）。本题递归函数参数还需要startIndex，因为切割过的地⽅，不能重复切割，和组合问题也是保持⼀致的。

**递归函数终⽌条件**：切割线切到了字符串最后⾯，说明找到了⼀种切割⽅法，此时就是本层递
归的终⽌终⽌条件。

**单层搜索的逻辑**：在 for (int i = startIndex; i < s.size(); i++) 循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的⼦串。⾸先判断这个⼦串是不是回⽂，如果是回⽂，就加⼊在 vector<string> path 中，path⽤来记录切割过的回⽂⼦串。

```C++
class Solution {
public:
    vector<vector<string>> partition(string s) {
        backtrack(s,0);
        return result;
    }
private:
    bool judge(string &s){
        for(int i=0;i<s.size()/2;++i)
            if(s[i]!=s[s.size()-1-i])
                return false;
        return true;
    }
    void backtrack(string &s,int start){
        if(start>=s.size()){
            result.push_back(path);
            return;
        }
        for(int i=start;i<s.size();++i){
            string substr = s.substr(start,i-start+1);
            if(!judge(substr))
                continue;
            path.push_back(substr);
            backtrack(s,i+1);
            path.pop_back();
        }
    }
    vector<vector<string>> result;
    vector<string> path;
};
```







# 回溯算法

## 基础知识

### 回溯算法要解决的问题

组合问题：N个数里面按⼀定规则找出k个数的集合
切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式
⼦集问题：⼀个N个数的集合里有多少符合条件的⼦集
排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式
棋盘问题：N皇后，解数独等等



排列和组合的区别：**组合是不强调元素顺序的，排列是强调元素顺序**。





### 回溯算法的模板

**1 回溯函数模板返回值以及参数**  
因为回溯算法需要的参数可不像⼆叉树递归的时候那么容易⼀次性确定下来，所以⼀ 般是先写逻辑，然后需要什么参数，就填什么参数  

**2 回溯函数终止条件**
树中就可以看出，⼀般来说搜到叶⼦节点了，也就找到了满⾜条件的⼀条答 案，把这个答案存放起来，并结束本层递归。

**3 回溯搜索的遍历过程**  
 回溯法⼀般是在集合中递归搜索，集合的⼤⼩构成了树的宽度，递归的深度构成的 树的深度。出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，⼀般来说，搜索叶⼦节点就是找的其中⼀个结果了。

代码框架如下：

```C++
void backtracking(参数) {
    if (终⽌条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```







## 题目





### J12. 矩阵中的路径

**[题目](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)**：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

```
示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

示例 2：
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

提示：

    1 <= board.length <= 200
    1 <= board[i].length <= 200
    board 和 word 仅由大小写英文字母组成



**思路1**：深度优先搜索。

 	递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。

​	终止条件：
​        返回 false： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。
​        返回 true ： k = len(word) - 1 ，即字符串 word 已全部匹配。
​    递推工作：
​        标记当前矩阵元素： 将 `board[i][j]` 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问。
​        搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。
​        还原当前矩阵元素： 将 `board[i][j]` 元素还原至初始值，即`word[k]` 。
​    返回值： 返回布尔量 res ，代表是否搜索到目标字符串。
​	使用空字符‘ ’做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。



```C++
bool dfs(vector<vector<char>>& board, string& word,int row,int col,int k){
    if(k==word.size()) return true;
    int rows = board.size();
    int cols = board[0].size();
    if(row!=0 && board[row-1][col]==word[k]){
        board[row-1][col]=' ';
        if(dfs(board,word,row-1,col,k+1))return true;
        board[row-1][col]=word[k];
    }
    if(col!=0 && board[row][col-1]==word[k]){
        board[row][col-1]=' ';
        if(dfs(board,word,row,col-1,k+1))return true;
        board[row][col-1]=word[k];
    }
    if(row!=rows-1 && board[row+1][col]==word[k]){
        board[row+1][col]=' ';
        if(dfs(board,word,row+1,col,k+1)) return true;;
        board[row+1][col]=word[k];
    }
    if(col!=cols-1 && board[row][col+1]==word[k]){
        board[row][col+1]=' ';
        if(dfs(board,word,row,col+1,k+1)) return true;
        board[row][col+1]=word[k];
    }
    return false;
}

bool exist(vector<vector<char>>& board, string word) {
    if(board.size()==1 && board[0].size()==1){
        if(word.size()==1 && board[0][0]==word[0]) 
            return true;
        else 
            return false;
    }
    for(int i=0;i<board.size();++i){
        for(int j=0;j<board[0].size();++j){
            if(dfs(board,word,i,j,0))
                return true;
        }
    }
    return false;
}
```



代码简化版本：

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        rows = board.size();
        cols = board[0].size();
        for(int i = 0; i < rows; i++) 
            for(int j = 0; j < cols; j++) 
                if(dfs(board, word, i, j, 0)) 
                    return true;
        return false;
    }
private:
    int rows, cols;
    bool dfs(vector<vector<char>>& board, string word, int i, int j, int k) {
        if(i >= rows || i < 0 || j >= cols || j < 0 || board[i][j] != word[k]) return false;
        if(k == word.size() - 1) return true;
        board[i][j] = '\0';
        bool res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    }
};

```





### J13. 机器人的运动范围

**[题目](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)**: 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

 ```
 示例 1：
 
 输入：m = 2, n = 3, k = 1
 输出：3
 
 示例 2：
 
 输入：m = 3, n = 1, k = 0
 输出：1
 ```

提示：

    1 <= n,m <= 100
    0 <= k <= 20



**思路1**：深度优先搜索。

那么如何计算一个数的数位之和呢？我们只需要对数 x 每次对 10 取余，就能知道数 x 的个位数是多少，然后再将 x 除 10，这个操作等价于将 x 的十进制数向右移一位，删除个位数（类似于二进制中的 >> 右移运算符），不断重复直到 x 为 0 时结束。



构建一个二维数组来表示棋盘格，当访问了某个节点后，`array[row][col] = 1`，从而避免重复的访问节点。

```
class Solution {
public:
    int counter=0;
    int sum_number(int num){
    	int tmp=num,sum=0;
        while(tmp>0){
            sum+=tmp%10;
            tmp/=10;
        }
        return sum;
    }
    
    void dfs(vector<vector<bool>> &array,int m, int n, int k,int row,int col){
        if(row<0 || row>=m || col<0 || col>=n) return;
        if(array[row][col]==1)
            return;
        else
            array[row][col]=1;
        if(sum_number(row)+sum_number(col) >k)return;
        counter++;
        dfs(array,m,n,k,row+1,col);
        dfs(array,m,n,k,row,col+1);
        dfs(array,m,n,k,row-1,col);
        dfs(array,m,n,k,row,col-1);
    }

    int movingCount(int m, int n, int k) {
        vector<vector<bool>> array(m,vector<bool>(n,0));
        dfs(array,m,n,k,0,0);
        return counter;
    }
};
```











## 组合问题



### L77. 组合

**题目**：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。



**思路1**：回溯。

回溯函数的参数：n,k和遍历起始值。

回溯终止条件：路径数组中的大小满足要求。

遍历过程：for循环搜索。

```C++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }
private:
    void backtracking(int n,int k,int start){
        if(path.size()==k){
            result.push_back(path);
            return;
        }
        for(int i=start;i<=n;++i){
            path.push_back(i);
            backtracking(n,k,i+1);
            path.pop_back();//回溯
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```



### L216. 组合总和III

**题目**：找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。



**思路1**：回溯。

回溯函数的参数：n,k和遍历起始值。

回溯终止条件：路径数组中的大小满足要求 且 其和为目标值。

遍历过程：for循环搜索，从1到9。

```C++
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        backtrack(k,n,1);
        return result;
    }
private:
    void backtrack(int k,int n,int start){
        if(path.size()==k){
            if(std::accumulate(path.begin(),path.end(),0)==n)
                result.push_back(path);
            return;
        }
        for(int i=start;i<10;++i){
            path.push_back(i);
            backtrack(k,n,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```





### L17. 电话号码的字母组合

**题目**：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。



**思路1**：回溯。

**回溯函数的参数**：输入的字符串digits，和当前选择到第几个数字的下标index。

这里不需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？如果是⼀个集合来求组合的话，就需要startIndex，例如L216、L77。 如果是多个集合取组合，各个集合之间相互不影响，那么就不⽤startIndex，例如L17。

**回溯终止条件**：index==digits.size。

**遍历过程**：在每次递归中，根据哈希表得到当前数字对应的字符串，遍历字符串的每个字符。

```C++
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return result;
        backtrack(digits,0);
        return result;
    }
private:
    void backtrack(string digits,int index){
        if(index==digits.size()){
            result.push_back(path);
            return;
        }
        string chars = keyboard[digits[index]];
        for(auto e: chars){
            path.push_back(e);
            backtrack(digits,index+1);
            path.pop_back();
        }
    }
    std::unordered_map<char,string> keyboard = {
        {'2',"abc"},{'3',"def"},{'4',"ghi"},{'5',"jkl"},{'6',"mno"},{'7',"pqrs"},
        {'8',"tuv"},{'9',"wxyz"}
    };
    vector<string> result;
    string path;
};
```







### L39. 组合总和

**题目**：给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。



**思路1**：回溯。

```C++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtrack(candidates,target,0);
        return result;
    }
private:
    void backtrack(vector<int>& candidates, int target,int start){
        if(int sum=std::accumulate(path.begin(),path.end(),0);sum == target){
            result.push_back(path);
            return;
        }
        else if(sum>target){
            return;
        }
        for(int i=start;i<candidates.size();++i){
            path.push_back(candidates[i]);
            backtrack(candidates,target,i);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```





### L40. 组合总和 II

**题目**：给你一个由候选元素组成的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个元素在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。 



**思路1**：回溯。

这道题⽬和39.组合总和如下区别：
1. 本题candidates 中的每个数字在每个组合中只能使⽤⼀次。
2. 本题数组candidates的元素是有重复的，⽽39.组合总和是⽆重复元素的数组candidates
最后本题和39.组合总和要求⼀样，解集不能包含重复的组合。

本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合。

	所谓**去重**，其实就是使⽤过的元素不能重复选取。 组合问题可以抽象为树形结构，那么“使⽤过”在这个树形结构上是有两个维度的，⼀个维度是同⼀树枝上使⽤过，⼀个维度是同⼀树层上使⽤过。回看⼀下题⽬，元素在同⼀个组合内是可以重复的，但两个组合不能相同。所以我们要去重的是同⼀树层上的“使⽤过”，同⼀树枝上的都是⼀个组合⾥的元素，不⽤去重。
	
	为了实现树层的去重，需要对候选数组进行排序，使得两个相等的元素相邻。此外，还需要定义一个used数组用来判断同一层循环中某个元素是否已经使用过了。
	
	如何使用used数组？将某个元素添加到path的时候，将对应位置的used数组元素设置为true，表示该元素已经在路径中了。
	
	当 candidates[i] == candidates[i - 1] && used[i - 1] == false 时，表示当前遍历的元素和上一个元素相等，但是used[i - 1] == false表示candidates[i-1]不在路径上，这表明之前已经遍历过了这条路径，因此此时跳过该元素。

代码：

```C++
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        std::sort(candidates.begin(),candidates.end());
        used.resize(candidates.size());
        backtrack(candidates,target,0);
        return result;
    }
private:
    void backtrack(vector<int>& candidates, int target,int start){
        if(int sum=std::accumulate(path.begin(),path.end(),0);sum==target){
            result.push_back(path);
            return;
        }
        else if(sum>target){
            return;
        }
        for(int i=start;i<candidates.size();++i){
            // used[i - 1] == true，说明同⼀树⽀candidates[i - 1]使⽤过
			// used[i - 1] == false，说明同⼀树层candidates[i - 1]使⽤过
            if(i>0 && candidates[i-1]==candidates[i] &&
            used[i-1]==false)
                continue;
            path.push_back(candidates[i]);
            used[i]=true;
            backtrack(candidates,target,i+1);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> result;
    vector<int> path;
    vector<bool> used;
};
```





## 分割问题

### L131. 分割回文串

**题目**：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。



**思路1**：回溯。

列出如下⼏个难点：
切割问题可以抽象为组合问题
如何模拟那些切割线
切割问题中递归如何终⽌
在递归循环中如何截取⼦串
如何判断回⽂



1. 切割问题，有不同的切割⽅式
2. 判断回⽂

切割问题：切割⼀个a之后，在bcdef中再去切割第⼆段，切割b之后在cdef中在切割第三段.....。

**递归函数参数：**
全局变量数组path存放切割后回⽂的⼦串，⼆维数组result存放结果集。 （这两个参数可以放到函数参数⾥）。本题递归函数参数还需要startIndex，因为切割过的地⽅，不能重复切割，和组合问题也是保持⼀致的。

**递归函数终⽌条件**：切割线切到了字符串最后⾯，说明找到了⼀种切割⽅法，此时就是本层递
归的终⽌终⽌条件。

**单层搜索的逻辑**：在 for (int i = startIndex; i < s.size(); i++) 循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的⼦串。⾸先判断这个⼦串是不是回⽂，如果是回⽂，就加⼊在 vector<string> path 中，path⽤来记录切割过的回⽂⼦串。

```C++
class Solution {
public:
    vector<vector<string>> partition(string s) {
        backtrack(s,0);
        return result;
    }
private:
    bool judge(string &s){
        for(int i=0;i<s.size()/2;++i)
            if(s[i]!=s[s.size()-1-i])
                return false;
        return true;
    }
    void backtrack(string &s,int start){
        if(start>=s.size()){
            result.push_back(path);
            return;
        }
        for(int i=start;i<s.size();++i){
            string substr = s.substr(start,i-start+1);
            if(!judge(substr))
                continue;
            path.push_back(substr);
            backtrack(s,i+1);
            path.pop_back();
        }
    }
    vector<vector<string>> result;
    vector<string> path;
};
```







### L93. 复原IP地址

**题目**：有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。



**思路1**：回溯。

同L31类似，这是一个分割问题。

**回溯函数的参数**：定义一个全局变量result用来保存分割的结果，定义一个path变量来保存每个遍历树的树枝上的变量结果。由于是切割问题，因此定义一个start参数来收缩遍历的范围。

**终止条件**：当分割的段数为4时，停止回溯。当切割已经完成时，将path保存到result中。

**单层的遍历过程**：从start遍历到s字符串的末尾。若num.size()>1 && num[0]=='0'时，取消遍历；若std::stoi(num)>255时，取消遍历。

```C++
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        backtrack(s,0);
        return result;
    }
private:
    void backtrack(string &s,int start){
        if(path.size()==4){
            if(start>=s.size())
                result.push_back(path[0]+"."+path[1]+"."+path[2]+"."+path[3]);
            return;
        }
        for(int i=start;i<s.size();++i){
            string num = s.substr(start,i-start+1);
            if(num.size()>1 && num[0]=='0')
                break;
            if(std::stoi(num)>255)
                break;
            path.push_back(num);
            backtrack(s,i+1);
            path.pop_back();
        }
    }
    vector<string> path;
    vector<string> result;
};
```





## 子集问题

如果把 ⼦集问题、组合问题、分割问题都抽象为⼀棵树的话，那么组合问题和分割问题都是收集树的叶⼦节点，⽽⼦集问题是找树的所有节点！

那么既然是⽆序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，⽽不是从0开始！ 有同学问了，什么时候for可以从0开始呢？求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合。



### L78. 子集

**题目**：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。



**思路1**：回溯。

这道题其实就是一个组合问题。由于需要遍历所有的节点，因此在回溯函数里面首先将当前节点添加到result中。再执行遍历。

```C++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        backtrack(nums,0);
        return result;
    }
private:
    void backtrack(vector<int>& nums, int index){
        result.push_back(path);
        if(index>=nums.size())
            return;
        for(int i = index;i<nums.size();++i){
            path.push_back(nums[i]);
            backtrack(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```



### L491. 递增子序列

**题目**：给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。



**思路1**：回溯。

题目是一个求子集的问题，但是又要求不能重复。

⽽本题求⾃增⼦序列，是不能对原数组经⾏排序的，排完序的数组都是⾃增⼦序列了。因此不能像 L40 那样对数组进行排序来去重。

这里使用的去重方式是 通过**哈希集合**去重。

**递归函数参数：**本题求⼦序列，很明显⼀个元素不能重复使⽤，所以需要startIndex，调整下⼀层递归的起始位置。

**终⽌条件**：题⽬要求递增⼦序列⼤⼩⾄少为2，或start > nums.size().

```C++
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        used.resize(nums.size());
        backtrack(nums,0,INT_MIN);
        return result;
    }
private:
    void backtrack(vector<int>& nums,int start,int last){
        if(path.size()>=2)
            result.push_back(path);
        if(start>=nums.size())
            return;
        std::unordered_set<int> hash_set;//用于同一树层内去重
        for(int i=start;i<nums.size();++i){
            if(nums[i]<last)
                continue;
            if(hash_set.find(nums[i])!=hash_set.end())
                continue;
            hash_set.insert(nums[i]);
            path.push_back(nums[i]);
            backtrack(nums,i+1,nums[i]);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```





### L90. 子集II

**题目**：给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

示例 1：

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
示例 2：

输入：nums = [0]
输出：[[],[0]]


提示：

1 <= nums.length <= 10
-10 <= nums[i] <= 10



**思路1**：回溯。

这道题和 L78 的不同之处在于 本题给定的nums可能包含重复元素。

这里采用的去重方法是首先对nums进行排序，然后使用哈希集合对同一个树层内的数字去重。

**注意**：对于求子集来说，一定要先排序。因为集合{1,2}和{2,1}是相等的。若不排序，则可能会出现这类等价的子集。

代码：

```C++
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        std::sort(nums.begin(),nums.end());
        backtrack(nums,0);
        return result;
    }
private:
    void backtrack(vector<int>& nums,int start){
        result.push_back(path);
        if(start>=nums.size()){
            return;
        }
        std::unordered_set<int> hash_set;
        for(int i=start;i<nums.size();++i){
            if(hash_set.find(nums[i])!=hash_set.end()) continue;
            path.push_back(nums[i]);
            hash_set.insert(nums[i]);
            backtrack(nums,i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> result;
    vector<int> path;
};
```











## 排列问题





### L46. 全排列

**[题目](https://leetcode-cn.com/problems/permutations/)**：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

```
示例 1：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

示例 2：
输入：nums = [0,1]
输出：[[0,1],[1,0]]

示例 3：
输入：nums = [1]
输出：[[1]]
```


提示：

1 <= nums.length <= 6
-10 <= nums[i] <= 10
nums 中的所有整数 互不相同



**思路1**：回溯。

**递归函数参数**
⾸先排列是有序的，也就是说[1,2] 和[2,1] 是两个集合，这和之前分析的⼦集以及组合所不同的地⽅。可以看出元素1在[1,2]中已经使⽤过了，但是在[2,1]中还要在使⽤⼀次1，所以处理排列问题就不⽤使⽤startIndex了。
但排列问题需要⼀个used数组，标记已经选择的元素。

**递归终⽌条件**

可以看出叶⼦节点，就是收割结果的地⽅。当收集元素的数组path的⼤⼩达到和nums数组⼀样⼤的时候，说明找到了⼀个全排列，也表示到达了叶⼦节点。

**单层搜索的逻辑**
这⾥和组合问题、切割问题和⼦集问题最⼤的不同就是for循环⾥不⽤startIndex了。因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使⽤过了，但是在[2,1]中还要再使⽤⼀次1。 **⽽used数组，其实就是记录此时path⾥都有哪些元素使⽤了，⼀个排列⾥⼀个元素只能使⽤⼀次**。

排列问题的不同：
每层都是从0开始搜索⽽不是startIndex
需要used数组记录path⾥都放了哪些元素了

代码：

```C++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        used.resize(nums.size());
        backtrack(nums);
        return result;
    }
private:
    void backtrack(vector<int>& nums){
        if(path.size()==nums.size()){
            result.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();++i){
            if(used[i])continue;
            path.push_back(nums[i]);
            used[i]=true;
            backtrack(nums);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> result;
    vector<int> path;
    vector<bool> used;
};
```



### L47. 全排列II

**题目**：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。



**思路1**：回溯。哈希集合去重。

这道题和 L46 的不同之处在于 给定的nums可能含有重复的数字。这会导致回溯得到的数组会存在重复。重复的原因是 在同一个回溯函数的遍历中，遍历到两个重复的数字，最后会得到的重复的结果。

因此，这里的解决方法是使用哈希集合来防止在同一个循环内遍历重复的数字。

代码：

```C++
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        used.resize(nums.size());
        backtrack(nums);
        return result;
    }
private:
    void backtrack(vector<int>& nums){
        if(path.size() == nums.size()){
            result.push_back(path);
            return;
        }
        std::unordered_set<int> hash_set;
        for(int i=0;i<nums.size();++i){
            if(used[i])continue;
            if(hash_set.find(nums[i])!=hash_set.end()) continue;
            path.push_back(nums[i]);
            used[i]=true;
            hash_set.insert(nums[i]);
            backtrack(nums);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> result;
    vector<int> path;
    vector<bool> used;
};
```



**思路2**：回溯。排序去重。

这里首先对nums进行排序，然后根据used数组判断同一层内相同的数字是否被使用过。

`used[i-1]==false`意味着s[i-1]不在path中，此时若进行递归会导致得到重复的排列。

```C++
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        used.resize(nums.size());
        std::sort(nums.begin(),nums.end());
        backtrack(nums);
        return result;
    }
private:
    void backtrack(vector<int>& nums){
        if(path.size() == nums.size()){
            result.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();++i){
            if(used[i])continue;
            if(i>0 && nums[i]==nums[i-1] &&used[i-1]==false) continue;
            path.push_back(nums[i]);
            used[i]=true;
            backtrack(nums);
            path.pop_back();
            used[i]=false;
        }
    }
    vector<vector<int>> result;
    vector<int> path;
    vector<bool> used;
};
```





### J17. 打印从1到最大的n位数

**[题目](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)**：输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

```
示例 1:
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```


说明：

用返回一个整数列表来代替打印
n 为正整数



**思路1**：直接法。（不考虑大数）



**思路2**：字符串加法。

由于n可能会很大，超出任何数字的表示范围。因此需要用字符串表示数字，并实现字符串加法。



**思路3**：全排列。

​	如果我们在数字前面补0，就会发现n位所有十进制数其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到了所有的十进制数。只是在打印的时候，排在前面的0不打印出来罢了。全排列用递归很容易表达，数字的每一位都可能是0~9中的一个数，然后设置下一位。递归结束的条件是我们已经设置了数字的最后一位。

```C++
class Solution {
private:
    vector<string> numbers;
    string path;
    void backtrack(int n){
        if(path.size()==n){
            numbers.push_back(path);
            return;
        }
        for(char c='0';c<='9';++c){
            path.push_back(c);
            backtrack(n);
            path.pop_back();
        }
    }
public:
    vector<int> printNumbers(int n) {
        backtrack(n);
        vector<int> result(numbers.size());
        for(int i=0;i<numbers.size();++i)
            result[i]=std::stoi(numbers[i]);
        result.erase(result.begin());//第一个是0，不要
        return result;
    }
};
```







### J38. 字符串的排列

**[题目](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)**: 输入一个字符串，打印出该字符串中字符的所有排列。

 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

 ```
示例:
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
 ```


限制：

1 <= s 的长度 <= 8



**思路1**：回溯+哈希集合。

为了得到字符串的排列，需要用回溯算法。用哈希集合来去重。

```C++
class Solution {
private:
    std::unordered_set<string> hash_set;
    string path;
    vector<bool> used;
    
    void backtrack(string &s){
        if(path.size()==s.size()){
            hash_set.insert(path);
            return;
        }
        for(int i=0;i<s.size();++i){
            if(used[i])continue;
            path.push_back(s[i]);
            used[i]=true;
            backtrack(s);
            path.pop_back();
            used[i]=false;
        }
    }
public:
    vector<string> permutation(string s) {
        used = vector<bool>(s.size(),false);
        backtrack(s);
        return vector<string>(hash_set.begin(),hash_set.end());
    }
};
```



**思路2**：回溯+排序去重。

`used[i-1]==false`意味着s[i-1]不在path中，此时若进行递归会导致得到重复的排列。

```C++
class Solution {
private:
    vector<string> result;
    string path;
    vector<bool> used;
    void backtrack(string &s){
        if(path.size()==s.size()){
            result.push_back(path);
            return;
        }
        for(int i=0;i<s.size();++i){
            if(used[i])continue;
            if(i>0 && s[i]==s[i-1] && used[i-1]==false)continue;
            path.push_back(s[i]);
            used[i]=true;
            backtrack(s);
            path.pop_back();
            used[i]=false;
        }
    }
public:
    vector<string> permutation(string s) {
        std::sort(s.begin(),s.end());
        used = vector<bool>(s.size(),false);
        backtrack(s);
        return result;
    }
};
```

复杂度分析

时间复杂度：O(n×n!)，其中 n 为给定字符串的长度。这些字符的全部排列有 O(n!) 个，每个排列平均需要 O(n) 的时间来生成。

空间复杂度：O(n)。我们需要 O(n) 的栈空间进行回溯，注意返回值不计入空间复杂度。



**思路3**：下一个排列。

我们可以这样思考：当我们已知了当前的一个排列，我们能不能快速得到字典序中下一个更大的排列呢？

答案是肯定的，参见「31. 下一个排列的官方题解」，当我们已知了当前的一个排列，我们可以在 O(n) 的时间内计算出字典序下一个中更大的排列。这与 C++ 中的next_permutation 函数功能相同。

具体地，我们首先对给定的字符串中的字符进行排序，即可得到当前字符串的第一个排列，然后我们不断地计算当前字符串的字典序中下一个更大的排列，直到不存在更大的排列为止即可。

这个方案的优秀之处在于，我们得到的所有排列都不可能重复，这样我们就无需进行去重的操作。同时因为无需使用回溯法，没有栈的开销，算法时间复杂度的常数较小。

```C++
class Solution {
public:
    bool nextPermutation(string& s) {
        int i = s.size() - 2;
        while (i >= 0 && s[i] >= s[i + 1]) {
            i--;
        }
        if (i < 0) {
            return false;
        }
        int j = s.size() - 1;
        while (j >= 0 && s[i] >= s[j]) {
            j--;
        }
        swap(s[i], s[j]);
        reverse(s.begin() + i + 1, s.end());
        return true;
    }

    vector<string> permutation(string s) {
        vector<string> ret;
        sort(s.begin(), s.end());
        do {
            ret.push_back(s);
        } while (nextPermutation(s));
        return ret;
    }
};
```

复杂度分析

时间复杂度：O(n×n!)，其中 nn 为给定字符串的长度。我们需要 O(nlogn) 的时间得到第一个排列，nextPermutation 函数的时间复杂度为 O(n)，我们至多执行该函数 O(n!) 次，因此总时间复杂度为O(n×n!+nlogn)=O(n×n!)。

空间复杂度：O(1)。注意返回值不计入空间复杂度。









## 其它

### L332. 重新安排行程

**题目**：给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前。
假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。





### L51. N皇后

**[题目](https://leetcode-cn.com/problems/n-queens/)**：n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

不能相互攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。



**思路1**：回溯。

首先先将path初始化为棋盘的大小，并设置每个位置为 '.' 。

回溯参数：棋盘格大小n ，和回溯到的行序号row

停止条件：当row==n时，将棋盘格放入结果数组result

单层迭代：遍历第row行，从0到n。并判断每个位置是否满足N皇后的约束。

这个判断是否满足约束，需要判断同一列、45度、135度是否存在Q。

代码：

```C++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        path = std::vector<string>(n,string(n,'.'));//创建棋盘
        backward(n,0);
        return result;
    }
private:
    bool IsValid(int row,int col,int n){
        //判断同列是否已经存在了Q点
        for(int i=0;i<row;++i){
            if(path[i][col]=='Q')
                return false;
        }
        //判断正45度是否已经存在Q点
        for(int i=row,j=col;i>=0 && j>=0;--i,--j){
            if(path[i][j]=='Q')
                return false;
        }
        //判断135读是否存在Q点
        for(int i=row,j=col;i>=0 && j<n;--i,++j){
            if(path[i][j]=='Q')
                return false;
        }
        return true;
    }
    void backward(int n,int row){
        if(row>=n){
            result.push_back(path);
            return;
        }
        for(int col=0;col<n;++col){
            //判断是否和n皇后的条件冲突了
            if(!IsValid(row,col,n))continue;
            path[row][col]='Q';
            backward(n,row+1);
            path[row][col]='.';
        }
    }
    vector<vector<string>> result;
    vector<string> path;
};
```





### L52. N皇后II

**题目**：n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。



**思路1**：回溯。

解法类似于L51。不过输出的结果是方案的数量，而不是每个方案。

代码：

```C++
class Solution {
public:
    int totalNQueens(int n) {
        path = vector<vector<bool>>(n,vector<bool>(n,false));
        backtrack(n,0);
        return number;
    }
private:
    bool IsValid(int row,int col,int n){
        for(int i=0;i<row;++i)
            if(path[i][col])
                return false;
        for(int i=row,j=col;i>=0 && j>=0;--i,--j)
            if(path[i][j])
                return false;
        for(int i=row,j=col;i>=0 && j<n;--i,++j)
            if(path[i][j])
                return false;
        return true;
    }
    void backtrack(int n,int row){
        if(row==n){
            number++;
            return;
        }
        for(int i=0;i<n;++i){
            if(!IsValid(row,i,n))
                continue;
            path[row][i]=true;
            backtrack(n,row+1);
            path[row][i]=false;
        }
    }

    vector<vector<bool>> path;
    int number{0};
};
```














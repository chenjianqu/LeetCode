# 图



## 基础知识

图数据结构的表示方法大致分为四种，邻接矩阵、邻接表、十字链表、多重邻接表。

**邻接矩阵**是最容易理解的表示方法，优点是简单易懂，缺点是可能会占用很多存储空间，且没有任何意义，空间复杂度有向图是n^2，无向图是n(n-1)/2，因为无向图矩阵是对称的，只需要存储一半且不包含对角线即可。邻接矩阵的存储优化可以通过矩阵优化来实现（具体可以看矩阵的压缩方法）。

![]( [20191225132551846.jpg (999×2421) (csdnimg.cn)](https://img-blog.csdnimg.cn/20191225132551846.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pjZ183NDE0NTQ4OTc=,size_16,color_FFFFFF,t_70)

**邻接表**就是更加灵活，节省存储空间空间复杂度有向图是n+e，无向图是n+2e，但是表示起来复杂一些。邻接表还衍生出了一种逆邻接表，因为邻接表统计出度的效率较高，而入度需要遍历整个表才可以统计出来，而逆邻接表不需要遍历，直接就可以统计出每个结点的出度，这正好和邻接表相反。

**十字链表**是结合了邻接表和逆邻接表于一体的表示方法，用来表示有向图，综合了两种表示方法的优点，缺点是表示起来更加复杂。

**多重邻接表**是类似于十字链表的表示方法，用来表示无向图，当一个无向图需要频繁的修改时，邻接表表示法需要修改边两侧的结点对应的信息，而多重邻接表可以只修改一次，计算量节省了一半。







## 题目



### L200. 岛屿数量

**[题目](https://leetcode-cn.com/problems/number-of-islands/)**：给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 ```
示例 1：
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

示例 2：
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
 ```


提示：

m == grid.length
n == grid[i].length
1 <= m, n <= 300
`grid[i][j]` 的值为 '0' 或 '1'



**思路1**：深度优先搜索。

我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。

最终岛屿的数量就是我们进行深度优先搜索的次数。

```C++
class Solution {
private:
    void dfs(vector<vector<char>>& grid, int r, int c) {
        int nr = grid.size();
        int nc = grid[0].size();

        grid[r][c] = '0';
        if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);
        if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);
        if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);
        if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();

        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    dfs(grid, r, c);
                }
            }
        }

        return num_islands;
    }
};
```



**思路2**：广度优先搜索。

同样地，我们也可以使用广度优先搜索代替深度优先搜索。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。直到队列为空，搜索结束。

最终岛屿的数量就是我们进行广度优先搜索的次数。

```C++
int numIslands(vector<vector<char>>& grid) {
    int nr = grid.size();
    if (!nr) return 0;
    int nc = grid[0].size();

    int num_islands = 0;
    for (int r = 0; r < nr; ++r) {
        for (int c = 0; c < nc; ++c) {
            if (grid[r][c] == '1') {
                ++num_islands;
                grid[r][c] = '0';
                queue<pair<int, int>> neighbors;
                neighbors.push({r, c});
                while (!neighbors.empty()) {
                    auto rc = neighbors.front();
                    neighbors.pop();
                    int row = rc.first, col = rc.second;
                    if (row - 1 >= 0 && grid[row-1][col] == '1') {
                        neighbors.push({row-1, col});
                        grid[row-1][col] = '0';
                    }
                    if (row + 1 < nr && grid[row+1][col] == '1') {
                        neighbors.push({row+1, col});
                        grid[row+1][col] = '0';
                    }
                    if (col - 1 >= 0 && grid[row][col-1] == '1') {
                        neighbors.push({row, col-1});
                        grid[row][col-1] = '0';
                    }
                    if (col + 1 < nc && grid[row][col+1] == '1') {
                        neighbors.push({row, col+1});
                        grid[row][col+1] = '0';
                    }
                }
            }
        }
    }

    return num_islands;
}
```



**思路3**：并查集。



### L79. 单词搜索

[题目](https://leetcode-cn.com/problems/word-search/) 同 J12

### J12. 矩阵中的路径

**[题目](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)**：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

```
示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

示例 2：
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

提示：

    1 <= board.length <= 200
    1 <= board[i].length <= 200
    board 和 word 仅由大小写英文字母组成



**思路1**：深度优先搜索。

 	递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。

​	终止条件：
​        返回 false： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。
​        返回 true ： k = len(word) - 1 ，即字符串 word 已全部匹配。
​    递推工作：
​        标记当前矩阵元素： 将 `board[i][j]` 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问。
​        搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。
​        还原当前矩阵元素： 将 `board[i][j]` 元素还原至初始值，即`word[k]` 。
​    返回值： 返回布尔量 res ，代表是否搜索到目标字符串。
​	使用空字符‘ ’做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。



```C++
bool dfs(vector<vector<char>>& board, string& word,int row,int col,int k){
    if(k==word.size()) return true;
    int rows = board.size();
    int cols = board[0].size();
    if(row!=0 && board[row-1][col]==word[k]){
        board[row-1][col]=' ';
        if(dfs(board,word,row-1,col,k+1))return true;
        board[row-1][col]=word[k];
    }
    if(col!=0 && board[row][col-1]==word[k]){
        board[row][col-1]=' ';
        if(dfs(board,word,row,col-1,k+1))return true;
        board[row][col-1]=word[k];
    }
    if(row!=rows-1 && board[row+1][col]==word[k]){
        board[row+1][col]=' ';
        if(dfs(board,word,row+1,col,k+1)) return true;;
        board[row+1][col]=word[k];
    }
    if(col!=cols-1 && board[row][col+1]==word[k]){
        board[row][col+1]=' ';
        if(dfs(board,word,row,col+1,k+1)) return true;
        board[row][col+1]=word[k];
    }
    return false;
}

bool exist(vector<vector<char>>& board, string word) {
    if(board.size()==1 && board[0].size()==1){
        if(word.size()==1 && board[0][0]==word[0]) 
            return true;
        else 
            return false;
    }
    for(int i=0;i<board.size();++i){
        for(int j=0;j<board[0].size();++j){
            if(dfs(board,word,i,j,0))
                return true;
        }
    }
    return false;
}
```



代码简化版本：

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        rows = board.size();
        cols = board[0].size();
        for(int i = 0; i < rows; i++) 
            for(int j = 0; j < cols; j++) 
                if(dfs(board, word, i, j, 0)) 
                    return true;
        return false;
    }
private:
    int rows, cols;
    bool dfs(vector<vector<char>>& board, string word, int i, int j, int k) {
        if(i >= rows || i < 0 || j >= cols || j < 0 || board[i][j] != word[k]) return false;
        if(k == word.size() - 1) return true;
        board[i][j] = '\0';
        bool res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    }
};

```







### L207. 课程表

**[题目](https://leetcode-cn.com/problems/course-schedule/)**：给你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

```
示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。

示例 2：
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```


提示：

1 <= numCourses <= 10^5
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses
prerequisites[i] 中的所有课程对 互不相同



### L210. 课程表II

**[题目](https://leetcode-cn.com/problems/course-schedule-ii/)**：给现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。

例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。

```
示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。

示例 2：
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。

示例 3：
输入：numCourses = 1, prerequisites = []
输出：[0]
```

提示：
1 <= numCourses <= 2000
0 <= prerequisites.length <= numCourses * (numCourses - 1)
prerequisites[i].length == 2
0 <= ai, bi < numCourses
ai != bi
所有[ai, bi] 互不相同



# 并查集

## 基础知识



## 题目



### L1319. 连通网络的操作次数

**[题目](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/ )**：用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。

网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。

给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 

```
示例 1：
输入：n = 4, connections = [[0,1],[0,2],[1,2]]
输出：1
解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。
```

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png)

 ```
示例 2：
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
输出：2

示例 3：
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
输出：-1
解释：线缆数量不足。

示例 4：
输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]
输出：0
 ```


提示：

```
1 <= n <= 10^5
1 <= connections.length <= min(n*(n-1)/2, 10^5)
connections[i].length == 2
0 <= connections[i][0], connections[i][1] < n
connections[i][0] != connections[i][1]
没有重复的连接。
两台计算机不会通过多条线缆连接。
```



**分析**：

我们首先考虑在什么情况下，不可能将所有计算机进行连接。

当计算机的数量为 n 时，我们至少需要 n−1 根线才能将它们进行连接。如果线的数量少于 n−1，那么我们无论如何都无法将这 n 台计算机进行连接。因此如果数组$ \textit{connections}$ 的长度小于 n−1，我们可以直接返回 −1 作为答案，否则我们一定可以找到一种操作方式。

那么如何计算最少的操作次数呢？我们将这 n 台计算机看成 n 个节点，每一条线看成一条无向边。假设这个无向图中有 k 个「连通分量」，**连通分量**的定义为：

> 设集合 V 为无向图中节点的一个子集，集合 E 为无向图中所有两个端点都在 V 中的边。设图 S=(V,E)，那么 S 就称为无向图的一个「诱导子图」（或者叫「导出子图」）。「连通分量」是极大的「诱导子图」，这里的「极大」表现在：
> V 中的任意两个节点仅通过 E 就可以相互到达；
> 不存在一个不属于 V 的节点 x，使得 x 与 V 中的某个节点直接相连。
>   我们可以通过节点集合 V 唯一地描述一个连通分量：例如在题目给出的样例 1 中，有两个连通分量 {0,1,2} 和 {3}；样例 2 中，有三个连通分量 {0,1,2,3}，{4} 和 {5}。

如果我们的操作是「添加一根线」而不是「移动一根线」，那么显然只需要添加 k−1 根线就可以将所有计算机进行连接了：例如将编号为 0 的连通分量中的任意一台计算机分别与编号为 1,2,⋯,k−1 的连通分量中的任意一台计算机相连。由于「移动一根线」的操作一定不会优于「添加一根线」，那么我们至少需要移动 k−1 根线，才有可能将所有计算机连接。

那么我们是否可以找到一种移动 k−1 根线的操作方法呢？我们可以发现，m台电脑只需要 m−1 根线就可以将它们进行连接。如果一个节点数为 m 的连通分量中的边数超过 m−1，就一定可以找到一条多余的边，且移除这条边之后，连通性保持不变。此时，我们就可以用这条边来连接两个连通分量，使得图中连通分量的个数减少 1。

>在题目给出的样例 2 中，连通分量 {0,1,2,3} 中有 5 条边，大于 m−1=3。因此一定可以找到一条多余的边。具体地，该连通分量中的任意一条边被移除后，连通性都保持不变。
注意：并不是在所有的情况下，连通分量中的任意一条边都是可以被移除的，我们只需要保证必定能够找到「一条」多余的边。

因此我们可以设计一个迭代的过程：每次在图中找出一条多余的边，将其断开，并连接图中的两个连通分量。将这个过程重复 k−1 次，最终就可以使得整个图连通。

我们如何保证一定能找出「一条」多余的边呢？我们需要证明的是，在任意时刻，如果图中有 k' 个连通分量且 k'>1，即整个图还没有完全连通，那么一定存在一个连通分量，使得其有一条多余的边：即它的节点数为 $m_i$ ，边数为 $e_i$ ，并且有 $e_i > m_i - 1$。

>
我们可以使用反证法来证明上面的结论。假设所有的连通分量都满足 $e_i \leq m_i - 1$，那么：
$$
\begin{cases} e_1 \leq m_1 - 1 \\ e_2 \leq m_2 - 1 \\ \cdots \\ e_{k'} \leq m_{k'} - 1 \end{cases}
$$
> 将这k'个不等式相加可以得到：

$$
e_1 + \cdots + e_{k'} \leq m_1 + \cdots + m_{k'} - k' = n - k'
$$
> 左侧的 $e_1 + \cdots + e_{k'}$ ,  即为图中的边数，右侧的 $m_1 + ... + m_{k'} = n$ 即为图中的节点数。由于图中至少有 n-1 条边，那么有：

$$
e_1 + \cdots + e_{k'} \geq n - 1
$$
> 与

$$
e_1 + \cdots + e_{k'} \leq n - k'
$$
> 产生了矛盾！因此一定存在一个连通分量，它有一条多余的边。

统计图中连通分量数的方法有很多，本篇题解中我们给出深度优先搜索和并查集两种方法。



**思路1**：深度优先搜索

我们可以使用深度优先搜索来得到图中的连通分量数。

具体地，初始时所有节点的状态均为「待搜索」。我们每次选择一个「待搜索」的节点，从该节点开始进行深度优先搜索，并将所有搜索到的节点的状态更改为「已搜索」，这样我们就找到了一个连通分量。

```C++
class Solution {
private:
    vector<vector<int>> edges;
    vector<int> used;

public:
    void dfs(int u) {
        used[u] = true;
        for (int v: edges[u]) {
            if (!used[v]) {
                dfs(v);
            }
        }
    }
    
    int makeConnected(int n, vector<vector<int>>& connections) {
        if (connections.size() < n - 1) {
            return -1;
        }
		//构建图
        edges.resize(n);
        for (const auto& conn: connections) {
            edges[conn[0]].push_back(conn[1]);
            edges[conn[1]].push_back(conn[0]);
        }
        //深度优先搜索
        used.resize(n);
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (!used[i]) {
                dfs(i);
                ++ans;
            }
        }
        
        return ans - 1;
    }
};
```

时间复杂度：O(n+m)，其中 m 是数组 connections 的长度。

空间复杂度：O(n+m)，其中 O(m) 为存储所有边需要的空间，O(n) 为深度优先搜索中使用的栈空间。



**思路2**：并查集。

我们可以使用并查集来得到图中的连通分量数。

并查集本身就是用来维护连通性的数据结构。如果其包含 n 个节点，那么初始时连通分量数为 n，每成功进行一次合并操作，连通分量数就会减少 1。

```C++
// 并查集模板
class UnionFind {
public:
    vector<int> parent;
    vector<int> size;
    int n;//节点数量
    int setCount;// 当前连通分量数目
    
public:
    UnionFind(int _n): 
            n(_n), 
            setCount(_n), 
            parent(_n), 
            size(_n, 1) {//将所有的子图大小初始化为1
        iota(parent.begin(), parent.end(), 0);
    }
    
    int findset(int x) {
        //路径压缩
        return parent[x] == x ? x : parent[x] = findset(parent[x]);
    }
    
    bool unite(int x, int y) {
        x = findset(x);
        y = findset(y);
        if (x == y) {
            return false;
        }
        //x和y未连通
        //下面将 小子图 连接到 大子图
        if (size[x] < size[y]) 
            swap(x, y);
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }
    
    bool connected(int x, int y) {
        x = findset(x);
        y = findset(y);
        return x == y;
    }
};

class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        if (connections.size() < n - 1) {
            return -1;
        }

        UnionFind uf(n);
        for (const auto& conn: connections) {
            uf.unite(conn[0], conn[1]);
        }

        return uf.setCount - 1;
    }
};
```





### L684. 冗余连接

**[题目]( [684. 冗余连接 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/redundant-connection/) )**：树可以看成是一个连通且 无环 的 无向 图。

给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。

示例 1：

![](https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png)

输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]
示例 2：

![](https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png)

输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]

**提示**:

> n == edges.length
> 3 <= n <= 1000
> edges[i].length == 2
> 1 <= ai < bi <= edges.length
> ai != bi
> edges 中无重复元素
> 给定的图是连通的 



**思路1**：并查集。

将输入到边构建并查集，当边的两个节点在并查集中已经连接时，返回该边即可。

```C++
class Solution {
private:
    vector<int> size;
    vector<int> connection;
    int find(int x){
        if(x==connection[x])
            return x;
        else{
            connection[x] = find(connection[x]);
            return connection[x];
        }
    }
    //返回值：false:已连接，true：未连接。
    bool unite(int x,int y){
        x = find(x);
        y = find(y);
        if(x==y)
            return false;
        //连接
        if(size[x]<size[y])
            std::swap(x,y);
        connection[y] = x;
        size[x] += size[y];

        return true;
    }

public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int N=edges.size();
        ///初始化
        size.resize(N+1,1);
        connection.resize(N+1);
        std::iota(connection.begin(),connection.end(),0);

        for(auto &e : edges){
            if(! unite(e[0],e[1])){
                return e;
            }
        }
        return {};
    }
};
```



**思路2**：深度优先搜索。
































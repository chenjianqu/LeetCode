**哈希表**
**链表**





# 1.数组

## 常见算法

### 双指针



## 数组的生成

### J17. 打印从1到最大的n位数

**[题目](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)**：输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

```
示例 1:

输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```


说明：

用返回一个整数列表来代替打印
n 为正整数



**思路1**：简单法：不考虑大数问题。

```
vector<int> printNumbers(int n) {
int max=std::pow(10,n)-1;
vector<int> arr(max);
std::iota(arr.begin(),arr.end(),1);
return arr;
}
```



**思路2**：当n很大时，会超出32位，此时需要考虑大数问题。







## 数组的查找和计算



### J03. 数组中重复的数字

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)**:找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 



```

限制：

2 <= n <= 100000



**思路1**：暴力法。先排序，后遍历。

简单粗暴，时间复杂度为O(nlogn)。

```c++
int findRepeatNumber(vector<int>& nums) {
    std::sort(nums.begin(),nums.end());
    for(int i=0;i<nums.size()-1;++i)
	    if(nums[i]==nums[i+1])
	    	return nums[i];
    return nums[0];
}
```



**思路2**：普通的哈希表。



**思路3**：原地交换。

题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。
因此，可遍历数组并通过交换操作，使**元素的 索引 与 值 一一对应**（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。

遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x] = x，此时即可得到一组重复数字。

```C++
int findRepeatNumber(vector<int>& nums) {
    for(int i=0;i<nums.size();++i){
        int n=nums[i];
        if(i!=n && nums[n]==n) 
            return n;
        else
            std::swap(nums[i],nums[n]);
    }
    return nums[0];
}
```



### J03 II. 数组中重复的数字∶不修改数组

**题目**：在一个长度为n+1的数组里的所有数字都在1～n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2， 3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。

**思路1**：哈希表。时间复杂度O(n)，空间复杂度O(n)



**思路2**：二分查找的思路。时间复杂度O(nlogn)，空间复杂度O(1)





### L2022. 将一维数组转变成二维数组

**题目**:
给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有
元素创建一个 m 行 n 列的二维数组。  
original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都
包含 ）的元素构成二维数组的第二行，依此类推。
请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。

**代码：**

```C++
    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
        if(original.size() != m*n)
            return vector<vector<int>>();
        vector<vector<int>> arr(m);
        for(int i=0;i<original.size();i+=n ){
                vector<int> row(n);
            for(int j=0;j<n;++j){
                row[j] = original[i+j];
            }
            arr[static_cast<int>(i/n)]=row;
        }
        return arr;
    }
```



### L136. 只出现一次的数字

**题目**:题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。  
说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**思路1**：使用哈希表对数组元素进行计数，最后遍历哈希表，找到计数为1的数。

```C++
int singleNumber(vector<int>& nums) {
    std::unordered_map<int,int> d;
    for(int i=0;i<nums.size();++i){
        if(d.find(nums[i])==d.end())
            d.insert({nums[i],1});
        else
            d[nums[i]]++;
    }
    for(auto [num,count] : d) if(count==1) return num;
    return 0;
}
```

**思路2**：使用异或运算。
  如何才能做到线性时间复杂度和常数空间复杂度呢？答案是使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。  
任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。   
任何数和其自身做异或运算，结果是 0，即 a⊕a=0。   
异或运算满足交换律和结合律，即 a⊕b⊕a = b⊕a⊕a = b⊕(a⊕a) = b⊕0=b。  
 因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。  

```C++
int singleNumber1(vector<int>& nums) {
        int result =0;
        for(int i=0;i<nums.size();++i)
            result ^= nums[i];
        return result;
}
```

### L169. 多数元素

**题目**：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。  
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**思路1**：采用哈希表（简单粗暴）

```C++
int majorityElement(vector<int>& nums) {
std::unordered_map<int,int> d;
for(int i=0;i<nums.size();++i){
    if(d.find(nums[i])==d.end())
	d.insert({nums[i],1});
    else
	d[nums[i]]++;
}
for(auto [num,count]:d){
    if(count>std::floor(nums.size()/2))
	return num;
}
return 0;
}
```

**思路2**：先排序，排序后数组的中间值肯定是众数。

**思路3**：分治算法。
如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。  
我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l / 2 + r / 2 次，
其中 l 和 r 分别是左半部分和右半部分的长度。由于 l / 2 + r / 2 <= (l + r) / 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。  
这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。  

**思路4**：Boyer-Moore 投票算法
Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：  
我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；  
我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：  
如果 x 与 candidate 相等，那么计数器 count 的值增加 1；  
如果 x 与 candidate 不等，那么计数器 count 的值减少 1。  
在遍历完成后，candidate 即为整个数组的众数。

```
int majorityElement(vector<int>& nums) {
int candidate = -1;
int count = 0;
for (int num : nums) {
    if (num == candidate)
	++count;
    else if (--count < 0) {
	candidate = num;
	count = 1;
    }
}
return candidate;
}
```





### L1. 两数之和

**题目**：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，
并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。  

**思路1**：遍历。  

```C++
vector<int> twoSum(vector<int>& nums, int target) {
    for(int i=0;i<nums.size();++i)
        for(int j=i+1;j<nums.size();++j)
            if(nums[i]+nums[j]==target)
                return vector<int>{i,j};
    return vector<int>{0,1};
}
```

**思路2**:哈希表。记录遍历过的值到哈希表。

```C++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int,int> d;
    for(int i=0;i<nums.size();++i){
        if(d.find(target-nums[i])!=d.end())
            return vector<int>{i,d[target-nums[i]]};
        if(d.find(nums[i])==d.end())
            d.insert({nums[i],i});
    }
    return vector<int>{0,1};
}
```



### L167. 两数之和 II - 输入有序数组

**题目**：给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

**思路1**：由于给定的是一个排序好的数组，则直接双指针。

```C++
vector<int> twoSum(vector<int>& numbers, int target) {
    for(int i=0,j=numbers.size()-1;i<j;){
        while(i<j && numbers[i]+numbers[j]>target)
            --j;
        if(numbers[i]+numbers[j] == target)
            return vector<int>{i+1,j+1};
        while(i<j && numbers[i]+numbers[j]<target)
            ++i;
    }
    return vector<int>();
}
```



**思路2**：二分查找。对于遍历每个元素numbers[i]，使用二分查找target - numbers[i]即可。时间复杂度为nlogn。





### L15. 三数之和

**题目**：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？
请你找出所有和为 0 且不重复的三元组。  
注意：答案中不可以包含重复的三元组。  

**思路1**:遍历法，双重循环，外层单指针，内双指针。时间复杂度O(n^2)  

```C++
int Partition(vector<int> &arr,int low,int high){
    int key=arr[low];
    while(low<high){
        while(low<high && arr[high]>=key)
            high--;
        arr[low]=arr[high];
        while(low<high && arr[low]<=key)
            low++;
        arr[high]=arr[low];
    }
    arr[low]=key;
    return low;
}
void QSort(vector<int> &arr,int low,int high){
    if(low < high){
        int parting = Partition(arr,low,high);
        QSort(arr,low,parting-1);
        QSort(arr,parting+1,high);
    }
}

vector<vector<int>> threeSum(vector<int>& nums) {
    const int n = nums.size();
    vector<vector<int>> output;
    //先排序
    QSort(nums,0,nums.size()-1);
    //外层单指针，内层双指针
    for (int first = 0; first < n; ++first) {
        if (first > 0 && nums[first] == nums[first - 1])  // 需要和上一次枚举的数不相同
            continue;
        int third = n - 1;// c 对应的指针初始指向数组的最右端
        int target = -nums[first];
        for (int second = first + 1; second < n; ++second) {
            if (second > first + 1 && nums[second] == nums[second - 1]) // 需要和上一次枚举的数不相同
                continue;
            while (second < third && nums[second] + nums[third] > target)  // 需要保证 b 的指针在 c 的指针的左侧
                --third;
            if (second == third)
                break;
            if (nums[second] + nums[third] == target)
                output.push_back({nums[first], nums[second], nums[third]});
        }
    }
    return output;
}
```


### L16. 最接近的三数之和

**题目**：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，
使它们的和与 target 最接近。 返回这三个数的和。  
假定每组输入只存在恰好一个解。

**思路1**: 直接暴力解法的时间复杂度时O(n^3)。同上一题一样，内层循环可以用双指针降低复杂度。  
为了使用双指针，需要首先对数组进行排序，复杂度为O(nlogn)。与上一题不同的是，不需要考虑重复的3元组。

```C++
int threeSumClosest(vector<int>& nums, int target) {
    std::sort(nums.begin(),nums.end());
    int closest_sum=0;
    int delta = INT_MAX;
    for(int i=0;i<nums.size();++i){
        int j=i+1,k=nums.size()-1;
        while(j<k){
            int sum = nums[i]+nums[j]+nums[k];
            if(std::abs(target-sum)<delta){
                delta = std::abs(target-sum);
                closest_sum = sum;
                if(delta==0)break;
            }
            if(sum<=target)
                j++;
            else if(sum>target)
                k--;
        }
    }
    return closest_sum;
}
```





### L18. 四数之和

**题目**：
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] 
（若两个四元组元素一一对应，则认为两个四元组重复）：  

* 0 <= a, b, c, d < n
* a、b、c 和 d 互不相同
* nums[a] + nums[b] + nums[c] + nums[d] == target
  你可以按 任意顺序 返回答案 。

**思路1**: 与L16差不多，外层是两个暴力双循环，内层是一个双指针。为了去掉重复的4元组，这里通过
集合set来保存结果。注意，本题还要考虑数据范围的问题。

```C++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> arr;
    if(nums.size()<4)
        return arr;
    std::set<vector<int>> num_set;
    //排序
    std::sort(nums.begin(),nums.end());
    //内外层双指针
    int n = nums.size();
    for(int i=0;i<n;++i){
        for(int j=i+1;j<n;++j){
            int k=j+1,l= n-1;
            while(k<l){
                int64_t sum = static_cast<int64_t>(nums[i])+static_cast<int64_t>(nums[j])+
                        static_cast<int64_t>(nums[k])+static_cast<int64_t>(nums[l]);
                if(sum==target){
                    num_set.insert({nums[i],nums[j],nums[k],nums[l]});
                    k++;
                }
                else if(sum>target) l--;
                else k++;
            }
        }
    }

    for(auto &v : num_set)
        arr.push_back(v);
    return arr;
}

```





### L724. 寻找数组的中心下标

**题目**：给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

**思路1**：暴力解法。从左到右遍历每一个可能的中心下标，计算左右两边的和，并判断两边是否相等。

```C++
int pivotIndex(vector<int>& nums) {
    int left_sum=0;
    int right_sum=0;
    for(int j=1;j<nums.size();++j) right_sum+=nums[j];//算法中心下标在0处的情况
    if(right_sum==0) return 0;

    for(int i=0;i<nums.size()-1;++i){
        left_sum+=nums[i];
        right_sum=0;
        for(int j=i+2;j<nums.size();++j) right_sum+=nums[j];
        if(left_sum==right_sum)
            return i+1;
    }
    return -1;
}
```

**思路2**：单层循环。只需要遍历一边中心下标即可，每次迭代时，更新左边的和，右边的和。

```C++
int pivotIndex(vector<int>& nums) {
    int left_sum=0;
    int right_sum=std::accumulate(nums.begin()+1,nums.end(),0);
    for(int i=0;i<nums.size();++i){
        if(left_sum == right_sum) return i;
        if(i==nums.size()-1) break;
        left_sum+=nums[i];
        right_sum -=nums[i+1];
    }
    return -1;
}
```



## 数组的合并和拆分



### J21. 调整数组顺序使奇数位于偶数前面

**[题目](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)**:  输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

 ```
示例：

输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
 ```


提示：

0 <= nums.length <= 50000
0 <= nums[i] <= 10000



**思路1**：首尾双指针，额外数组。

```C++
vector<int> exchange(vector<int>& nums) {
    vector<int> arr(nums.size());
    int index_o=0,index_e=nums.size()-1;
    for(int i=0;i<nums.size();++i){
        if(nums[i]%2==1){
            arr[index_o]=nums[i];
            index_o++;
        }
        else{
            arr[index_e]=nums[i];
            index_e--;
        }
    }
    return arr;
}
```



**思路2**：首尾双指针，原地交换。

```C++
vector<int> exchange(vector<int>& nums) {
    int left=0,right=nums.size()-1;
    while(left<right){
        while(left<right && nums[left]%2==1)left++;
        while(left<right && nums[right]%2==0)right--;
        std::swap(nums[left],nums[right]);
        left++;
        right--;
    }
    return nums;
}
```



**思路3**：快慢双指针。

定义快慢双指针 fast 和 low ，fast 在前， low 在后 .
fast的作用是向前搜索奇数位置，low 的作用是指向下一个奇数应当存放的位置
fast 向前移动，当它搜索到奇数时，将它和 nums[low] 交换，此时 low 向前移动一个位置 .
重复上述操作，直到 fast 指向数组末尾 .

```C++
vector<int> exchange(vector<int>& nums) {
    int low = 0, fast = 0;
    while (fast < nums.size()) {
        if (nums[fast] & 1) {
            swap(nums[low], nums[fast]);
            low ++;
        }
        fast ++;
    }
    return nums;
}
```







### L349. 两个数组的交集

**题目**: 给定两个数组，编写一个函数来计算它们的交集。 

说明：

- 输出结果中的每个元素一定是唯一的。
- 我们可以不考虑输出结果的顺序。

**思路1**：使用两个哈希集合，第一个哈希集合存放第一个数组的元素，第二个哈希集合存放 交集元素。最后再把第二个哈希集合转移到输出数组中。

```C++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    std::unordered_set<int> hash_set,out_set;
    std::vector<int> arr;
    for(int i=0;i<nums1.size();++i)
        hash_set.insert(nums1[i]);
    for(int i=0;i<nums2.size();++i)
        if(hash_set.count(nums2[i])>0)
            out_set.insert(nums2[i]);
    for(auto e:out_set) arr.push_back(e);
    return arr;
}
```

**思路2**： 排序+双指针。首先对两个数组进行排序，然后分别对两个数组设置一个指针，用于指向正在比较的数组的元素。对于每个指针，还需要判断去掉重复的元素。

```C++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    std::sort(nums1.begin(),nums1.end());
    std::sort(nums2.begin(),nums2.end());
    vector<int> arr;
    for(int i=0,j=0;i<nums1.size()&&j<nums2.size();){
        if(i>0 && nums1[i]==nums1[i-1]){
            ++i;
            continue;
        }
        if(j>0 && nums2[j]==nums2[j-1]){
            ++j;
            continue;
        }
        if(nums1[i]==nums2[j]){
            arr.push_back(nums1[i]);
            ++i;
            ++j;
        }
        else if(nums1[i]<nums2[j]){
            ++i;
        }
        else{
            ++j;
        }
    }
    return arr;
}
```





### L56. 合并区间

**题目**：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**思路1**：暴力法，双重循环比较两个之间是否重叠。该方法会“超出时间限制”。

**思路2**：（这道题第9次提交才对）首先对输入的区间数组进行排序，则重叠的区间肯定相邻。遍历一遍，对相邻重叠区间进行合并。当第i个区间与i+1个区间不相邻时，将第i个区间添加到输出数组。

```C++
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    int n=intervals.size();
    if(n==1)
        return vector<vector<int>>{intervals[0]};
    std::sort(intervals.begin(),intervals.end());
    vector<vector<int>> output;
    for(int i=0;i<intervals.size()-1;++i){
        if(intervals[i][1]>=intervals[i+1][0]){//i和i+1重叠
            intervals[i+1][0] = intervals[i][0];
            intervals[i+1][1] = std::max(intervals[i][1],intervals[i+1][1]);
        }else{
            output.push_back(intervals[i]);
        }
    }
    if(intervals[n-2][1]>=intervals[n-1][0]){//n-1和n-2重叠
        intervals[n-1][0] = intervals[n-2][0];
        intervals[n-1][1] = std::max(intervals[n-2][1],intervals[n-1][1]);
    }
    output.push_back(intervals[n-1]);
    return output;
}
```









### L561. 数组拆分I

给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。

返回该 最大总和 。

```
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```



**思路1**：首先进行排序，得到升序数组，0-1,2-3, 4-5 ...划分为一组。因此结果为第0个、第2个、第4个...元素的和。

```C++
int arrayPairSum(vector<int>& nums) {
    std::sort(nums.begin(),nums.end());
    int sum=0;
    for(int i=0;i<nums.size();i+=2)
        sum+=nums[i];
    return sum;
}
```





## 矩阵的搜索

### J04. 二维数组中的查找

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)**: 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 ```
示例:
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
 ```

限制：

0 <= n <= 1000

0 <= m <= 1000



**思路1**：暴力法。

遍历二维数组，时间复杂度O(n*m)



**思路2**：线性查找法。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。

若数组为空，返回 false
初始化行下标为 0，列下标为二维数组的列数减 1
重复下列步骤，直到行下标或列下标超出边界
获得当前下标位置的元素 num
如果 num 和 target 相等，返回 true
如果 num 大于 target，列下标减 1
如果 num 小于 target，行下标加 1
循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false

```C++
bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
    if(matrix.empty()) return false;
    for(int i=0,j=matrix[0].size()-1;i<matrix.size() && j>=0;){
        if(matrix[i][j]==target)
            return true;
        else if(matrix[i][j]<target)
            ++i;
        else if(matrix[i][j]>target)
            --j;
    }
    return false;
}
```





### L54. 螺旋矩阵

**[题目](https://leetcode-cn.com/problems/spiral-matrix/)**：给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 ```
示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
 ```

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
示例 2：
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

提示：

```
m == matrix.length
n == matrix[i].length
1 <= m, n <= 10
-100 <= matrix[i][j] <= 100
```



**思路1**：观察法。

观察下面的例子：

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

可知，打印的顺序为：

1 2 3 4

8 12

11 10 9

5

6 7

设矩阵的宽为cols, 高为rows，则每一圈，各步骤打印的长度为：

cols

rows-1

cols-1

rows-2

根据这个规律，得到的代码如下：

```C++
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    int rows=matrix.size(),cols=matrix[0].size();
    int size = rows*cols;
    vector<int> arr;
    int r=0,c=0;//（r,c）表示每一步的起点
    rows--;
    while(true){
        //printf("r:%d c:%d rows:%d cols:%d\n",r,c,rows,cols);
        for(int i=0;i<cols;++i)arr.push_back(matrix[r][c+i]);
        c+= cols-1;
        r++;
        cols--;
        if(arr.size()==size)break;

        for(int i=0;i<rows;++i)arr.push_back(matrix[r+i][c]);
        c--;
        r += rows-1;
        rows--;
        if(arr.size()==size)break;

        for(int i=0;i<cols;++i)arr.push_back(matrix[r][c-i]);
        c -= (cols-1);
        r--;
        cols--;
        if(arr.size()==size)break;

        for(int i=0;i<rows;++i)arr.push_back(matrix[r-i][c]);
        c++;
        r -= (rows-1);
        rows--;
        if(arr.size()==size)break;
    }
    return arr;
}
```



**思路2**：模拟螺旋矩阵的路径。

可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。

判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 \textit{visited}visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 \textit{visited}visited 中的对应位置的元素设为已访问。

如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

```C++
class Solution {
private:
    static constexpr int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0)
            return {};
        int rows = matrix.size(), columns = matrix[0].size();
        //辅助数组，标志是否访问过该元素
        vector<vector<bool>> visited(rows, vector<bool>(columns));
        int total = rows * columns;
        vector<int> order(total);
        int row = 0, column = 0;
        int directionIndex = 0;
        for (int i = 0; i < total; i++) {
            order[i] = matrix[row][column];
            visited[row][column] = true;
            //判断是否应该转换方向
            int nextRow = row + directions[directionIndex][0];
            int nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn])
                directionIndex = (directionIndex + 1) % 4;//换一个方向
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
};
```



**思路3**：按层遍历。

可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。

定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。

```
[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]
```

​	对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 (top,left)，右下角位于(bottom,right)，按照如下顺序遍历当前层的元素。从左到右遍历上侧元素，依次为 (top,left) 到(top,right)。

从上到下遍历右侧元素，依次为(top+1,right) 到 (bottom,right)。

如果 left<right 且top<bottom，则从右到左遍历下侧元素，依次为(bottom,right−1) 到 (bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到 (top+1,left)。

遍历完当前层的元素之后，将 left 和top 分别增加 11，将right 和 bottom 分别减少 11，进入下一层继续遍历，直到遍历完所有元素为止。

```c++
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    if(matrix.size()==0 || matrix[0].size()==0) return {};
    int rows=matrix.size(), cols=matrix[0].size();
    vector<int> arr;
    int left=0,right=cols-1,top=0,bottom=rows-1;
    while(left<=right && top<=bottom){
        //从左上角到右上角
        for(int i=left;i<=right;++i) arr.push_back(matrix[top][i]);
        //从右上角到右下角
        for(int i=top+1;i<=bottom;++i) arr.push_back(matrix[i][right]);
        if(left==right || top==bottom) //为了防止重复遍历
            break;
        //从右下角到左下角
        for(int i=right-1;i>=left;--i) arr.push_back(matrix[bottom][i]);
        //从左下角到左上角
        for(int i=bottom-1;i>top;--i) arr.push_back(matrix[i][left]);
        top++;
        bottom--;
        left++;
        right--;
    }
    return arr;
}
```



### J29. 顺时针打印矩阵

**[题目](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)**: 同上L54









# 2. 哈希表

## 基础知识





## 题目

### L705. 设计哈希集合
**题目**：不使用任何内建的哈希表库设计一个哈希集合（HashSet）。  
实现 MyHashSet 类：
void add(key) 向哈希集合中插入值 key 。  
bool contains(key) 返回哈希集合中是否存在这个值 key 。  
void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。  

**思路1**：使用数组作为容器，一开始就设置数组的容量。使用除留余数法作为哈希函数。使用链地址法解决哈希冲突。即
数组的每个元素是一个list，这样增删比较方便。

```C++
class MyHashSet {
public:
    MyHashSet() {
        data.resize(kSize);
    }
    int hash(int key){
        return key%kSize;
    }
    void add(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it)
            if(*it == key)
                return;
        data[index].push_back(key);
    }
    void remove(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(*it == key){
                data[index].erase(it);
                return;
            }
        }
    }
    bool contains(int key) {
        int index = hash(key);
        for(auto p: data[index]) if(p==key) return true;
        return false;
    }
private:
    vector<list<int>> data;
    static constexpr int kSize=1000;
};
```

**思路2**：使用一个**数组**来表示哈希集。数组中的每个元素都是一个桶。在每个桶中，我们使用 vector来存储所有值。

```C++
#define MAX_LEN 100000          // the amount of buckets
class MyHashSet {
private:
    vector<int> set[MAX_LEN];   // hash set implemented by array
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        // Each bucket contains a list. Iterate all the elements in the bucket to find the target key.
        for (int i = 0; i < set[index].size(); ++i) 
            if (set[index][i] == key) 
                return i;
        return -1;
    }
public:
    MyHashSet() {
    }
    
    void add(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) set[index].push_back(key);
    }
    
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) set[index].erase(set[index].begin() + pos);
    }
    /** Returns true if this set did not already contain the specified element */
    bool contains(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        return pos >= 0;
    }
};
```





### L706. 设计哈希映射

**题目**：不使用任何内建的哈希表库设计一个哈希映射（HashMap）。  
实现 MyHashMap 类：  
MyHashMap() 用空映射初始化对象  
void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。  
int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。  
void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。  

**思路1**：使用数组作为容器，一开始就设置数组的容量。使用除留余数法作为哈希函数。使用链地址法解决哈希冲突。即
数组的每个元素是一个list，这样增删比较方便。
```C++
class MyHashMap {
public:
    MyHashMap() {
        data.resize(kSize);
    }
    int hash(int key){
        return key%kSize;
    }
    void put(int key, int value) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(it->first==key){
                it->second = value;
                return;
            }
        }
        data[index].push_back({key,value});
    }
    
    int get(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(it->first==key){
                return it->second;
            }
        }
        return -1;
    }
    
    void remove(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(it->first==key){
                data[index].erase(it);
                return;
            }
        }
    }
private:
    vector<list<pair<int,int>>> data;
    static constexpr int kSize=1000;
};
```

**思路2**：使用一个**数组**来表示哈希集。数组中的每个元素都是一个桶。在每个桶中，我们使用 vector来存储所有值。

```C++
#define MAX_LEN 100000            // the amount of buckets

class MyHashMap {
private:
    vector<pair<int, int>> map[MAX_LEN];       // hash map implemented by array
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        for (int i = 0; i < map[index].size(); ++i) 
            if (map[index][i].first == key) 
                return i;
        return -1;
    }
public:
    /** Initialize your data structure here. */
    MyHashMap() {
    }
    /** value will always be positive. */
    void put(int key, int value) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            map[index].push_back(make_pair(key, value));
        } else {
            map[index][pos].second = value;
        }
    }
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    int get(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) 
            return -1;
         else 
            return map[index][pos].second;
    }
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) 
            map[index].erase(map[index].begin() + pos);
    }
};
```









### L202. 快乐数

**题目**：难度简单769收藏分享切换为英文接收动态反馈

编写一个算法来判断一个数 `n` 是不是快乐数。

「快乐数」定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果 **可以变为** 1，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**思路1**：通过哈希集合std::unordered_set记录每次迭代中中平方和num，若发现哈希集合中已经存在了该值，则返回false。

```C++
bool isHappy(int n) {
    if(n==1)
        return true;
    else if(n==0)
        return false;
    int num=0;
    std::unordered_set<int> hash_set;
    while(true){
        while(n>0){//split
            num += std::pow(n%10,2);
            n/=10;
        }
        if(num==1)
            return true;
        if(hash_set.count(num)>0)
            return false;
        hash_set.insert(num);
        n=num;
        num=0;
    }
    return false;
}
```

**思路2**：使用快慢指针法。通过反复调用 getNext(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 getNext(n) 函数获得。

意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。

不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。

我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。

如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。

如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。





### L75. 颜色分类
**题目**:
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。  
**思路1：**: 最简单粗暴的方法是，直接使用排序算法，进行升序排列。
```C++
//快速排序
void QSort(vector<int> &nums,int low,int high){
    static auto partition = [](vector<int> &arr,int left,int right){
        int key = arr[left];
        while(left<right){
            while(left < right && arr[right]>=key) right--;
            arr[left]=arr[right];
            while(left<right && arr[left]<=key) left++;
            arr[right] = arr[left];
        }
        arr[left] = key;
        return left;
    };
    if(low>=high) return;
    int mid = partition(nums,low,high);
    QSort(nums,low,mid-1);
    QSort(nums,mid+1,high);
}


void sortColors(vector<int>& nums) {
    QSort(nums,0,nums.size()-1);
}
```

**思路2**：这是一个荷兰国旗问题。单指针，遍历两次，第一次遍历将0 交换到数组的前部，第二次遍历将1 交换到0后数组的中间区域。
```C++
void sortColors(vector<int>& nums) {
    int k=0;
    for(int i=0;i<nums.size();++i){
        if( nums[i]==0){
            std::swap(nums[i],nums[k]);
            k++;
        }
    }
    for(int i=k;i<nums.size();++i){
        if( nums[i]==1){
            std::swap(nums[i],nums[k]);
            k++;
        }
    }
}
```

**思路3**：采用双指针，一个从前往后，一个从后往前同时遍历。
```C++
void sortColors(vector<int>& nums) {
    int k = nums.size()-1;
    int j=0;
    for(int i=0;i<=k;++i){
        while(i<=k && nums[i]==2){
            std::swap(nums[i],nums[k]);
            k--;
        }
        if(nums[i]==0){
            std::swap(nums[i],nums[j]);
            j++;
        }
    }
}
```



# 3. 链表

## 基础知识











## 搜索

### J22. 链表中倒数第k个节点

**[题目](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)**：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

 ```
示例：
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.
 ```



**思路1**：双指针，让其中一个指针先走k步。

```C++
ListNode* getKthFromEnd(ListNode* head, int k) {
    int index=0;
    auto curr=head;
    auto prev=head;
    while(curr){
        if(index < k){
            index++;
            curr=curr->next;
        }
        else{
            curr=curr->next;
            prev=prev->next;
        }
    }
    return prev;
}
```



**思路2**：两次遍历。

第一次首先计算出链表的长度n，第二次遍历到n-k处。

```C++
ListNode* getKthFromEnd(ListNode* head, int k) {
    int n=0;
    auto node=head;
    while(node){
        ++n;
        node=node->next;
    }
    node=head;
    int index=n-k;
    while(index>0){
        node=node->next;
        index--;
    }
    return node;
}
```



## 插入和删除



### J18. 删除链表的节点

**[题目](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)**: 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

```
示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```


说明：

题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点



**思路**：

```C++
ListNode* deleteNode(ListNode* head, int val) {
    if(!head)return head;
    if(head->val==val)return head->next;
    auto node=head;
    while(node->next){
        if(node->next->val == val){
            node->next = node->next->next;
            break;
        }
        node=node->next;
    }
    return head;
}
```





### L203. 移除链表元素

**题目**：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。   

**思路**：首先找到第一个不是val的节点，作为新链表的头节点。然后定义两个节点prev和p，p用来判断是否是val，prev用来当删除
p时保存链表的连接。

```C++
ListNode* removeElements(ListNode* head, int val) {
    struct ListNode* dummyHead = new ListNode(0, head);
    struct ListNode* temp = dummyHead;
    while (temp->next != NULL) {
        if (temp->next->val == val) {
            temp->next = temp->next->next;
        } else {
            temp = temp->next;
        }
    }
    return dummyHead->next;
}
```





### L83. 删除排序链表中的重复元素

**题目**：存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。
返回同样按升序排列的结果链表。

**思路**：定义一个while循环，当p->next && p->val == p->next->val 删除p即可。  
**解法**：

```C++
ListNode* deleteDuplicates(ListNode* head) {
    auto p = head;
    while(p){
        while(p->next && p->val == p->next->val){
            auto tmp =p->next;
            p->next = p->next->next;
            delete tmp;
        }
        if(p)
            p = p->next;
        else
            break;
    }
    return head;
}
```





### L19. 删除链表的倒数第N个节点

**[题目](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)**：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

 ```
示例 1：
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

示例 2：
输入：head = [1], n = 1
输出：[]

示例 3：
输入：head = [1,2], n = 1
输出：[1]
 ```


提示：

链表中结点的数目为 sz
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz



**思路1**：双指针。

先令一个curr指针先走n+1步。

然后使curr指针和prev指针同时前进，当curr指针到结尾时，prev指针刚好是要删除节点的前一个节点。

注意这里需要区分是否删除的是头节点。判断是不是头节点的方法是令curr走n步之后，判断是否为空。

```C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    if(!head)return head;
    auto prev=head;
    auto curr=head;
    for(int i=0;i<n && curr;++i)
        curr=curr->next;//curr先前进了n步
    if(!curr){//前进n步就为null，表明要删除的是头节点
        auto tmp=head;
        head=head->next;
        delete tmp;
    }
    else{
        //为了删除curr，需要curr再前进一步，使得curr比prev多前进n+1步
        curr=curr->next;
        while(prev && curr){
            prev=prev->next;
            curr=curr->next;
        }
        auto tmp=prev->next;
        prev->next=prev->next->next;
        delete tmp;
    }

    return head;
}
```
另一种实现方法：创建新的头节点指针。

```C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0, head);
    ListNode* first = head;
    ListNode* second = dummy;
    for (int i = 0; i < n; ++i) 
        first = first->next;
    while (first) {
        first = first->next;
        second = second->next;
    }
    second->next = second->next->next;
    ListNode* ans = dummy->next;
    delete dummy;
    return ans;
}
```



**思路2**：栈。

```C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0, head);
    stack<ListNode*> stk;
    ListNode* cur = dummy;
    while (cur) {
        stk.push(cur);
        cur = cur->next;
    }
    for (int i = 0; i < n; ++i) {
        stk.pop();
    }
    ListNode* prev = stk.top();
    prev->next = prev->next->next;
    ListNode* ans = dummy->next;
    delete dummy;
    return ans;
}
```



**思路3**：计算链表长度。

```C++
int getLength(ListNode* head) {
    int length = 0;
    while (head) {
        ++length;
        head = head->next;
    }
    return length;
}

ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0, head);
    int length = getLength(head);
    ListNode* cur = dummy;
    for (int i = 1; i < length - n + 1; ++i) {
        cur = cur->next;
    }
    cur->next = cur->next->next;
    ListNode* ans = dummy->next;
    delete dummy;
    return ans;
}
```





## 反转



### L206. 反转链表

**题目**：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 



**思路1**：迭代，设置前向和后向迭代两个指针。

​	假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。 在遍历链表时，将当前节点的 next 指针改为
指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后
返回新的头引用。  
代码：  

```C++
ListNode* reverseList(ListNode* head) {
    if(!head)return head;
    auto prev=head;//反转链表的指针
    auto curr=head;//前向链表的指针
    while(curr){
        auto tmp=curr;//记录前向链表
        curr=curr->next;//前向
        tmp->next=prev;
        prev=tmp;
    }
    head->next=NULL;
    return prev;
}
```



**思路2**：递归。

```C++
ListNode* reverseList(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode* newHead = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return newHead;
}
```



**思路3**：栈。

使用栈保存遍历得到的节点。

```C++
ListNode* reverseList(ListNode* head) {
    if(!head)return head;
    std::stack<ListNode*> stk;
    auto node=head;
    while(node){
        stk.push(node);
        node=node->next;
    }
    auto r_head=stk.top();
    stk.pop();
    node=r_head;
    while(!stk.empty()){
        node->next = stk.top();
        stk.pop();
        node=node->next;
        node->next=NULL;
    }
    return r_head;
}
```





### J24. 反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

 ```
示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
 ```


限制：

0 <= 节点个数 <= 5000



解法：同L206





## 合并



### L21. 合并两个有序链表

**[题目]( https://leetcode-cn.com/problems/merge-two-sorted-lists/)**：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```
示例 1：
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

示例 2：
输入：l1 = [], l2 = []
输出：[]

示例 3：
输入：l1 = [], l2 = [0]
输出：[0]
```


提示：

两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列



**思路1**：双指针。

我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。  

```C++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if(!list1)return list2;
    else if(!list2) return list1;
    auto node1=list1;
    auto node2=list2;
    //计算头节点
    ListNode* list3=nullptr;
    if(node1->val < node2->val){
        list3=node1;
        node1=node1->next;
    }
    else{
        list3=node2;
        node2=node2->next;
    }
    //双指针循环
    auto node3=list3;
    while(true){
        if(!node1){
            node3->next = node2;
            break;
        }
        else if(!node2){
            node3->next = node1;
            break;
        }
        else{
            if(node1->val < node2->val){
                node3->next = node1;
                node1=node1->next;
                node3=node3->next;
                node3->next=nullptr;
            }
            else{
                node3->next = node2;
                node2=node2->next;
                node3=node3->next;
                node3->next=nullptr;
            }
        }
    }
    return list3;
}
```



代码简化版：

```C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    auto l3=new ListNode(3);
    auto prev=l3;
    while(l1 && l2){
        if(l1->val < l2->val){
            prev->next=l1;
            l1=l1->next;
        }
        else{
            prev->next=l2;
            l2=l2->next;
        }
        prev=prev->next;
    }
    prev->next = l1?l1:l2;
    prev=l3->next;
    delete l3;
    return prev;
}
```



**思路2**：递归法。

我们直接将以上递归过程建模，同时需要考虑边界情况。

如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

```C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    if (l1 == nullptr) {
        return l2;
    } else if (l2 == nullptr) {
        return l1;
    } else if (l1->val < l2->val) {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    } else {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}
```



### J25. 合并两个排序的链表

题目和答案：同L21





## 环形链表



### L141. 环形链表

**[题目](https://leetcode-cn.com/problems/linked-list-cycle/)**：给你一个链表的头节点 head ，判断链表中是否有环。  
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，
评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链
表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。  
如果链表中存在环，则返回 true 。 否则，返回 false 。  

```
示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```


提示：

```
链表中节点的数目范围是 [0, 104]
-105 <= Node.val <= 105
pos 为 -1 或者链表中的一个 有效索引 。
```



**思路1**:  哈希表  

```C++
bool hasCycle(ListNode *head) {
    std::unordered_set<ListNode*> hash_set;
    auto node=head;
    while(node){
        if(hash_set.find(node)!=hash_set.end())
            return true;
        else
            hash_set.insert(node);
        node=node->next;
    }
    return false;
}
```



**思路2**： Floyd 判圈算法 

​	我们先设置慢指针 slow 和快指针 fast ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 slow 放置起点 0，两个指针每次同时移动一步，相遇的点就是答案。 

​	这里简单解释为什么后面将 slow 放置起点后移动相遇的点就一定是答案了。假设环长为 L，从起点到环的入口的步数是 a，从环的入口继续走 b 步到达相遇位置，从相遇位置继续走 c 步回到环的入口，则有 b+c=L，其中 L、a、b、c 都是正整数。根据上述定义，慢指针走了a+b 步，快指针走了 2(a+b)步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 a+b+kL，其中 k 表示快指针在环上走的圈数。联立等式，可以得到2(a+b)=a+b+kL解得 a=kL-b，整理可得 a=(k-1)L+(L-b)=(k-1)L+c  。从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 a 步之后到达环的入口，快指针在环里走了 k−1 圈之后又走了 c 步，由于从相遇位置继续走 c 步即可回到环的入口，因此快指针也到达环的入口。两个指针在 环的入口相遇，相遇点就是答案。  

注意特点： 适用于判断图，判断环路，有且只有一个环的情况。图中有且只有一个点存在两个入度为 1，其他入度均为 0。  

```C++
bool hasCycle(ListNode *head) {
    if(!head || !head->next)return false;
    auto prev=head;//走一步的指针
    auto curr=head;//走两步的指针
    while(curr && curr->next){
        prev=prev->next;
        curr=curr->next->next;
        if(prev==curr) return true;
    }
    return false;
}
```





### L142. 环形链表 II

**[题目](https://leetcode-cn.com/problems/linked-list-cycle-ii/)**: 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

 ```
示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
 ```


提示：

链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引



**思路1**：哈希集合。

```C++
ListNode *detectCycle(ListNode *head) {
    std::unordered_set<ListNode*> hash_set;
    while(head){
        if(hash_set.find(head)!=hash_set.end())
            return head;
        else
            hash_set.insert(head);
        head=head->next;
    }
    return nullptr;
}
```



**思路2**：Floyd 判圈算法

分析同L141。

​	假设环长为 `L`，从起点到环的入口的步数是 `a`，从环的入口继续走 `b` 步到达相遇位置，从相遇位置继续走 `c` 步回到环的入口，则有 `b+c=L`，其中 `L、a、b、c `都是正整数。根据上述定义，慢指针走了`a+b` 步，快指针走了 `2(a+b)`步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 `a+b+kL`，其中 `k `表示快指针在环上走的圈数。

​	联立等式，可以得到`2(a+b)=a+b+kL`解得 `a=kL-b`，整理可得 `a=(k-1)L+(L-b)=(k-1)L+c ` 。

​	**即在两个指针相遇后，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了` a `步之后到达环的入口，快指针在环里走了 `k−1` 圈之后又走了 `c` 步，由于从相遇位置继续走 `c `步即可回到环的入口，因此快指针也到达环的入口。两个指针在 环的入口相遇，相遇点就是答案。**  

```C++
ListNode *detectCycle(ListNode *head) {
    auto slow=head;
    auto fast=head;
    while(fast && fast->next){
        fast=fast->next->next;
        slow=slow->next;
        if(fast==slow){//到达相遇点
            slow=head;//slow重头开始走
            while(slow!=fast){//slow==fast即为入口点
                slow=slow->next;
                fast=fast->next;
            }
            return slow;
        }
    }
    return nullptr;
}
```





### JII 22.链表中环的入口节点

**[题目](https://leetcode-cn.com/problems/c32eOV/)**：同上（L142）





## 复杂链表

### L138. 复制带随机指针的链表

**[题目](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)**：给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **深拷贝**。 深拷贝应该正好由 n 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。

返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

* val：一个表示 Node.val 的整数。
* random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
  你的代码 只 接受原链表的头节点 head 作为传入参数。

 ```
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

示例 2：
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]

示例 3：
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
 ```


提示：

0 <= n <= 1000
-104 <= Node.val <= 104
Node.random 为 null 或指向链表中的节点。



**思路1**：迭代+哈希表实现。

​	在复制新的节点时，将旧节点和对应的新节点放入哈希表中，成为键值对。其中旧节点是key，新节点是值。

​	创建所有的新节点完成后，遍历旧链表，根据哈希表，查询每个旧节点的random指针，设置新节点的random指针，即：`cnode->random = hash_map[node->random]`。

```C++
Node* copyRandomList(Node* head) {
    if(!head) return NULL;
    Node* chead=new Node(head->val);

    std::unordered_map<Node*,Node*> hash_map;//用于映射：old node -> new node
    hash_map.insert({head,chead});

    //构建新的链表
    auto prev = chead;
    auto node = head->next;
    while(node){
        Node* new_node=new Node(node->val);
        hash_map.insert({node,new_node});
        prev->next = new_node;
        prev = prev->next;
        node = node->next;
    }
    //设置新链表的random指针
    node=head;
    auto cnode = chead;
    while(node){
        if(node->random){
            cnode->random = hash_map[node->random];
        }
        else{
            cnode->random=NULL;
        }
        node = node->next;
        cnode = cnode->next;
    }
    return chead;
}
```



**思路2**：回溯+哈希表实现。

本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。

具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。

在实际代码中，我们需要特别判断给定节点为空节点的情况。

```C++
class Solution {
private:
    std::unordered_map<Node*,Node*> hash_map;
public:
    Node* copyRandomList(Node* head) {
        if(!head)
            return NULL;
        if(auto cnode=hash_map.find(head); cnode==hash_map.end()){
            Node* new_node=new Node(head->val);
            hash_map.insert({head,new_node});
            new_node->next = copyRandomList(head->next);
            new_node->random = copyRandomList(head->random);
            return new_node;
        }
        else{
            return cnode->second;
        }
    }
};
```



**思路3**：迭代+节点拆分

注意到方法一需要使用哈希表记录每一个节点对应新节点的创建情况，而我们可以使用一个小技巧来省去哈希表的空间。

我们首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 A→B→C，我们可以将其拆分为 'A→A′ →B→B′ →C→C′ 。对于任意一个原节点 S，其拷贝节点 S' 即为其后继节点。

这样，我们可以直接找到每一个拷贝节点 S' 的随机指针应当指向的节点，即为其原节点 S 的随机指针指向的节点 T 的后继节点 T'。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。

当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。

```C++
Node* copyRandomList(Node* head) {
    if (head == nullptr) {
        return nullptr;
    }
    //拷贝每个节点
    for (Node* node = head; node != nullptr; node = node->next->next) {
        Node* nodeNew = new Node(node->val);
        nodeNew->next = node->next;
        node->next = nodeNew;
    }
    //为每个拷贝节点 设置随机指针
    for (Node* node = head; node != nullptr; node = node->next->next) {
        Node* nodeNew = node->next;
        nodeNew->random = (node->random != nullptr) ? node->random->next : nullptr;
    }
    //将拷贝节点从原链表中拆分出来
    Node* headNew = head->next;
    for (Node* node = head; node != nullptr; node = node->next) {
        Node* nodeNew = node->next;
        node->next = node->next->next;
        nodeNew->next = (nodeNew->next != nullptr) ? nodeNew->next->next : nullptr;
    }
    return headNew;
}
```









### J35. 复杂链表的复制

**[题目](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)**：同L138.







# 4. 栈

## 基础知识



## 题目



### L155. 最小栈

**[题目](https://leetcode-cn.com/problems/min-stack/)**：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

* push(x) —— 将元素 x 推入栈中。
* pop() —— 删除栈顶的元素。
* top() —— 获取栈顶元素。
* getMin() —— 检索栈中的最小元素。

```
示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```


提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。



**思路1**：辅助栈。用两个栈实现。

只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。

当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；

当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；

在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。

```C++
class MinStack {
    stack<int> x_stack;
    stack<int> min_stack;
public:
    MinStack() {
        min_stack.push(INT_MAX);
    }
    
    void push(int x) {
        x_stack.push(x);
        min_stack.push(min(min_stack.top(), x));
    }
    
    void pop() {
        x_stack.pop();
        min_stack.pop();
    }
    
    int top() {
        return x_stack.top();
    }
    
    int getMin() {
        return min_stack.top();
    }
};
```



另一种实现是，辅助栈中并不存储所有元素对应的最小值，而是当插入到主栈中的元素小于等于辅助栈栈顶的元素时，才进行插入操作。

pop()时，仅当主栈栈顶的元素等于辅助栈栈顶的元素时，才将辅助栈栈顶的元素pop()。此时，辅助栈所需的空间小于原来的方法。

```C++
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {
    }
    
    void push(int x) {
        data.push(x);
        if(min_data.empty() || min_data.top()>=x)
            min_data.push(x);
    }
    
    void pop() {
        if(data.top()==min_data.top())
            min_data.pop();
        data.pop();
    }
    
    int top() {
        return data.top();
    }
    
    int min() {
        return min_data.top();
    }
private:
    std::stack<int> data;
    std::stack<int> min_data;
};
```



### J30. 包含min函数的栈

**[题目](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)**：同L155



### L946. 验证栈序列

**[题目](https://leetcode-cn.com/problems/validate-stack-sequences/)**: 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。

```
示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```


提示：

```
1 <= pushed.length <= 1000
0 <= pushed[i] <= 1000
pushed 的所有元素 互不相同
popped.length == pushed.length
popped 是 pushed 的一个排列
```



**思路1**：模拟栈的输入输出。

使用一个栈来模拟输入输出序列。
当 popped[j]!=stk.top() 时，将pushed序列的元素压入栈中。

当pushed序列和poped序列不对应时，将返回false。

```C++
bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
    std::stack<int> stk;
    int i=0,j=0;
    while(j<popped.size()){
        while((stk.empty() || popped[j]!=stk.top()) && i<pushed.size()){
            stk.push(pushed[i++]);
        }
        if(popped[j]==stk.top()){
            j++;
            stk.pop();
        }
        else{
            return false;
        }
    }
    return true;
}
```



**思路2**：优化版本。

上面的 方法需要单独构建一个栈来验证。

这里使用pushed数组的前半部分作为栈来验证序列。因此空间复杂度降低。

```C++
bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
    int i = 0, j = 0;
    for(int x : pushed){
        pushed[i] = x;
        while(i >= 0 && pushed[i] == popped[j]){
            j++;
            i--;
        }
        i++;
    }
    return i == 0;
}
```





### J31. 栈的压入、弹出序列

**[题目](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)**: 同L946






















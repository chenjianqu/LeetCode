

# 1. 哈希表

## 基础知识





## 题目

### L705. 设计哈希集合
**题目**：不使用任何内建的哈希表库设计一个哈希集合（HashSet）。  
实现 MyHashSet 类：
void add(key) 向哈希集合中插入值 key 。  
bool contains(key) 返回哈希集合中是否存在这个值 key 。  
void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。  

**思路1**：使用数组作为容器，一开始就设置数组的容量。使用除留余数法作为哈希函数。使用链地址法解决哈希冲突。即
数组的每个元素是一个list，这样增删比较方便。

```C++
class MyHashSet {
public:
    MyHashSet() {
        data.resize(kSize);
    }
    int hash(int key){
        return key%kSize;
    }
    void add(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it)
            if(*it == key)
                return;
        data[index].push_back(key);
    }
    void remove(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(*it == key){
                data[index].erase(it);
                return;
            }
        }
    }
    bool contains(int key) {
        int index = hash(key);
        for(auto p: data[index]) if(p==key) return true;
        return false;
    }
private:
    vector<list<int>> data;
    static constexpr int kSize=1000;
};
```

**思路2**：使用一个**数组**来表示哈希集。数组中的每个元素都是一个桶。在每个桶中，我们使用 vector来存储所有值。

```C++
#define MAX_LEN 100000          // the amount of buckets
class MyHashSet {
private:
    vector<int> set[MAX_LEN];   // hash set implemented by array
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        // Each bucket contains a list. Iterate all the elements in the bucket to find the target key.
        for (int i = 0; i < set[index].size(); ++i) 
            if (set[index][i] == key) 
                return i;
        return -1;
    }
public:
    MyHashSet() {
    }
    
    void add(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) set[index].push_back(key);
    }
    
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) set[index].erase(set[index].begin() + pos);
    }
    /** Returns true if this set did not already contain the specified element */
    bool contains(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        return pos >= 0;
    }
};
```





### L706. 设计哈希映射

**题目**：不使用任何内建的哈希表库设计一个哈希映射（HashMap）。  
实现 MyHashMap 类：  
MyHashMap() 用空映射初始化对象  
void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。  
int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。  
void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。  

**思路1**：使用数组作为容器，一开始就设置数组的容量。使用除留余数法作为哈希函数。使用链地址法解决哈希冲突。即
数组的每个元素是一个list，这样增删比较方便。
```C++
class MyHashMap {
public:
    MyHashMap() {
        data.resize(kSize);
    }
    int hash(int key){
        return key%kSize;
    }
    void put(int key, int value) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(it->first==key){
                it->second = value;
                return;
            }
        }
        data[index].push_back({key,value});
    }
    
    int get(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(it->first==key){
                return it->second;
            }
        }
        return -1;
    }
    
    void remove(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(it->first==key){
                data[index].erase(it);
                return;
            }
        }
    }
private:
    vector<list<pair<int,int>>> data;
    static constexpr int kSize=1000;
};
```

**思路2**：使用一个**数组**来表示哈希集。数组中的每个元素都是一个桶。在每个桶中，我们使用 vector来存储所有值。

```C++
#define MAX_LEN 100000            // the amount of buckets

class MyHashMap {
private:
    vector<pair<int, int>> map[MAX_LEN];       // hash map implemented by array
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        for (int i = 0; i < map[index].size(); ++i) 
            if (map[index][i].first == key) 
                return i;
        return -1;
    }
public:
    /** Initialize your data structure here. */
    MyHashMap() {
    }
    /** value will always be positive. */
    void put(int key, int value) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            map[index].push_back(make_pair(key, value));
        } else {
            map[index][pos].second = value;
        }
    }
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    int get(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) 
            return -1;
         else 
            return map[index][pos].second;
    }
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) 
            map[index].erase(map[index].begin() + pos);
    }
};
```









### L202. 快乐数

**题目**：难度简单769收藏分享切换为英文接收动态反馈

编写一个算法来判断一个数 `n` 是不是快乐数。

「快乐数」定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果 **可以变为** 1，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**思路1**：通过哈希集合std::unordered_set记录每次迭代中中平方和num，若发现哈希集合中已经存在了该值，则返回false。

```C++
bool isHappy(int n) {
    if(n==1)
        return true;
    else if(n==0)
        return false;
    int num=0;
    std::unordered_set<int> hash_set;
    while(true){
        while(n>0){//split
            num += std::pow(n%10,2);
            n/=10;
        }
        if(num==1)
            return true;
        if(hash_set.count(num)>0)
            return false;
        hash_set.insert(num);
        n=num;
        num=0;
    }
    return false;
}
```

**思路2**：使用快慢指针法。通过反复调用 getNext(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 getNext(n) 函数获得。

意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。

不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。

我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。

如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。

如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。





### L75. 颜色分类
**题目**:
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。  
**思路1：**: 最简单粗暴的方法是，直接使用排序算法，进行升序排列。
```C++
//快速排序
void QSort(vector<int> &nums,int low,int high){
    static auto partition = [](vector<int> &arr,int left,int right){
        int key = arr[left];
        while(left<right){
            while(left < right && arr[right]>=key) right--;
            arr[left]=arr[right];
            while(left<right && arr[left]<=key) left++;
            arr[right] = arr[left];
        }
        arr[left] = key;
        return left;
    };
    if(low>=high) return;
    int mid = partition(nums,low,high);
    QSort(nums,low,mid-1);
    QSort(nums,mid+1,high);
}


void sortColors(vector<int>& nums) {
    QSort(nums,0,nums.size()-1);
}
```

**思路2**：这是一个荷兰国旗问题。单指针，遍历两次，第一次遍历将0 交换到数组的前部，第二次遍历将1 交换到0后数组的中间区域。
```C++
void sortColors(vector<int>& nums) {
    int k=0;
    for(int i=0;i<nums.size();++i){
        if( nums[i]==0){
            std::swap(nums[i],nums[k]);
            k++;
        }
    }
    for(int i=k;i<nums.size();++i){
        if( nums[i]==1){
            std::swap(nums[i],nums[k]);
            k++;
        }
    }
}
```

**思路3**：采用双指针，一个从前往后，一个从后往前同时遍历。
```C++
void sortColors(vector<int>& nums) {
    int k = nums.size()-1;
    int j=0;
    for(int i=0;i<=k;++i){
        while(i<=k && nums[i]==2){
            std::swap(nums[i],nums[k]);
            k--;
        }
        if(nums[i]==0){
            std::swap(nums[i],nums[j]);
            j++;
        }
    }
}
```







# 2. 栈

## 基础知识



## 题目



### L155. 最小栈

**[题目](https://leetcode-cn.com/problems/min-stack/)**：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

* push(x) —— 将元素 x 推入栈中。
* pop() —— 删除栈顶的元素。
* top() —— 获取栈顶元素。
* getMin() —— 检索栈中的最小元素。

```
示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```


提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。



**思路1**：辅助栈。用两个栈实现。

只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。

当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；

当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；

在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。

```C++
class MinStack {
    stack<int> x_stack;
    stack<int> min_stack;
public:
    MinStack() {
        min_stack.push(INT_MAX);
    }
    
    void push(int x) {
        x_stack.push(x);
        min_stack.push(min(min_stack.top(), x));
    }
    
    void pop() {
        x_stack.pop();
        min_stack.pop();
    }
    
    int top() {
        return x_stack.top();
    }
    
    int getMin() {
        return min_stack.top();
    }
};
```



另一种实现是，辅助栈中并不存储所有元素对应的最小值，而是当插入到主栈中的元素小于等于辅助栈栈顶的元素时，才进行插入操作。

pop()时，仅当主栈栈顶的元素等于辅助栈栈顶的元素时，才将辅助栈栈顶的元素pop()。此时，辅助栈所需的空间小于原来的方法。

```C++
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {
    }
    
    void push(int x) {
        data.push(x);
        if(min_data.empty() || min_data.top()>=x)
            min_data.push(x);
    }
    
    void pop() {
        if(data.top()==min_data.top())
            min_data.pop();
        data.pop();
    }
    
    int top() {
        return data.top();
    }
    
    int min() {
        return min_data.top();
    }
private:
    std::stack<int> data;
    std::stack<int> min_data;
};
```



### J30. 包含min函数的栈

**[题目](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)**：同L155



### L946. 验证栈序列

**[题目](https://leetcode-cn.com/problems/validate-stack-sequences/)**: 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。

```
示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```


提示：

```
1 <= pushed.length <= 1000
0 <= pushed[i] <= 1000
pushed 的所有元素 互不相同
popped.length == pushed.length
popped 是 pushed 的一个排列
```



**思路1**：模拟栈的输入输出。

使用一个栈来模拟输入输出序列。
当 popped[j]!=stk.top() 时，将pushed序列的元素压入栈中。

当pushed序列和poped序列不对应时，将返回false。

```C++
bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
    std::stack<int> stk;
    int i=0,j=0;
    while(j<popped.size()){
        while((stk.empty() || popped[j]!=stk.top()) && i<pushed.size()){
            stk.push(pushed[i++]);
        }
        if(popped[j]==stk.top()){
            j++;
            stk.pop();
        }
        else{
            return false;
        }
    }
    return true;
}
```



**思路2**：优化版本。

上面的 方法需要单独构建一个栈来验证。

这里使用pushed数组的前半部分作为栈来验证序列。因此空间复杂度降低。

```C++
bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
    int i = 0, j = 0;
    for(int x : pushed){
        pushed[i] = x;
        while(i >= 0 && pushed[i] == popped[j]){
            j++;
            i--;
        }
        i++;
    }
    return i == 0;
}
```





### J31. 栈的压入、弹出序列

**[题目](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)**: 同L946









# 3. 堆

## 基础知识



## 题目



### J41. 数据流的中位数

**[题目](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)**：同L295。

### L295. 数据流的中位数

**[题目](https://leetcode-cn.com/problems/find-median-from-data-stream/)**：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

```
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
```


示例：

```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
```

进阶:

如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？
如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？



**思路1**：优先队列。

时间复杂度：addNum: O(logn)，其中 n 为累计添加的数的数量。findMedian: O(1)。
空间复杂度：O(n)，主要为优先队列的开销。

我们用两个优先队列 `greater_median` 和 `less_median` 分别记录大于中位数的数和小于等于中位数的数。当累计添加的数的数量为奇数时，`less_median` 中的数的数量比 `greater_median` 多一个，此时中位数为 `less_median` 的队头。当累计添加的数的数量为偶数时，两个优先队列中的数的数量相同，此时中位数为它们的队头的平均值。

当我们尝试添加一个数 `num` 到数据结构中，我们需要分情况讨论：

* `num≤max{less_median}`：此时 `num` 小于等于中位数，我们需要将该数添加到 `less_median` 中。新的中位数将小于等于原来的中位数，因此我们可能需要将 `less_median` 中最大的数移动到 `greater_median` 中。

* `num>max{less_median}`：此时 `num` 大于中位数，我们需要将该数添加到 `greater_median` 中。新的中位数将大于等于原来的中位数，因此我们可能需要将 `greater_median` 中最小的数移动到 `less_median` 中。

* 特别地，当累计添加的数的数量为 0 时，我们将 `num` 添加到 less_median 中。

```C++
class MedianFinder {
private:
    std::priority_queue<int,vector<int>,std::less<int>> less_media;//大顶堆，用于记录小于等于中位数的数
    std::priority_queue<int,vector<int>,std::greater<int>> greater_median;//小顶堆，用于记录大于中位数的数
public:
    MedianFinder() {
    }
    
    void addNum(int num) {
        if(less_media.empty() || num<=less_media.top()){
            less_media.push(num);
            if(greater_media.size()<less_media.size()-1){//大于中位数的数太少，将大顶堆less_media中最大的数字转移到小顶堆中
                greater_media.push(less_media.top());
                less_media.pop();
            }
        }
        else{
            greater_media.push(num);
            if(greater_media.size()>less_media.size()){//小于中位数的数太少
                less_media.push(greater_media.top());
                greater_media.pop();
            }
        }
    }
    
    double findMedian() {
        if(less_media.size()>greater_media.size())
            return less_media.top();
        else
            return (less_media.top()+greater_media.top())/2.;
    }
};
```



**思路2**：有序集合 + 双指针。

我们也可以使用有序集合维护这些数。我们把有序集合看作自动排序的数组，使用双指针指向有序集合中的中位数元素即可。当累计添加的数的数量为奇数时，双指针指向同一个元素。当累计添加的数的数量为偶数时，双指针分别指向构成中位数的两个数。

当我们尝试添加一个数num 到数据结构中，我们需要分情况讨论：

* 初始有序集合为空时，我们直接让左右指针指向 num 所在的位置。

* 有序集合为中元素为奇数时，left 和 right 同时指向中位数。如果 num 大于等于中位数，那么只要让left 左移，否则让 right 右移即可。

* 有序集合为中元素为偶数时，left 和 right 分别指向构成中位数的两个数。
  * 当 num 成为新的唯一的中位数，那么我们让 left 右移，right 左移，这样它们即可指向 num 所在的位置；
  * 当 num 大于等于 right，那么我们让 left 右移即可；
  * 当 num 小于 right 指向的值，那么我们让 right 左移，注意到如果 num 恰等于 left 指向的值，那么 num 将被插入到 left 右侧，使得 left 和 right 间距增大，所以我们还需要额外让 left 指向移动后的 right。

```C++
class MedianFinder {
    multiset<int> nums;
    multiset<int>::iterator left, right;

public:
    MedianFinder() : left(nums.end()), right(nums.end()) {}

    void addNum(int num) {
        const size_t n = nums.size();
        nums.insert(num);
        if (n==0) {
            left = right = nums.begin();
        } else if (n % 2==1) {//n为奇数
            if (num < *left) 
                left--;
            else
                right++;
        } else {//n为偶数
            if (num > *left && num < *right) {//left和right变为指向新的中位数
                left++;
                right--;
            } else if (num >= *right) {//插到右边
                left++;
            } else {
                right--;//插到左边
                left = right;//由于num可能等于*left，此时num被插入到left的右侧；此步是为了使得left和right相邻
            }
        }
    }

    double findMedian() {
        return (*left + *right) / 2.0;
    }
};
```




















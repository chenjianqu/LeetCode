# 贪心

## 基础知识

什么是贪⼼
贪⼼的本质是选择每⼀阶段的局部最优，从⽽达到全局最优。
这么说有点抽象，来举⼀个例⼦：
例如，有⼀堆钞票，你可以拿⾛⼗张，如果想达到最⼤的⾦额，你要怎么拿？
指定每次拿最⼤的，最终结果就是拿⾛最⼤数额的钱。
每次拿最⼤的就是局部最优，最后拿⾛最⼤数额的钱就是推出全局最优。



贪⼼算法⼀般分为如下四步：
* 将问题分解为若⼲个⼦问题

* 找出适合的贪⼼策略

* 求解每⼀个⼦问题的最优解

* 将局部最优解堆叠成全局最优解  
  
  
  
  其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪⼼的题⽬往往还和其他⽅⾯的知识混在⼀起。



## 题目

### L455. 分发饼干

**题目**：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。



**思路1**：贪心算法。

为了了满⾜更多的⼩孩，就不要造成饼⼲尺⼨的浪费。
⼤尺⼨的饼⼲既可以满⾜胃⼝⼤的孩⼦也可以满⾜胃⼝⼩的孩⼦，那么就应该优先满⾜胃⼝⼤的。
这⾥的局部最优就是⼤饼⼲喂给胃⼝⼤的，充分利⽤饼⼲尺⼨喂饱⼀个，全局最优就是喂饱尽可能多的
⼩孩。
可以尝试使⽤贪⼼策略，先将饼⼲数组和⼩孩数组排序。
然后从后向前遍历⼩孩数组，⽤⼤饼⼲优先满⾜胃⼝⼤的，并统计满⾜⼩孩数量。

```C++
int findContentChildren(vector<int>& g, vector<int>& s) {
    std::sort(g.begin(),g.end());
    std::sort(s.begin(),s.end());
    int num=0;
    for(int gi=g.size()-1,si=s.size()-1;gi>=0 && si>=0;){
        if(s[si]>=g[gi]){
            num++;
            --si;
            --gi;
        }
        else{
            --gi;
        }
    }
    return num;
}
```





### L376. 摆动序列

**题目**：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。



**思路1**：贪心算法。

局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。
整体最优：整个序列有最多的局部峰值，从⽽达到最⻓摆动序列。
局部最优推出全局最优，并举不出反例，那么试试贪⼼！
实际操作上，其实连删除的操作都不⽤做，因为题⽬要求的是最⻓摆动⼦序列的⻓度，所以只需要统计数组的峰值数量就可以了（相当于是删除单⼀坡度上的节点，然后统计⻓度）
这就是贪⼼所贪的地⽅，让峰值尽可能的保持峰值，然后删除单⼀坡度上的节点。

我的代码

```C++
int wiggleMaxLength(vector<int>& nums) {
    if(nums.size()==1) return 1;
    int count=1;
    int last = nums[1]-nums[0];
    if(last!=0) count++;
    for(int i=2;i<nums.size();++i){
        int differ = nums[i]-nums[i-1];
        if(last>0 && differ>=0)
            continue;
        else if(last<0 && differ<=0)
            continue;
        else if(differ==0){
            last = differ;
            continue;
        }
        last = differ;
        count++;
    }
    return count;
}
```

Carl的代码：

```C++
int wiggleMaxLength(vector<int>& nums) { 
    if (nums.size() <= 1) return nums.size();
    int preDiff = 0; // 前⼀对差值
    int result = 1; // 记录峰值个数，序列默认序列最右边有⼀个峰值
    for (int i = 0; i < nums.size() - 1; i++) {
        int curDiff = nums[i + 1] - nums[i];// 当前⼀对差值
        // 出现峰值
        if ((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0)){
            result++;
            preDiff = curDiff;
        }
    }
    return result;
 }
```





### L53. 最大子数组和

**题目**：给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。



**思路1**：贪心。

如果 -2 1 在⼀起，计算起点的时候，⼀定是从1开始计算，因为负数只会拉低总和，这就是贪⼼贪的地⽅！
局部最优：当前“连续和”为负数的时候⽴刻放弃，从下⼀个元素重新计算“连续和”，因为负数加上下⼀个元素 “连续和”只会越来越⼩。
全局最优：选取最⼤“连续和”
局部最优的情况下，并记录最⼤的“连续和”，可以推出全局最优。
从代码⻆度上来讲：遍历nums，从头开始⽤count累积，如果count⼀旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。
这相当于是暴⼒解法中的不断调整最⼤⼦序和区间的起始位置。

```C++
int maxSubArray(vector<int>& nums) {
    //贪心
    int max=INT_MIN;
    int cnt=0;
    for(int i=0;i<nums.size();++i){
        cnt+=nums[i];
        if(cnt>max)
            max=cnt;
        if(cnt<0)
            cnt=0;
    }
    return max;
}
```





**思路2**：动态规划。

1 确定 dp数组 以及 下标含义。

dp[i] 表示第i个数字前的最大连续子数组和

2 递推公式

dp[i] = max(dp[i-1]+dp[i], dp[i])

3 初始化

dp[0] = nums[0]

4 遍历顺序

从左到右

5 举例。

```C++
int maxSubArray(vector<int>& nums) {
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    int result = nums[0];
    for(int i=1;i<nums.size();++i){
        dp[i] = std::max(dp[i-1]+nums[i],nums[i]);
        if(result<dp[i]) 
            result = dp[i];
    }
    return result;
}
```





**思路3**：分治。

```C++
class Solution {
public:
int crossSubArray(vector<int>& arr,int low ,int mid,int high){
    int lsum=INT_MIN;
    int sum=0;
    for(int i=mid;i>=low;--i){
        sum+= arr[i];
        if(sum>lsum)
            lsum = sum;
    }
    int rsum=INT_MIN;
    sum=0;
    for(int i=mid+1;i<=high;++i){
        sum+=arr[i];
        if(sum>rsum)
            rsum=sum;
    }
    return lsum+rsum;
}

int findSubArray(vector<int>& arr,int low,int high){
    if(low==high) return arr[low];
    int mid = (low+high)/2;
    int lsum = findSubArray(arr,low,mid);
    int rsum = findSubArray(arr,mid+1,high);
    int csum = crossSubArray(arr,low,mid,high);
    return std::max(std::max(lsum,rsum),csum);
}
int maxSubArray(vector<int>& nums) {
    int numsSize = int(nums.size());
    int result = findSubArray(nums, 0, numsSize - 1);
    return result;
}
};
```



**思路4**：暴力法。（超时）

```C++
int maxSubArray(vector<int>& nums) {
    //暴力法
    int max=INT_MIN;
    for(int i=0;i<nums.size();++i){
        int cnt=0;
        for(int j=i;j<nums.size();++j){
            cnt+=nums[j];
            if(cnt>max) max=cnt;
        }
    }
    return max;
}
```





### L122. 买卖股票的最佳时机 II

[题目](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)：给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



**思路1**：贪心。

由于可以多次买卖，因此只要尽可能多在股票价格低时买入，在价高时卖出，即可获得最大收益。

局部最优：收集每天的正利润，全局最优：求得最⼤利润

```C++
int maxProfit(vector<int>& prices) {
    int earning=0;
    int start=-1;
    for(int i=0;i<prices.size()-1;++i){
        if(start<0 && prices[i+1]>prices[i]){
            start=i;
        }
        else if(start>=0 && prices[i+1]<prices[i]){
            earning += prices[i]-prices[start];
            start=-1;
        }
    }
    if(start>=0)
        earning += *(prices.end()-1)-prices[start];
    return earning;
}
```



**思路2**：动态规划。



### L55. 跳跃游戏

[题目](https://leetcode-cn.com/problems/jump-game/)：给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。



**思路1**：贪心算法。

刚看到本题⼀开始可能想：当前位置元素如果是3，我究竟是跳⼀步呢，还是两步呢，还是三步呢，究竟跳⼏步才是最优呢？
其实跳⼏步⽆所谓，关键在于可跳的覆盖范围！不⼀定⾮要明确⼀次究竟跳⼏步，每次取最⼤的跳跃步数，这个就是可以跳跃的覆盖范围。这个范围内，别管是怎么跳的，反正⼀定可以跳过来。那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！
每次移动取最⼤跳跃步数（得到最⼤的覆盖范围），每移动⼀个单位，就更新最⼤覆盖范围。
贪⼼算法局部最优解：每次取最⼤跳跃步数（取最⼤覆盖范围），整体最优解：最后得到整体最⼤覆盖范围，看是否能到终点。

代码：

```C++
bool canJump(vector<int>& nums) {
    int cover=0;
    for(int i=0;i<nums.size()-1 && i<=cover;++i){
        if(i+nums[i] > cover)
            cover=(nums[i]+i);
    }
    return cover>=nums.size()-1;
}
```



### L45. 跳跃游戏 II

[题目](https://leetcode-cn.com/problems/jump-game-ii/)：给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。



**思路1**：贪心。

这道题的思路是，遍历当前可以跳跃的距离，选择一个可以跳跃距离最远的元素作为下一个跳跃点，并记录跳跃的次数。

```C++
int jump(vector<int>& nums) {
    if(nums.size()<=1) return 0;
    int jump_num=1; //跳跃次数
    int cover=nums[0];//当前可以跳跃的距离
    int i=0;
    while(i<nums.size() && cover < nums.size()-1){
        int max_jump=cover;
        int max_j=i;
        for(int j=i+1;j<=cover;++j){
            if(j+nums[j]>max_jump){
                max_jump = j+nums[j];
                max_j = j;
            }
        }
        jump_num++;
        cover=max_jump;
        i = max_j;
    }
    return jump_num;
}
```



或：

贪⼼的思路，局部最优：当前可移动距离尽可能多⾛，如果还没到终点，步数再加⼀。整体最优：⼀步尽可能多⾛，从⽽达到最⼩步数。

所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内⼀定是可以跳到的，以最⼩的步数增加覆盖范围，覆盖范围⼀旦覆盖了终点，得到的就是最⼩步数！
这⾥需要统计两个覆盖范围，当前这⼀步的最⼤覆盖和下⼀步最⼤覆盖。
如果移动下标达到了当前这⼀步的最⼤覆盖最远距离了，还没有到终点的话，那么就必须再⾛⼀步来增加覆盖范围，直到覆盖范围覆盖了终点。

```C++
int jump(vector<int>& nums) {
    int curDistance = 0; // 当前覆盖的最远距离下标
    int ans = 0; // 记录⾛的最⼤步数
    int nextDistance = 0; // 下⼀步覆盖的最远距离下标
    for (int i = 0; i < nums.size() - 1; i++) { // 注意这⾥是⼩于nums.size() - 1
        nextDistance = max(nums[i] + i, nextDistance); // 更新下⼀步覆盖的最远距离下标
        if (i == curDistance) { // 遇到当前覆盖的最远距离下标
            curDistance = nextDistance; // 更新当前覆盖的最远距离下标
            ans++;
        }
    }
    return ans;
 }
```







### L1005. K 次取反后最大化的数组和

[题目](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)：给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：

选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
重复这个过程恰好 k 次。可以多次选择同一个下标 i 。

以这种方式修改数组后，返回数组 可能的最大和 。



**思路1**：贪心。

首先对输入数组进行排序，排序得到的数组 前半部分是负数。因此为了获得最大的数组和，使用k次机会将负数变为正数。

当所有的负数均变为正数后，再对数组进行排序。此排序的目的是获得数组中最小的元素。

由于可以多次对同一个元素进行翻转，因此根据贪心的思路，对最小的非负数翻转 对数组和的影响最小。

```C++
int largestSumAfterKNegations(vector<int>& nums, int k) {
    std::sort(nums.begin(),nums.end());
    for(int i=0;i<nums.size() && nums[i]<0 && k>0;++i){
        nums[i] = -nums[i];
        --k;
    }
    if(k>0){
        std::sort(nums.begin(),nums.end());
        while(k>0){
            nums[0] = -nums[0];
            --k;
        }
    }
    return std::accumulate(nums.begin(),nums.end(),0);
}
```

这么⼀道简单题，就⽤了两次贪⼼！

第⼀步：将数组按照绝对值⼤⼩从⼤到⼩排序，注意要按照绝对值的⼤⼩
第⼆步：从前向后遍历，遇到负数将其变为正数，同时K--
第三步：如果K还⼤于0，那么反复转变数值最⼩的元素，将K⽤完
第四步：求和











### L134. 加油站

[题目](https://leetcode-cn.com/problems/gas-station/)：在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明: 

如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。



**思路1**：贪心。

⾸先如果总油量减去总消耗⼤于等于零那么⼀定可以跑完⼀圈，说明 各个站点的加油站 剩油量
rest[i]相加⼀定是⼤于等于零的。
每个加油站的剩余量rest[i]为gas[i] - cost[i]。 i从0开始累加rest[i]，和记为curSum，⼀旦curSum⼩于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。

如果出现更⼤的负数，就是更新j，那么起始位置⼜变成新的j+1了。
⽽且j之前出现了多少负数，j后⾯就会出现多少正数，因为耗油总和是⼤于零的（前提我们已经确定了⼀定可以跑完全程）。
那么局部最优：当前累加rest[j]的和curSum⼀旦⼩于0，起始位置⾄少要是j+1，因为从j开始⼀定不⾏。全局最优：找到可以跑⼀圈的起始位置。

```C++
 int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
     int curSum = 0;
     int totalSum = 0;
     int start = 0;
     for (int i = 0; i < gas.size(); i++) {
         curSum += gas[i] - cost[i];
         totalSum += gas[i] - cost[i];
         if (curSum < 0) { // 当前累加rest[i]和 curSum⼀旦⼩于0
         	start = i + 1; // 起始位置更新为i+1
         	curSum = 0; // curSum从0开始
         }
     }
     if (totalSum < 0) return -1; // 说明怎么⾛都不可能跑⼀圈了
     return start;
 }
```





**思路2**：从后往前累加比较。

直接从全局进⾏贪⼼选择，情况如下：

情况⼀：如果gas的总和⼩于cost总和，那么⽆论从哪⾥出发，⼀定是跑不了⼀圈的
情况⼆：rest[i] = gas[i]-cost[i]为⼀天剩下的油，i从0开始计算累加到最后⼀站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。
情况三：如果累加的最⼩值是负数，汽⻋就要从⾮0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点。

情况3的意思是，如果从后往前到某个节点node的累加和大于min，则表示从node开始能走到最后。

代码：

```C++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
     int curSum = 0;
     int min = INT_MAX; // 从起点出发，油箱⾥的油量最⼩值
     for (int i = 0; i < gas.size(); i++) {
         int rest = gas[i] - cost[i];
         curSum += rest;
         if (curSum < min) min = curSum;
     }
     if (curSum < 0) return -1; // 情况1
     if (min >= 0) return 0; // 情况2
     // 情况3
     for (int i = gas.size() - 1; i >= 0; i--) {
         int rest = gas[i] - cost[i];
         min += rest;
         if (min >= 0) return i;
     }
     return -1;
 }
```







**思路3**：转换为求最大连续子数组问题。

核心想法：能跑完环路的出发点是 最大连续子数组 的起点。首先将gas数组减去cost数组，求gas数组的最大连续子数组。

过程：

首先gas数组减去cost数组；

然后求最大连续子数组的起点；

最后验证该起点是否能跑完整个环路。

```C++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    const int N = gas.size();
    for(int i=0;i<N;++i) gas[i] -= cost[i];
    int max=0,max_start=0;
    int sum=0,sum_start=0;
    for(int i=0;i<N;++i){
        sum += gas[i];
        if(sum > max){
            max;
            max_start = sum_start;
        }
        else if(sum<0){
            sum=0;
            sum_start = i+1;
        }
    }
    //验证
    int curr_gas=0;
    for(int i=max_start;i<max_start+N;++i){
        curr_gas+=gas[i%N];
        if(curr_gas<0)
            return -1;
    }
    return max_start;
}
```





**思路4**：暴力法（超时）

```C++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    const int N = gas.size();
    for(int i=0;i<N;++i){
        int curr_gas = gas[i];
        curr_gas -= cost[i];
        for(int j=1;j<=N && curr_gas>=0;++j){
            int index = (j+i)%N;
            curr_gas+=gas[index];
            curr_gas-=cost[index];
        }
        if(curr_gas>=0)
            return i;
    }
    return -1;
}
```







### L135. 分发糖果

[题目](https://leetcode-cn.com/problems/candy/)：n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

* 每个孩子至少分配到 1 个糖果。

* 相邻两个孩子评分更高的孩子会获得更多的糖果。

  请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。









### L860. 柠檬水找零

[题目](https://leetcode-cn.com/problems/lemonade-change/)：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。



**思路2**：贪心。遍历一遍，优先使用10元找零。

设置3个变量，分别表示5、10、20美元的数量。

情况⼀：账单是5，直接收下。 

情况⼆：账单是10，消耗⼀个5，增加⼀个10 

情况三：账单是20，优先消耗⼀个10和⼀个5，如果不够，再消耗三个5

```C++
bool lemonadeChange(vector<int>& bills) {
    int num5=0, num10=0,num20=0;
    for(int i=0;i<bills.size();++i){
        if(bills[i]==5){
            ++num5;
        }
        else if(bills[i]==10){
            ++num10;
            --num5;
        }
        else if(bills[i]==20){
            ++num20;
            if(num10!=0){
                --num10;
                --num5;
            }
            else{
                num5-=3;
            }
        }
        if(num5<0)
            return false;
    }
    return true;
}
```







### L406. 根据身高重建队列

[题目]([https://leetcode-cn.com/problems/queue-reconstruction-by-height/)：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。



**思路1**：贪心。

遇到两个维度权衡的时候，⼀定要先确定⼀个维度，再确定另⼀个维度。如果两个维度⼀起考虑⼀定会顾此失彼。
困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还先按照k排序呢？如果按照k来从⼩到⼤排序，排完之后，会发现k的排列并不符合条件，身⾼也不符合条件，两个维度哪⼀个都没确定下来。

​	那么按照身⾼h来排序呢，身⾼⼀定是从⼤到⼩排（身⾼相同的话则k⼩的站前⾯），让⾼个⼦在前⾯。此时我们可以确定⼀个维度了，就是身⾼，前⾯的节点⼀定都⽐本节点⾼！那么只需要按照k为下标重新插⼊队列就可以了

局部最优：优先按身⾼⾼的people的k来插⼊。插⼊操作过后的people满⾜队列属性
全局最优：最后都做完插⼊操作，整个队列满⾜题⽬队列属性

代码：

```C++
 vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
      // 身⾼从⼤到⼩排（身⾼相同k⼩的站前⾯）
    sort (people.begin(), people.end(), [](const vector<int> &a, const vector<int> &b){
        if(a[0]==b[0]) return a[1]<b[1];
        return a[0]>b[0];
    });
    std::list<vector<int>> que; // list底层是链表实现，插⼊效率⽐vector⾼的多
    for (int i = 0; i < people.size(); i++) {
        int position = people[i][1]; // 插⼊到下标为position的位置
        auto it = que.begin();
        while (position--)it++; // 寻找在插⼊位置
        que.insert(it, people[i]);
    }
    return vector<vector<int>>(que.begin(), que.end());
 }
```
















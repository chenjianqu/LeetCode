# 贪心

## 基础知识

什么是贪⼼
贪⼼的本质是选择每⼀阶段的局部最优，从⽽达到全局最优。
这么说有点抽象，来举⼀个例⼦：
例如，有⼀堆钞票，你可以拿⾛⼗张，如果想达到最⼤的⾦额，你要怎么拿？
指定每次拿最⼤的，最终结果就是拿⾛最⼤数额的钱。
每次拿最⼤的就是局部最优，最后拿⾛最⼤数额的钱就是推出全局最优。



贪⼼算法⼀般分为如下四步：
* 将问题分解为若⼲个⼦问题

* 找出适合的贪⼼策略

* 求解每⼀个⼦问题的最优解

* 将局部最优解堆叠成全局最优解  
  
  
  
  其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪⼼的题⽬往往还和其他⽅⾯的知识混在⼀起。



## 题目

### L455. 分发饼干

**题目**：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。



**思路1**：贪心算法。

为了了满⾜更多的⼩孩，就不要造成饼⼲尺⼨的浪费。
⼤尺⼨的饼⼲既可以满⾜胃⼝⼤的孩⼦也可以满⾜胃⼝⼩的孩⼦，那么就应该优先满⾜胃⼝⼤的。
这⾥的局部最优就是⼤饼⼲喂给胃⼝⼤的，充分利⽤饼⼲尺⼨喂饱⼀个，全局最优就是喂饱尽可能多的
⼩孩。
可以尝试使⽤贪⼼策略，先将饼⼲数组和⼩孩数组排序。
然后从后向前遍历⼩孩数组，⽤⼤饼⼲优先满⾜胃⼝⼤的，并统计满⾜⼩孩数量。

```C++
int findContentChildren(vector<int>& g, vector<int>& s) {
    std::sort(g.begin(),g.end());
    std::sort(s.begin(),s.end());
    int num=0;
    for(int gi=g.size()-1,si=s.size()-1;gi>=0 && si>=0;){
        if(s[si]>=g[gi]){
            num++;
            --si;
            --gi;
        }
        else{
            --gi;
        }
    }
    return num;
}
```





### L376. 摆动序列

**题目**：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。



**思路1**：贪心算法。

局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。
整体最优：整个序列有最多的局部峰值，从⽽达到最⻓摆动序列。
局部最优推出全局最优，并举不出反例，那么试试贪⼼！
实际操作上，其实连删除的操作都不⽤做，因为题⽬要求的是最⻓摆动⼦序列的⻓度，所以只需要统计数组的峰值数量就可以了（相当于是删除单⼀坡度上的节点，然后统计⻓度）
这就是贪⼼所贪的地⽅，让峰值尽可能的保持峰值，然后删除单⼀坡度上的节点。

我的代码

```C++
int wiggleMaxLength(vector<int>& nums) {
    if(nums.size()==1) return 1;
    int count=1;
    int last = nums[1]-nums[0];
    if(last!=0) count++;
    for(int i=2;i<nums.size();++i){
        int differ = nums[i]-nums[i-1];
        if(last>0 && differ>=0)
            continue;
        else if(last<0 && differ<=0)
            continue;
        else if(differ==0){
            last = differ;
            continue;
        }
        last = differ;
        count++;
    }
    return count;
}
```

Carl的代码：

```C++
int wiggleMaxLength(vector<int>& nums) { 
    if (nums.size() <= 1) return nums.size();
    int preDiff = 0; // 前⼀对差值
    int result = 1; // 记录峰值个数，序列默认序列最右边有⼀个峰值
    for (int i = 0; i < nums.size() - 1; i++) {
        int curDiff = nums[i + 1] - nums[i];// 当前⼀对差值
        // 出现峰值
        if ((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0)){
            result++;
            preDiff = curDiff;
        }
    }
    return result;
 }
```





### L53. 最大子数组和

**题目**：给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。



**思路1**：贪心。

如果 -2 1 在⼀起，计算起点的时候，⼀定是从1开始计算，因为负数只会拉低总和，这就是贪⼼贪的地⽅！
局部最优：当前“连续和”为负数的时候⽴刻放弃，从下⼀个元素重新计算“连续和”，因为负数加上下⼀个元素 “连续和”只会越来越⼩。
全局最优：选取最⼤“连续和”
局部最优的情况下，并记录最⼤的“连续和”，可以推出全局最优。
从代码⻆度上来讲：遍历nums，从头开始⽤count累积，如果count⼀旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。
这相当于是暴⼒解法中的不断调整最⼤⼦序和区间的起始位置。

```C++
int maxSubArray(vector<int>& nums) {
    //贪心
    int max=INT_MIN;
    int cnt=0;
    for(int i=0;i<nums.size();++i){
        cnt+=nums[i];
        if(cnt>max)
            max=cnt;
        if(cnt<0)
            cnt=0;
    }
    return max;
}
```





**思路2**：动态规划。

1 确定 dp数组 以及 下标含义。

dp[i] 表示第i个数字前的最大连续子数组和

2 递推公式

dp[i] = max(dp[i-1]+dp[i], dp[i])

3 初始化

dp[0] = nums[0]

4 遍历顺序

从左到右

5 举例。

```C++
int maxSubArray(vector<int>& nums) {
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    int result = nums[0];
    for(int i=1;i<nums.size();++i){
        dp[i] = std::max(dp[i-1]+nums[i],nums[i]);
        if(result<dp[i]) 
            result = dp[i];
    }
    return result;
}
```





**思路3**：分治。

```C++
class Solution {
public:
int crossSubArray(vector<int>& arr,int low ,int mid,int high){
    int lsum=INT_MIN;
    int sum=0;
    for(int i=mid;i>=low;--i){
        sum+= arr[i];
        if(sum>lsum)
            lsum = sum;
    }
    int rsum=INT_MIN;
    sum=0;
    for(int i=mid+1;i<=high;++i){
        sum+=arr[i];
        if(sum>rsum)
            rsum=sum;
    }
    return lsum+rsum;
}

int findSubArray(vector<int>& arr,int low,int high){
    if(low==high) return arr[low];
    int mid = (low+high)/2;
    int lsum = findSubArray(arr,low,mid);
    int rsum = findSubArray(arr,mid+1,high);
    int csum = crossSubArray(arr,low,mid,high);
    return std::max(std::max(lsum,rsum),csum);
}
int maxSubArray(vector<int>& nums) {
    int numsSize = int(nums.size());
    int result = findSubArray(nums, 0, numsSize - 1);
    return result;
}
};
```



**思路4**：暴力法。（超时）

```C++
int maxSubArray(vector<int>& nums) {
    //暴力法
    int max=INT_MIN;
    for(int i=0;i<nums.size();++i){
        int cnt=0;
        for(int j=i;j<nums.size();++j){
            cnt+=nums[j];
            if(cnt>max) max=cnt;
        }
    }
    return max;
}
```





### L122. 买卖股票的最佳时机 II

[题目](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)：给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



**思路1**：贪心。

由于可以多次买卖，因此只要尽可能多在股票价格低时买入，在价高时卖出，即可获得最大收益。

局部最优：收集每天的正利润，全局最优：求得最⼤利润

```C++
int maxProfit(vector<int>& prices) {
    int earning=0;
    int start=-1;
    for(int i=0;i<prices.size()-1;++i){
        if(start<0 && prices[i+1]>prices[i]){
            start=i;
        }
        else if(start>=0 && prices[i+1]<prices[i]){
            earning += prices[i]-prices[start];
            start=-1;
        }
    }
    if(start>=0)
        earning += *(prices.end()-1)-prices[start];
    return earning;
}
```



**思路2**：动态规划。



### L55. 跳跃游戏

[题目](https://leetcode-cn.com/problems/jump-game/)：给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。



**思路1**：贪心算法。

刚看到本题⼀开始可能想：当前位置元素如果是3，我究竟是跳⼀步呢，还是两步呢，还是三步呢，究竟跳⼏步才是最优呢？
其实跳⼏步⽆所谓，关键在于可跳的覆盖范围！不⼀定⾮要明确⼀次究竟跳⼏步，每次取最⼤的跳跃步数，这个就是可以跳跃的覆盖范围。这个范围内，别管是怎么跳的，反正⼀定可以跳过来。那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！
每次移动取最⼤跳跃步数（得到最⼤的覆盖范围），每移动⼀个单位，就更新最⼤覆盖范围。
贪⼼算法局部最优解：每次取最⼤跳跃步数（取最⼤覆盖范围），整体最优解：最后得到整体最⼤覆盖范围，看是否能到终点。

代码：

```C++
bool canJump(vector<int>& nums) {
    int cover=0;
    for(int i=0;i<nums.size()-1 && i<=cover;++i){
        if(i+nums[i] > cover)
            cover=(nums[i]+i);
    }
    return cover>=nums.size()-1;
}
```



### L45. 跳跃游戏 II

[题目](https://leetcode-cn.com/problems/jump-game-ii/)：给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。



**思路1**：贪心。
















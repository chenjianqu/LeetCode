# 贪心

## 基础知识

什么是贪⼼
贪⼼的本质是选择每⼀阶段的局部最优，从⽽达到全局最优。
这么说有点抽象，来举⼀个例⼦：
例如，有⼀堆钞票，你可以拿⾛⼗张，如果想达到最⼤的⾦额，你要怎么拿？
指定每次拿最⼤的，最终结果就是拿⾛最⼤数额的钱。
每次拿最⼤的就是局部最优，最后拿⾛最⼤数额的钱就是推出全局最优。



贪⼼算法⼀般分为如下四步：
* 将问题分解为若⼲个⼦问题

* 找出适合的贪⼼策略

* 求解每⼀个⼦问题的最优解

* 将局部最优解堆叠成全局最优解  
  
  
  
  其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪⼼的题⽬往往还和其他⽅⾯的知识混在⼀起。



## 题目

### L455. 分发饼干

**题目**：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。



**思路1**：贪心算法。

为了了满⾜更多的⼩孩，就不要造成饼⼲尺⼨的浪费。
⼤尺⼨的饼⼲既可以满⾜胃⼝⼤的孩⼦也可以满⾜胃⼝⼩的孩⼦，那么就应该优先满⾜胃⼝⼤的。
这⾥的局部最优就是⼤饼⼲喂给胃⼝⼤的，充分利⽤饼⼲尺⼨喂饱⼀个，全局最优就是喂饱尽可能多的
⼩孩。
可以尝试使⽤贪⼼策略，先将饼⼲数组和⼩孩数组排序。
然后从后向前遍历⼩孩数组，⽤⼤饼⼲优先满⾜胃⼝⼤的，并统计满⾜⼩孩数量。

```C++
int findContentChildren(vector<int>& g, vector<int>& s) {
    std::sort(g.begin(),g.end());
    std::sort(s.begin(),s.end());
    int num=0;
    for(int gi=g.size()-1,si=s.size()-1;gi>=0 && si>=0;){
        if(s[si]>=g[gi]){
            num++;
            --si;
            --gi;
        }
        else{
            --gi;
        }
    }
    return num;
}
```





### L376. 摆动序列

**题目**：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。



**思路1**：贪心算法。

局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。
整体最优：整个序列有最多的局部峰值，从⽽达到最⻓摆动序列。
局部最优推出全局最优，并举不出反例，那么试试贪⼼！
实际操作上，其实连删除的操作都不⽤做，因为题⽬要求的是最⻓摆动⼦序列的⻓度，所以只需要统计数组的峰值数量就可以了（相当于是删除单⼀坡度上的节点，然后统计⻓度）
这就是贪⼼所贪的地⽅，让峰值尽可能的保持峰值，然后删除单⼀坡度上的节点。

我的代码

```C++
int wiggleMaxLength(vector<int>& nums) {
    if(nums.size()==1) return 1;
    int count=1;
    int last = nums[1]-nums[0];
    if(last!=0) count++;
    for(int i=2;i<nums.size();++i){
        int differ = nums[i]-nums[i-1];
        if(last>0 && differ>=0)
            continue;
        else if(last<0 && differ<=0)
            continue;
        else if(differ==0){
            last = differ;
            continue;
        }
        last = differ;
        count++;
    }
    return count;
}
```

Carl的代码：

```C++
int wiggleMaxLength(vector<int>& nums) { 
    if (nums.size() <= 1) return nums.size();
    int preDiff = 0; // 前⼀对差值
    int result = 1; // 记录峰值个数，序列默认序列最右边有⼀个峰值
    for (int i = 0; i < nums.size() - 1; i++) {
        int curDiff = nums[i + 1] - nums[i];// 当前⼀对差值
        // 出现峰值
        if ((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0)){
            result++;
            preDiff = curDiff;
        }
    }
    return result;
 }
```





### L53. 最大子数组和

**题目**：给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。



**思路1**：贪心。







**思路2**：动态规划。






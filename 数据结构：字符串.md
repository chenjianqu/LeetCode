# 字符串

## 常见算法



### 有限状态机

确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：

* 有一个特殊的状态，被称作「初始状态」。
* 还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。

起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。

**注意**：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。

一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。

自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。

自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。



### KMP算法

[文章](https://zhuanlan.zhihu.com/p/105629613)

Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(m+n)。

**构造Next数组**：next[i] 对应的下标，为 P[0...i - 1] 的最长*公共前缀后缀*的长度，令 P[0] = -1。 具体解释如下：

例如对于字符串 abcba：

前缀：它的前缀包括：a, ab, abc, abcb，不包括本身；
后缀：它的后缀包括：bcba, cba, ba, a，不包括本身；
最长公共前缀后缀：abcba 的前缀和后缀中只有 a 是公共部分，字符串 a 的长度为 1。
所以，我们将 P[0...i - 1] 的最长公共前后缀的长度作为 next[i] 的下标，就得到了 next 数组。



```C++
int strStr(string haystack, string needle) {
    int n = haystack.size(), m = needle.size();
    if (m == 0)  return 0;
    vector<int> pi(m);///构造Next数组
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && needle[i] != needle[j]) j = pi[j - 1];
        if (needle[i] == needle[j])  j++;
        pi[i] = j;
    }
    for (int i = 0, j = 0; i < n; i++) {
        while (j > 0 && haystack[i] != needle[j])
            j = pi[j - 1];
        if (haystack[i] == needle[j])
            j++;
        if (j == m) 
            return i - m + 1;
    }
    return -1;
}

```



### 字符串数字加法

逐位相加：

```C++
string equal(string a,string b){
    string result;
    std::reverse(a.begin(),a.end());
    std::reverse(b.begin(),b.end());

    int iter_max=max(a.size(),b.size());
    int carry=0;
    for(int i=0;i<iter_max;++i){
        int n1=i<a.size()?(a[i]-'0') : 0;
        int n2=i<b.size()?(b[i]-'0') : 0;
        int sum= n1+n2+carry;
        carry = sum/10;
        sum %= 10;
        result.push_back(sum+'0');
    }
    if(carry>0)
        result.push_back(carry+'0');
    return result
}
```



判断两个字符串相加的结果是否等于第三个字符串：

```C++
/**
    a 数字1，输入数字均是从高位到低位排序
    b 数字2
    c 数字3
    返回值：若a+b==c,返回0;若a+b<c,返回-1;若a+b>c,返回1.
    */
int equal(string a,string b,string c){
    if(c.size()< a.size() || c.size()<b.size())
        return 1;
    string result;
    std::reverse(a.begin(),a.end());
    std::reverse(b.begin(),b.end());

    int iter_max=max(a.size(),b.size());
    int carry=0;
    for(int i=0;i<iter_max;++i){
        int n1=i<a.size()?(a[i]-'0') : 0;
        int n2=i<b.size()?(b[i]-'0') : 0;
        int sum= n1+n2+carry;
        carry = sum/10;
        sum %= 10;
        result.push_back(sum+'0');
    }
    if(carry>0)
        result.push_back(carry+'0');

    //比较两个数
    if(result.size() > c.size()){//说明c的位数小于result的位数，c<result
        return 1;
    }
    else if(result.size() < c.size()){
        return -1;
    }
    else{//位数相等
        std::reverse(result.begin(),result.end());
        for(int i=0;i<c.size();++i){
            if(result[i]>c[i])
                return 1;
            else if(result[i]<c[i])
                return -1;
        }
    }
    return 0;
}
```









## 题目









## 翻转字符串

### L344. 反转字符串

**题目**：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**思路**：遍历法，使用双指针。

```C++
void reverseString(vector<char>& s) {
	for(int i=0;i<s.size()/2;++i) 
        std::swap(s[i],s[s.size()-i-1]);
}
```



### L541. 反转字符串II

**[题目]( [541. 反转字符串 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/reverse-string-ii/) )**：给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

```
示例 1：
输入：s = "abcdefg", k = 2
输出："bacdfeg"

示例 2：
输入：s = "abcd", k = 2
输出："bacd"
```


提示：

1 <= s.length <= 104
s 仅由小写英文组成
1 <= k <= 104



**思路1**：递增子区间。

遍历时，递增区间长度k，而不是1。

设置一个bool变量来控制是否进行反转。

```C++
string reverseStr(string s, int k) {
    int N=s.size();
    string output(N,' ');
    bool reverse=true;
    for(int start=0;start<N;start+=k){
        int M = std::min(k,N-start);
        for(int i=0;i<M;++i){
            if(reverse){
                output[start+i] = s[start+M-i-1];
            }
            else{
                output[start+i] = s[start+i];
            }                
        }
        reverse = !reverse;
    }
    return output;
}
```



**思路2**：调用库函数进行反转。

```C++
string reverseStr(string s, int k) {
    int n = s.length();
    for (int i = 0; i < n; i += 2 * k) {
        reverse(s.begin() + i, s.begin() + min(i + k, n));
    }
    return s;
}
```







### L151. 翻转字符串里的单词 & J58. 翻转单词顺序 I

**题目**：给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。

```C++
输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
```

**思路1**：单层遍历法。这种方法需要额外的字符串。空间复杂度为(n)。从后往前遍历输入字符串，当遇到空格时，将刚刚经过的字符串添加到输出字符串。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    //翻转单词
    int n=s.size();
    string out,tmp;
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' ' && s[i]==s[i+1] )//去除重复的字符串
            continue;
        if(s[i]==' '){
            out += s.substr(i+1,len);
            out+=" ";//补上空格
            len=0;
            continue;
        }
        else if(i==0){
            out += s.substr(i,len+1);//由于最后一次结束没到' '，因此len需要补上1
        }
        len++;
    }
    return out;
}
```

另一个实现：

```C++
string reverseWords(string s) {
    string result;
    int flag=0;
    int end=s.size()-1;
    for(int i=s.size()-1;i>=0;--i){
        if(flag==0 && s[i]!=' '){
            end=i;
            flag=1;
        }
        else if(flag==1 && s[i]==' '){
            result += s.substr(i+1,end-i)+" ";
            flag=0;
        }
    }
    if(s[0]!=' ')//可能还有最后一段
        result += s.substr(0,end-0+1);
    else//如果没有的话，去掉最后一个空格
        result.pop_back();
    return result;
}
```







**思路2**：先翻转整个字符串，再逐个翻转单词。时间复杂度O(n)，空间复杂度O(1)。



**思路3**：使用队列，队列具有先进先出的特性，在遍历字符串时从后往前，将每个单词入到队列中。最后将队列中的单词串联成输出字符串。时间复杂度:O(n)，空间复杂度O(n)。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    int n=s.size();
    std::queue<string> q;
    //从后往前遍历字符串，将单词放入队列中。
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' '){
            if(s[i]==s[i+1])//去除连续空格
                continue;
            else
                q.push(s.substr(i+1,len));
            len=0;
            continue;
        }
        else if(i==0){
            q.push(s.substr(0,len+1));
        }
        len++;
    }
    //将队列中的单词串联成输出字符串。
    int qsize=q.size();;
    string out;
    for(int i=0;i<qsize;++i){
        out += q.front();
        if(i!=qsize-1)out+=" ";
        q.pop();
    }
    return out;
}
```





### J58. 左旋转字符串 II

**[题目](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)**：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

 ```
示例 1：
输入: s = "abcdefg", k = 2
输出: "cdefgab"

示例 2：
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
 ```


限制：

1 <= k < s.length <= 10000



**思路1**：直接拼接子字符串。

```C++
string reverseLeftWords(string s, int n) {
    return s.substr(n,s.size()-n) + s.substr(0,n);
}
```

时间复杂度 O(N) ： 其中 N 为字符串 s 的长度，字符串切片函数为线性时间复杂度（参考资料）；
空间复杂度 O(N) ： 两个字符串切片的总长度为 N 。



**思路2**：将前k个字符插入字符串，然后将前k个删除即可。

```C++
string reverseLeftWords(string s, int n) {
    for(int i=0;i<n;i++)
        s.push_back(s[i]);
    s.erase(0,n);
    return s;
}
```





## 子字符串



### L14. 最长公共前缀

**题目**：编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

 ```C++
示例 1：
输入：strs = ["flower","flow","flight"]
输出："fl"
 ```

**思路1**：纵向扫描。双重循环，外层循环从左往右遍历字符，内层循环从左往右遍历字符串，比较每个字符串在相同位置上是否拥有相同的元素。

```C++
string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty())
            return "";
        string output;
        for(int i=0;i<strs[0].size();++i){
            bool flag=true;
            char c = strs[0][i];
            for(int j=1;j<strs.size();++j){
                if(strs[j][i]!=c){
                    flag=false;
                    break;
                }
            }
            if(flag) output.push_back(c);
            else break;
        }
        return output;
    }
```



**思路2**：横向扫描。 依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。 

```
string longestCommonPrefix(vector<string>& strs) {
	if (!strs.size()) return "";
	string prefix = strs[0];
	int count = strs.size();
    for (int i = 1; i < count; ++i) {
        prefix = longestCommonPrefix(prefix, strs[i]);
        if (!prefix.size()) break;
    }
    return prefix;
}

string longestCommonPrefix(const string& str1, const string& str2) {
    int length = min(str1.size(), str2.size());
    int index = 0;
    while (index < length && str1[index] == str2[index])
	    ++index;
    return str1.substr(0, index);
}

```

**思路3**：分治法。

注意到  $\textit{LCP}$ 的计算满足结合律，有以下结论：

$$
\textit{LCP}(S_1 \ldots S_n) 
\\ = \textit{LCP}(\textit{LCP}(S_1 \ldots S_k), \textit{LCP} (S_{k+1} \ldots S_n))
$$
其中 ${LCP}(S_1 \ldots S_n)$ 是字符串$S_1 \ldots S_n$的最长公共前缀。基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题 ${LCP}(S_i \ldots S_j)$，可以分解成两个子问题 ${LCP}(S_i \ldots S_{mid})$和${LCP}(S_{mid+1} \ldots S_j)$，其中 $mid=\frac{i+1}{2}$。

**思路4**：二分查找。

显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用minLength 表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值mid，判断每个字符串的长度为mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于mid，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。



### L28. 实现strStr()

**[题目](https://leetcode-cn.com/problems/implement-strstr/)**：给实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。



**思路1**：这是一道典型的KMP问题。

```C++
 int strStr(string haystack, string needle) {
        if(needle.empty())
            return 0;
        if(haystack.size()<needle.size() )
            return -1;
        vector<int> arr(needle.size());
        for(int i=1,j=0;i<needle.size();++i){
            while(j>0 && needle[i]!=needle[j])
                j = arr[j-1];//回溯
            if(needle[i]==needle[j])
                j++;
            arr[i]=j;
        }
        for(int i=0,j=0;i<haystack.size();++i){
            while(j>0 && haystack[i]!=needle[j])
                j=arr[j-1];
            if(haystack[i]==needle[j])
                j++;
            if(j==needle.size())
                return i-needle.size()+1;
        }
        
        return -1;
    }
```





### L3. 无重复字符的最长子串 & J48. 最长不含重复字符的子字符串

**[题目](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)**：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

 ```
示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

示例 4:
输入: s = ""
输出: 0
 ```


提示：

0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成



**思路1**：滑动窗口。

我们先用一个例子考虑如何在较优的时间复杂度内通过本题。

我们不妨以示例一中的字符串 `abcabcbb` 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：

以 `(a)bcabcbb` 开始的最长字符串为 `(abc)abcbb`；
以 `a(b)cabcbb` 开始的最长字符串为 `a(bca)bcbb`；
以 `ab(c)abcbb` 开始的最长字符串为 `ab(cab)cbb`；
以 `abc(a)bcbb` 开始的最长字符串为 `abc(abc)bb`；
以 `abca(b)cbb` 开始的最长字符串为 `abca(bc)bb`；
以 `abcab(c)bb` 开始的最长字符串为 `abcab(cb)b`；
以 `abcabc(b)b` 开始的最长字符串为 `abcabc(b)b`；
以 `abcabcb(b)` 开始的最长字符串为 `abcabcb(b)`。
发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 r_k 。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 r_k 的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 r_k ，直到右侧出现了重复字符为止。

这样一来，我们就可以使用「滑动窗口」来解决这个问题了：

我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 r_k；

在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；

在枚举结束后，我们找到的最长的子串的长度即为答案。

判断重复字符

在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 C++ 中的 `std::unordered_set`，Java 中的 `HashSet`，Python 中的 `set`, JavaScript 中的 `Set`）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。

至此，我们就完美解决了本题。

```C++
int lengthOfLongestSubstring(string s) {
    // 哈希集合，记录每个字符是否出现过
    unordered_set<char> occ;
    int n = s.size();
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    int rk = -1, ans = 0;
    // 枚举左指针的位置，初始值隐性地表示为 -1
    for (int i = 0; i < n; ++i) {
        if (i != 0) {
            // 左指针向右移动一格，移除一个字符
            occ.erase(s[i - 1]);
        }
        while (rk + 1 < n && !occ.count(s[rk + 1])) {
            // 不断地移动右指针
            occ.insert(s[rk + 1]);
            ++rk;
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk - i + 1);
    }
    return ans;
}
```



我的代码：

```C++
int lengthOfLongestSubstring(string s) {
    std::unordered_set<char> hash_set;
    int left=0, right=0;//滑动窗口的标号
    int ans=0;
    while(right<s.size()){
        while(right < s.size() && hash_set.find(s[right])==hash_set.end()){//滑动窗口右边扩展
            hash_set.insert(s[right]);
            ++right;
        }
        if(hash_set.size() > ans)
            ans = hash_set.size();
        //滑动窗口左边移动
        hash_set.erase(s[left]);
        left++;
    }
    return ans;
}
```



## 字符串转换

###  C01.03. URL化

[题目](https://leetcode-cn.com/problems/string-to-url-lcci/)：URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）

```
示例 1：
输入："Mr John Smith    ", 13
输出："Mr%20John%20Smith"

示例 2：
输入："               ", 5
输出："%20%20%20%20%20"
```


提示：

字符串长度在 [0, 500000] 范围内。



**思路1**：直接转换。

```C++
string replaceSpaces(string S, int length) {
    string output;
    output.reserve(length);
    for(int i=0;i<length;++i){
        if(S[i]==' ')
            output += "%20";
        else
            output.push_back(S[i]);
    }
    return output;
}
```





### L205. 同构字符串

**题目**：给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

```
输入：s = "egg", t = "add"
输出：true

输入：s = "foo", t = "bar"
输出：false

输入：s = "paper", t = "title"
输出：true
```

**思路1**：用哈希表。由于要求“不同字符不能映射到同一个字符上”，因此需要两个哈希表，一个用来将s映射到t，另一个用来将t映射到s。

```C++
bool isIsomorphic(string s, string t) {
    if(s.size()!=t.size())
        return false;
    std::unordered_map<char,char> hash_map;
    std::unordered_map<char,char> value_map;
    for(int i=0;i<s.size();++i){
        bool find_s = hash_map.find(s[i])!=hash_map.end();
        if(!find_s){
            if(value_map.find(t[i])!=value_map.end())//题目要求不同字符不能映射到同一个字符
                return false;
            hash_map.insert({s[i],t[i]});
            value_map.insert({t[i],s[i]});
        }
        else if(hash_map[s[i]]!=t[i])
                return false;
    }
    return true;
}
```



### C01.02. 判定是否互为字符重排

给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

```
示例 1：
输入: s1 = "abc", s2 = "bca"
输出: true 

示例 2：
输入: s1 = "abc", s2 = "bad"
输出: false
```

说明：

0 <= len(s1) <= 100
0 <= len(s2) <= 100



**思路1**：使用数组统计字符出现的次数。

使用哈希表或数组统计第一个字符串所有字符串的出现次数，根据这个次数判断两个字符串是否包含同样的字符。

```C++
bool CheckPermutation(string s1, string s2) {
    //判断两个字符串是否拥有共同的字符
    vector<int> counter(52);
    for(char c:s1){
        if(c<='Z')
            counter[c-'A'+26]++;
        else
            counter[c-'a']++;
    }
    for(char c:s2){
        if(c<='Z')
            counter[c-'A'+26]--;
        else
            counter[c-'a']--;
    }
    for(int i:counter){
        if(i!=0)
            return false;
    }
    return true;
}
```



**思路2**：先排序，然后再看两个字符串是否相等。





### L383. 赎金信

**[题目](https://leetcode-cn.com/problems/ransom-note/)**：给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

```
示例 1：
输入：ransomNote = "a", magazine = "b"
输出：false

例 2：
输入：ransomNote = "aa", magazine = "ab"
输出：false

示例 3：
输入：ransomNote = "aa", magazine = "aab"
输出：true
```


提示:

1 <= ransomNote.length, magazine.length <= 10^5
ransomNote 和 magazine 由小写英文字母组成



**思路1**：使用哈希集合。

```C++
bool canConstruct(string ransomNote, string magazine) {
    //用哈希集合
    unordered_multiset<char> mag_set;
    for(char c: magazine){
        mag_set.insert(c);
    }
    ///判断ransomNote中的字符是否存在
    bool exist=true;
    for(char c:ransomNote){
        auto it=mag_set.find(c);
        if(it==mag_set.end()){
            exist=false;
            break;
        }
        else{
            mag_set.erase(it);//将集合中的元素删除
        }
    }
    return exist;
}
```



**思路2**：使用数组代替哈希集合，来统计出现字符的次数。

```C++
bool canConstruct(string ransomNote, string magazine) {
    vector<int> ascii_cnt(128);
    for(char c:magazine){
        ascii_cnt[c]++;
    }
    for(char c:ransomNote){
        if(ascii_cnt[c]<=0){
            return false;
        }
        ascii_cnt[c]--;
    }
    return true;
}
```







### C01.04. 回文排列

**[题目](https://leetcode-cn.com/problems/palindrome-permutation-lcci/)**：给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。

回文串不一定是字典当中的单词。

```
示例1：
输入："tactcoa"
输出：true（排列有"tacocat"、"atcocta"，等等）
```



**思路1**：统计字符出现的次数。

回文数中每个字符出现的次数最多有一个奇数次。

```C++
bool canPermutePalindrome(string s) {
    vector<int> cnt(128);
    for(char c:s)
        cnt[c]++;
    int odd_cnt=0;
    for(int n:cnt)
        odd_cnt += (n%2);
    return odd_cnt<=1;
}
```





### L49. 字母异位词分组

**[题目]( https://leetcode-cn.com/problems/group-anagrams/) **：给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

```
示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

示例 2:
输入: strs = [""]
输出: [[""]]

示例 3:
输入: strs = ["a"]
输出: [["a"]]
```


提示：

1 <= strs.length <= 104
0 <= strs[i].length <= 100
strs[i] 仅包含小写字母



**思路1**：暴力法。

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        auto isSame = [](string &s,string &m){
            int N=s.size();
            int cnt=0;
            for(int i=0;i<N;++i){
                for(int j=0;j<N;++j){
                    if(s[i]==m[j]){
                        cnt++;
                        m[j]=0;
                        break;
                    }
                }
            }
            return cnt == N;
        };

        //暴力法
        /**
        group[i]表示 长度为i的所有组
        */
        vector<vector<vector<string>>> group(100);
        for(string &s : strs){
            int N = s.size();
            bool inserted=false;
            //寻找是否有合适的组
            for(auto &g : group[N]){//从长度为N的组中寻找是否有异构组
                if(g.empty()) continue;
                string tmp = g[0];
                if(isSame(s,tmp)){
                    g.push_back(s);
                    inserted =true;
                    break;
                }
            }
            ///创建新的组
            if(!inserted){
                vector<string> tmp;
                tmp.push_back(s);
                group[N].push_back(tmp);
            }
        }
        ///输出
        vector<vector<string>> output;
        for(auto &ng : group){
            output.insert(output.end(), ng.begin(), ng.end());
        }
        return output;
    }
};
```



**思路2**：排序+哈希映射。

两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。

遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。

以下的两种方法分别使用排序和计数作为哈希表的键。

**1.排序**

由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;
        for (string& str: strs) {
            string key = str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        }
        vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }
        return ans;
    }
};
```

复杂度分析

时间复杂度：O(nklogk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要 O(klogk) 的时间进行排序以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(nklogk)。

空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。



**2.计数**

由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。

由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 自定义对 array<int, 26> 类型的哈希函数
        auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t {
            return accumulate(arr.begin(), arr.end(), 0u, [&](size_t acc, int num) {
                return (acc << 1) ^ fn(num);
            });
        };

        unordered_map<array<int, 26>, vector<string>, decltype(arrayHash)> mp(0, arrayHash);
        for (string& str: strs) {
            array<int, 26> counts{};
            int length = str.length();
            for (int i = 0; i < length; ++i)
                counts[str[i] - 'a'] ++;
            mp[counts].emplace_back(str);
        }
        vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }
        return ans;
    }
};
```

复杂度分析

时间复杂度：O(n(k+|\Sigma|))O(n(k+∣Σ∣))，其中 nn 是 \textit{strs}strs 中的字符串的数量，kk 是 \textit{strs}strs 中的字符串的的最大长度，\SigmaΣ 是字符集，在本题中字符集为所有小写字母，|\Sigma|=26∣Σ∣=26。需要遍历 nn 个字符串，对于每个字符串，需要 O(k)O(k) 的时间计算每个字母出现的次数，O(|\Sigma|)O(∣Σ∣) 的时间生成哈希表的键，以及 O(1)O(1) 的时间更新哈希表，因此总时间复杂度是 O(n(k+|\Sigma|))O(n(k+∣Σ∣))。

空间复杂度：O(n(k+|\Sigma|))O(n(k+∣Σ∣))，其中 nn 是 \textit{strs}strs 中的字符串的数量，kk 是 \textit{strs}strs 中的字符串的最大长度，\SigmaΣ 是字符集，在本题中字符集为所有小写字母，|\Sigma|=26∣Σ∣=26。需要用哈希表存储全部字符串，而记录每个字符串中每个字母出现次数的数组需要的空间为 O(|\Sigma|)O(∣Σ∣)，在渐进意义下小于 O(n(k+|\Sigma|))O(n(k+∣Σ∣))，可以忽略不计。







### J20. 表示数值的字符串

**[题目](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)**：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。

**数值**（按顺序）可以分成以下几个部分：

* 若干空格
* 一个 小数 或者 整数
* （可选）一个 'e' 或 'E' ，后面跟着一个 整数
* 若干空格

**小数**（按顺序）可以分成以下几个部分：

* （可选）一个符号字符（'+' 或 '-'）

* 下述格式之一：

  * 至少一位数字，后面跟着一个点 '.'
  * 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
  * 一个点 '.' ，后面跟着至少一位数字

**整数**（按顺序）可以分成以下几个部分：

* （可选）一个符号字符（'+' 或 '-'）

* 至少一位数字

例子：

  部分数值列举如下：`["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"]`
  部分非数值列举如下：`["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"]`

```
示例 1：
输入：s = "0"
输出：true

示例 2：
输入：s = "e"
输出：false

示例 3：
输入：s = "."
输出：false

示例 4：
输入：s = "    .1  "
输出：true
```


提示：

1 <= s.length <= 20
s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，空格 ' ' 或者点 '.' 。



**思路1**：确定有限状态机。

**问题描述**

在 C++ 文档 中，描述了一个合法的数值字符串应当具有的格式。具体而言，它包含以下部分：

* 符号位，即 +、− 两种符号
* 整数部分，即由若干字符 0-90−9 组成的字符串
* 小数点
* 小数部分，其构成与整数部分相同
* 指数部分，其中包含开头的字符 \text{e}e（大写小写均可）、可选的符号位，和整数部分

相比于 C++ 文档而言，本题还有一点额外的不同，即允许字符串首末两端有一些额外的空格。

在上面描述的五个部分中，每个部分都不是必需的，但也受一些额外规则的制约，如：

* 如果符号位存在，其后面必须跟着数字或小数点。
* 小数点的前后两侧，至少有一侧是数字。

**思路与算法**

根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：

* 起始的空格
* 符号位
* 整数部分
* 左侧有整数的小数点
* 左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）
* 小数部分
* 字符 e
* 指数部分的符号位
* 指数部分的整数部分
* 末尾的空格

  下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 1，而「接受状态」的集合则为状态 3、状态 4、状态 6、状态 9 以及状态 10。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。

  最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来：

![](https://assets.leetcode-cn.com/solution-static/jianzhi_20/jianzhi_20_fig1.png)

比较上图与「预备知识」一节中对自动机的描述，可以看出有一点不同：

我们没有单独地考虑每种字符，而是划分为若干类。由于全部 1010 个数字字符彼此之间都等价，因此只需定义一种统一的「数字」类型即可。对于正负号也是同理。
在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。

代码：

```C++
class Solution {
private:
    enum State {
        STATE_INITIAL,
        STATE_INT_SIGN,
        STATE_INTEGER,
        STATE_POINT,
        STATE_POINT_WITHOUT_INT,
        STATE_FRACTION,
        STATE_EXP,
        STATE_EXP_SIGN,
        STATE_EXP_NUMBER,
        STATE_END
    };
    enum CharType {
        CHAR_NUMBER,
        CHAR_EXP,
        CHAR_POINT,
        CHAR_SIGN,
        CHAR_SPACE,
        CHAR_ILLEGAL
    };

    CharType toCharType(char ch) {
        if (ch >= '0' && ch <= '9') {
            return CHAR_NUMBER;
        } else if (ch == 'e' || ch == 'E') {
            return CHAR_EXP;
        } else if (ch == '.') {
            return CHAR_POINT;
        } else if (ch == '+' || ch == '-') {
            return CHAR_SIGN;
        } else if (ch == ' ') {
            return CHAR_SPACE;
        } else {
            return CHAR_ILLEGAL;
        }
    }
    
    std::unordered_map<State, std::unordered_map<CharType, State>> transfer{
            {
                STATE_INITIAL, {
                    {CHAR_SPACE, STATE_INITIAL},
                    {CHAR_NUMBER, STATE_INTEGER},
                    {CHAR_POINT, STATE_POINT_WITHOUT_INT},
                    {CHAR_SIGN, STATE_INT_SIGN}
                }
            }, {
                STATE_INT_SIGN, {
                    {CHAR_NUMBER, STATE_INTEGER},
                    {CHAR_POINT, STATE_POINT_WITHOUT_INT}
                }
            }, {
                STATE_INTEGER, {
                    {CHAR_NUMBER, STATE_INTEGER},
                    {CHAR_EXP, STATE_EXP},
                    {CHAR_POINT, STATE_POINT},
                    {CHAR_SPACE, STATE_END}
                }
            }, {
                STATE_POINT, {
                    {CHAR_NUMBER, STATE_FRACTION},
                    {CHAR_EXP, STATE_EXP},
                    {CHAR_SPACE, STATE_END}
                }
            }, {
                STATE_POINT_WITHOUT_INT, {
                    {CHAR_NUMBER, STATE_FRACTION}
                }
            }, {
                STATE_FRACTION,
                {
                    {CHAR_NUMBER, STATE_FRACTION},
                    {CHAR_EXP, STATE_EXP},
                    {CHAR_SPACE, STATE_END}
                }
            }, {
                STATE_EXP,
                {
                    {CHAR_NUMBER, STATE_EXP_NUMBER},
                    {CHAR_SIGN, STATE_EXP_SIGN}
                }
            }, {
                STATE_EXP_SIGN, {
                    {CHAR_NUMBER, STATE_EXP_NUMBER}
                }
            }, {
                STATE_EXP_NUMBER, {
                    {CHAR_NUMBER, STATE_EXP_NUMBER},
                    {CHAR_SPACE, STATE_END}
                }
            }, {
                STATE_END, {
                    {CHAR_SPACE, STATE_END}
                }
            }
        };
    
public:
    bool isNumber(string s) {
        int len = s.length();
        State st = STATE_INITIAL;

        for (int i = 0; i < len; i++) {
            CharType typ = toCharType(s[i]);
            if (transfer[st].find(typ) == transfer[st].end()) {
                return false;
            } else {
                st = transfer[st][typ];
            }
        }
        return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;
    }
};
```







**思路2**：剑指Offer的实现

**分析**：表示数值的字符串遵循模式`A[.[B]][e|EC]`或者`.B[e|EC]`，其中A为数值的整数部分，B紧跟着小数点为数值的小数部分，C紧跟着`'e'`或者`'E'`为数值的指数部分。在小数里可能没有数值的整数部分。例如，小数.123等于0.123。因此A 部分不是必需的。如果一个数没有整数部分，那么它的小数部分不能为空。上述`A`和`C`都是可能以`'+'`或者`'-'`开头的`0～9`的数位串; `B`也是`0～9`的数位串，但前面不能有正负号。

​	以表示数值的字符串`"123.45e+6"`为例，`"123"`是它的整数部分A，`"45"`是它的小数部分B，`"+6"`是它的指数部分C。

​	判断一个字符串是否符合上述模式时，首先尽可能多地扫描0~9的数位（有可能在起始处有`'+'`或者`'-'`），也就是前面模式中表示数值整数的 A部分。如果遇到小数点，则开始扫描表示数值小数部分的 B部分。如果遇到`'e'`或者`'E'`，则开始扫描表示数值指数的C部分。

```C++
class Solution {
private:
    // 整数的格式可以用[+|-]B表示, 其中B为无符号整数
    bool scanInteger(const string s, int& index){
        if(s[index] == '+' || s[index] == '-')
            ++index;
        return scanUnsignedInteger(s, index);
    }
    
    bool scanUnsignedInteger(const string s, int& index){
        int befor = index;
        while(index != s.size() && s[index] >= '0' && s[index] <= '9')
            index ++;
        return index > befor;
    }
    
public:
    // 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，
    // 其中A和C都是整数（可以有正负号，也可以没有），而B是一个无符号整数
    bool isNumber(string s) {
        if(s.size() == 0)
            return false;
        int index = 0;
        while(s[index] == ' ')++index; //字符串开始有空格，可以返回true
        bool numeric = scanInteger(s, index);
        // 如果出现'.'，接下来是数字的小数部分
        if(s[index] == '.'){
            ++index;
            // 下面一行代码用||的原因：
            // 1. 小数可以没有整数部分，例如.123等于0.123；
            // 2. 小数点后面可以没有数字，例如233.等于233.0；
            // 3. 当然小数点前面和后面可以有数字，例如233.666
            numeric = scanUnsignedInteger(s, index) || numeric;
        }

        // 如果出现'e'或者'E'，接下来跟着的是数字的指数部分
        if(s[index] == 'e' || s[index] == 'E'){
            ++index;
            // 下面一行代码用&&的原因：
            // 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；
            // 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4
            numeric = numeric && scanInteger(s ,index);
        }
        //字符串结尾有空格，可以返回true
        while(s[index] == ' ')
            ++index;
        return numeric && index == s.size();
    }
};
```





### J46. 把数字翻译成字符串

**[题目](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)**：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

```
示例 1:
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

提示：

0 <= num < 2^31



**分析**：

`[1,4,02]`，这种情况也是不合法的，含有前导零的两位数不在题目规定的翻译规则中，那么 `[14,02]` 显然也是不合法的。 

**思路1**：动态规划。

题目是求多少种方法，而不是求出所有的方法。前者可以用动态规划，后者可以用回溯。

1. 确定dp数组（dp table）以及下标的含义 

   `dp[i]`表示对于前i个位数，有多少种方法

2. 确定递推公式 

   递推公式要根据前两个字母的情况来判断的：

   如果前一个字母是( '1') 或 ('2'且 当前字母<='5')，则有`dp[i] = dp[i-1] + dp[i-2];`；否则`dp[i] = dp[i-1]`。

```C++
if(s[i-2]=='1' || (s[i-2]=='2' && s[i-1]<='5'))
    dp[i] = dp[i-1] + dp[i-2];
else
    dp[i] = dp[i-1];
```

3. dp数组如何初始化 

   dp[0]=1，无意义。

   dp[1]=1，第一个字母只有一种方法。

4. 确定遍历顺序 

   从前往后。

5. 举例推导dp数组

```C++
int translateNum(int num) {
    string s = std::to_string(num);
    vector<int> dp(s.size()+1);//dp[i]表示对于前i个位数，有多少种方法
    dp[0]=1;
    dp[1]=1;
    for(int i=2;i<=s.size();++i){
        if(s[i-2]=='1' || (s[i-2]=='2' && s[i-1]<='5'))//注意，对s来说，下标应该从1开始，因此这里比标砖的遍历少1
            dp[i] = dp[i-1] + dp[i-2];
        else
            dp[i] = dp[i-1];
    }
    return *(dp.end()-1);
}
```



**思路2**：动态规划-滚动数组。

首先我们来通过一个例子理解一下这里「翻译」的过程：我们来尝试翻译「1402」。

分成两种情况：

首先我们可以把每一位单独翻译，即 `[1, 4, 0, 2]`，翻译的结果是 `beac`
然后我们考虑组合某些连续的两位：

* [`14, 0, 2]`，翻译的结果是 `oac`。
* `[1,40,2]`，这种情况是不合法的，因为 40 不能翻译成任何字母。
* `[1,4,02]`，这种情况也是不合法的，含有前导零的两位数不在题目规定的翻译规则中，那么 `[14,02]` 显然也是不合法的。

那么我们可以归纳出翻译的规则，字符串的第 i 位置：

* 可以单独作为一位来翻译
* 如果第 i - 1 位和第 i 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译

​	到这里，我们发现它和「198. 打家劫舍」非常相似。我们可以用 f(i) 表示以第 i 位结尾的前缀串翻译的方案数，考虑第 i 位单独翻译和与前一位连接起来再翻译对 f(i) 的贡献。单独翻译对 f(i) 的贡献为 f(i−1)；如果第 i−1 位存在，并且第 i−1 位和第 i 位形成的数字 x 满足 10≤x≤25，那么就可以把第 i−1 位和第 i 位连起来一起翻译，对 f(i) 的贡献为 f(i−2)，否则为 0。我们可以列出这样的动态规划转移方程：

`f(i)=f(i−1)+f(i−2)[i−1≥0,10≤x≤25]`

边界条件是 `f(−1)=0`，`f(0) = 1`。方程中 `[c]` 的意思是 c 为真的时候 `[c] = 1`，否则 `[c] = 0`。

有了这个方程我们不难给出一个时间复杂度为 O(n)，空间复杂度为 O(n) 的实现。考虑优化空间复杂度：这里的 f(i) 只和它的前两项 f(i−1) 和 f(i−2) 相关，我们可以运用「滚动数组」思想把 f 数组压缩成三个变量，这样空间复杂度就变成了 O(1)。

```C++
int translateNum(int num) {
    string src = to_string(num);
    int p = 0, q = 0, r = 1;
    for (int i = 0; i < src.size(); ++i) {
        p = q; 
        q = r; 
        r = 0;
        r += q;
        if (i == 0) {
            continue;
        }
        auto pre = src.substr(i - 1, 2);
        if (pre <= "25" && pre >= "10") {
            r += p;
        }
    }
    return r;
}
```



## 括号

### L20. 有效的括号

**[题目]( [20. 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/valid-parentheses/) )**：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

  左括号必须用相同类型的右括号闭合。
  左括号必须以正确的顺序闭合。

```
示例 1：
输入：s = "()"
输出：true

示例 2：
输入：s = "()[]{}"
输出：true

示例 3：
输入：s = "(]"
输出：false

示例 4：
输入：s = "([)]"
输出：false

示例 5：
输入：s = "{[]}"
输出：true
```


提示：

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成



**思路1**：用栈保存前面的括号。

判断括号的有效性可以使用「栈」这一数据结构来解决。

我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。

当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。

在遍历结束后，如果栈中没有左括号，说明我们将字符串 ss 中的所有左括号闭合，返回 True，否则返回 False。

注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。

```C++
bool isValid(string s) {
	if (n % 2 == 1) 
        return false;
    std::stack<char> bracket;
    std::map<char,char> bracket_map={{')','('},{']','['},{'}','{'}};
    for(char c:s){
        if(c=='(' || c=='{' || c=='['){
            bracket.push(c);
        }
        else{
            if(bracket.empty() || bracket.top()!=bracket_map[c])
                return false;
            bracket.pop();
        }
    }
    if(bracket.empty())
        return true;
    else
        return false;
}
```





### L22. 括号生成

 **[题目](https://leetcode-cn.com/problems/generate-parentheses/)** ：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

 ```
示例 1：
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]

示例 2：
输入：n = 1
输出：["()"]
 ```


提示：

1 <= n <= 8



**思路1**：回溯。

将"()"插入到所有 可能的位置，使用集合去重。

```C++
class Solution {
private:
    unordered_set<string> hash_set;
    string path;
    /**
    index: 从0开始计数的索引
    */
    void backtrack(int index,int n){
        if(index==n){
            hash_set.insert(path);
            return ;
        }
        int len = path.size();
        string prev_path = path;
        for(int i=0;i<=len;++i){
            path = prev_path;
            path.insert(i,"()");
            backtrack(index+1 , n);
        }
    }

public:
    vector<string> generateParenthesis(int n) {
        backtrack(0,n);
        return vector<string>(hash_set.begin(),hash_set.end());
    }
};
```



官方解法：回溯。

我们可以只在序列仍然保持有效时才添加 '(' or ')'，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，

如果左括号数量不大于 nn，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。

```C++
class Solution {
    void backtrack(vector<string>& ans, string& cur, int open, int close, int n) {
        if (cur.size() == n * 2) {
            ans.push_back(cur);
            return;
        }
        if (open < n) {
            cur.push_back('(');
            backtrack(ans, cur, open + 1, close, n);
            cur.pop_back();
        }
        if (close < open) {
            cur.push_back(')');
            backtrack(ans, cur, open, close + 1, n);
            cur.pop_back();
        }
    }
public:
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        string current;
        backtrack(result, current, 0, 0, n);
        return result;
    }
};
```

我们的复杂度分析依赖于理解 generateParenthesis(n) 中有多少个元素。这个分析超出了本文的范畴，但事实证明这是第 n 个卡特兰数 $\dfrac{1}{n+1}\dbinom{2n}{n} $，这是由 $\dfrac{4^n}{n\sqrt{n}} $渐近界定的。

时间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$，在回溯过程中，每个答案需要 O(n) 的时间复制到答案数组中。

空间复杂度：O(n)，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 O(1) 的空间，最多递归 2n 层，因此空间复杂度为 O(n)。



### L32.最长有效括号

**[题目](https://leetcode-cn.com/problems/longest-valid-parentheses/)**：给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

```
示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"

示例 2：
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"

示例 3：
输入：s = ""
输出：0
```


提示：

0 <= s.length <= 3 * 104
s[i] 为 '(' 或 ')'









## 其它字符串题目





### J50. 第一个只出现一次的字符

**[题目](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)**：在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

```
示例 1:
输入：s = "abaccdeff"
输出：'b'

示例 2:
输入：s = "" 
输出：' '
```


限制：

0 <= s 的长度 <= 50000



**思路1**：哈希表，存储频次。

我们可以对字符串进行两次遍历。

在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回该字符，否则在遍历结束后返回空格。

```C++
char firstUniqChar(string s) {
    //哈希表
    vector<int> hash_vec(26);
    vector<char> sequence;
    for(auto c : s){
        if(hash_vec[c-'a']==0)
            sequence.push_back(c);
        hash_vec[c-'a']++;
    }
    //找到第一个只出现一次的字符
    for(char c: sequence){
        if(hash_vec[c-'a']==1)
            return c;
    }
    return ' ';
}
```

或直接用哈希表。

```C++
char firstUniqChar(string s) {
    unordered_map<int, int> frequency;
    for (char ch: s) 
        ++frequency[ch];
    for (int i = 0; i < s.size(); ++i) {
        if (frequency[s[i]] == 1) 
            return s[i];
    }
    return ' ';
}
```

时间复杂度：O(n)，其中 n 是字符串 s 的长度。我们需要进行两次遍历。

空间复杂度：O(∣Σ∣)，其中 Σ 是字符集，在本题中 s 只包含小写字母，因此 ∣Σ∣≤26。我们需要 O(∣Σ∣) 的空间存储哈希映射。



**思路2**：哈希表，存储索引。

我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。

具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 −1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 −1。

在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 −1 的最小值，即为第一个不重复字符的索引，然后返回该索引对应的字符。如果哈希映射中的所有值均为 −1，我们就返回空格。

```C++
char firstUniqChar(string s) {
    unordered_map<char, int> position;
    int n = s.size();
    for (int i = 0; i < n; ++i) {
        if (position.count(s[i]))
            position[s[i]] = -1;
        else 
            position[s[i]] = i;
    }
    int first = n;
    for (auto [_, pos]: position) {
        if (pos != -1 && pos < first)
            first = pos;
    }
    return first == n ? ' ' : s[first];
}
```

时间复杂度：O(n)，其中 n 是字符串 s 的长度。第一次遍历字符串的时间复杂度为 O(n)，第二次遍历哈希映射的时间复杂度为 O(∣Σ∣)，由于 s 包含的字符种类数一定小于 s 的长度，因此 O(∣Σ∣) 在渐进意义下小于 O(n)，可以忽略。

空间复杂度：O(∣Σ∣)，其中 Σ 是字符集，在本题中 s 只包含小写字母，因此 ∣Σ∣≤26。我们需要 O(∣Σ∣) 的空间存储哈希映射。



### L58.最后一个单词的长度

**[题目](https://leetcode-cn.com/problems/length-of-last-word/)**: 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

```
示例 1：
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为5。

示例 2：
输入：s = "   fly me   to   the moon  "
输出：4
解释：最后一个单词是“moon”，长度为4。

示例 3：
输入：s = "luffy is still joyboy"
输出：6
解释：最后一个单词是长度为6的“joyboy”。
```


提示：

1 <= s.length <= 10^4
s 仅有英文字母和空格 ' ' 组成
s 中至少存在一个单词



**思路1**：遍历法。

从后往前遍历。设置两个变量left和right，left记录目标单词开始的位置，right记录目标单词结束的位置。

```C++
int lengthOfLastWord(string s) {
    int right=s.size()-1;
    int left=-1;//从-1开始，防止left变量在循环中未被设置
    bool flag=false;
    for(int i=s.size()-1;i>=0;--i){
        if(!flag && s[i]!=' '){
            right=i;
            flag=true;
        }
        if(flag && s[i]==' '){
            left = i;
            flag=false;
            break;
        }
    }
    return right-left;
}
```



官方解答：

```C++
int lengthOfLastWord(string s) {
    int index = s.size() - 1;

    while (s[index] == ' ') {
        index--;
    }
    int wordLength = 0;
    while (index >= 0 && s[index] != ' ') {
        wordLength++;
        index--;
    }

    return wordLength;
}
```



### L415.字符串相加

**[题目](https://leetcode-cn.com/problems/add-strings/)**: 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

 ```
示例 1：
输入：num1 = "11", num2 = "123"
输出："134"

示例 2：
输入：num1 = "456", num2 = "77"
输出："533"

示例 3：
输入：num1 = "0", num2 = "0"
输出："0"
 ```


提示：

1 <= num1.length, num2.length <= 10^4
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零



**思路1**：模拟。

  本题我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 10，则向高位进一位？因此我们只要将这个过程用代码写出来即可。

![](https://assets.leetcode-cn.com/solution-static/415/1.png)

具体实现也不复杂，我们定义两个指针 i 和 j 分别指向 num1和 num 2的末尾，即最低位，同时定义一个变量add 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理，具体可以看下面的代码。

```C++
string addStrings(string num1, string num2) {
    int N = std::max(num1.size(),num2.size());
    string result(N,'0');
    std::reverse(num1.begin(),num1.end());
    std::reverse(num2.begin(),num2.end());
    int carry=0;
    for(int i=0;i<N;++i){
        int tmp=carry;
        if(i>=num1.size()){
            tmp+=(num2[i]-'0');
        }
        else if(i>=num2.size()){
            tmp+=(num1[i]-'0');
        }
        else{
            tmp+=((num2[i]-'0')+(num1[i]-'0'));
        }
        result[i] = tmp%10+'0';
        carry = tmp/10;//进位
    }
    if(carry>0){//可能还剩余进位
        result.push_back(carry+'0');
    }
    std::reverse(result.begin(),result.end());
    return result;
}
```



官方解答：

```C++
string addStrings(string num1, string num2) {
    int i = num1.length() - 1, j = num2.length() - 1, add = 0;
    string ans = "";
    while (i >= 0 || j >= 0 || add != 0) {
        int x = i >= 0 ? num1[i] - '0' : 0;
        int y = j >= 0 ? num2[j] - '0' : 0;
        int result = x + y + add;
        ans.push_back('0' + result % 10);
        add = result / 10;
        i -= 1;
        j -= 1;
    }
    // 计算完以后的答案需要翻转过来
    reverse(ans.begin(), ans.end());
    return ans;
}
```











### L43.字符串相乘

**[题目](https://leetcode-cn.com/problems/multiply-strings/)**: 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

```
示例 1:
输入: num1 = "2", num2 = "3"
输出: "6"

示例 2:
输入: num1 = "123", num2 = "456"
输出: "56088"
```


提示：

1 <= num1.length, num2.length <= 200
num1 和 num2 只能由数字组成。
num1 和 num2 都不包含任何前导零，除了数字0本身。



**思路1**：乘法竖式。

举例：

```
  123
x 456
_____
  738
 615
492
_____
56088
```

代码：

```C++
string multiply(string num1, string num2) {
    string result(num1.size()*num2.size()+1,' ');
    //将字符串进行翻转
    std::reverse(num1.begin(),num1.end());
    std::reverse(num2.begin(),num2.end());

    for(int i=0;i<num2.size();++i){
        int carry=0;//进位
        //num2的每个数乘以num1的每个数
        for(int j=0;j<num1.size();++j){
            int multiply = (num1[j]-'0')*(num2[i]-'0');//两个数字相乘
            multiply+=carry;//加上进位
            if(result[j+i]!=' ')
                multiply+= (result[j+i]-'0');//加上前面的结果 
            result[j+i] = (multiply%10)+'0';
            carry=multiply/10;//设置新的进位
        }
        if(carry!=0)//还有进位
            result[num1.size()+i] = carry+'0';
    }
    result.erase(result.find_last_not_of(" ") + 1);//去除尾部的空格
    std::reverse(result.begin(),result.end());//将结果重新翻转
    //防止出现"0000"的情况        
    for(auto it=result.begin();result.size()>1;){
        if(*it>'0')
            break;
        else if(*it == '0')
            it=result.erase(it);//返回指向下一个元素的指针
    }
    return result;
}
```



[官方解答](https://leetcode-cn.com/problems/multiply-strings/solution/zi-fu-chuan-xiang-cheng-by-leetcode-solution/)









## 正则表达式



### L10. 正则表达式匹配 & J19.正则表达式匹配

**[题目](https://leetcode-cn.com/problems/regular-expression-matching/)**：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

```
示例 1：
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

示例 2:
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3：
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4：
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

示例 5：
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```


提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 只含小写英文字母。
p 只含小写英文字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符



**思路1**：动态规划。
	题目中的匹配是一个「逐步匹配」的过程：我们每次从字符串 p 中取出一个字符或者`字符+星号`的组合，并在 s 中进行匹配。对于 p 中一个字符而言，它只能在 s 中匹配一个字符，匹配的方法具有唯一性；而对于 p 中`字符+星号`的组合而言，它可以在 s 中匹配任意自然数个字符，并不具有唯一性。因此我们可以考虑使用动态规划，对匹配的方案进行枚举。

**我们用 `f[i][j]`表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配**。在进行状态转移时，我们考虑 p 的第 j 个字符的匹配情况：

1. **如果 p 的第 j 个字符是一个小写字母**，那么我们必须在 s 中匹配一个相同的小写字母，即


$$
f[i][j] = \begin{cases} f[i - 1][j - 1], & s[i] = p[j]\\ \text{false}, & s[i] \neq p[j] \end{cases}
$$

​	也就是说，如果 s 的第 i 个字符与 p 的第 j 个字符不相同，那么无法进行匹配；否则我们可以匹配两个字符串的最后一个字符，完整的匹配结果取决于两个字符串前面的部分。

2. **如果 p 的第 j 个字符是 `*`**，那么就表示我们可以对 p 的第 j−1个字符`p[j-1]`匹配任意自然数次。在匹配 0 次的情况下，我们有

$$
f[i][j] = f[i][j - 2]
$$

​	也就是我们「浪费」了一个`字符+星号`的组合，没有匹配任何 s 中的字符。在匹配 1,2,3,⋯ 次的情况下，类似地我们有

$$
\begin{aligned} 
& f[i][j] = f[i - 1][j - 2], \quad && \text{if } s[i] = p[j - 1] \\ 
& f[i][j] = f[i - 2][j - 2], \quad && \text{if } s[i - 1] = s[i] = p[j - 1] \\ 
& f[i][j] = f[i - 3][j - 2], \quad && \text{if } s[i - 2] = s[i - 1] = s[i] = p[j - 1] \\
& \cdots\cdots 
& \end{aligned}
$$

​	如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了 s 中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：`字母+星号`的组合在匹配的过程中，本质上只会有两种情况：

* 匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；

* 不匹配字符，将该组合扔掉，不再进行匹配。

如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：
$$
f[i][j] = 
\begin{cases} f[i - 1][j] \text{ or } f[i][j - 2], & s[i] = p[j - 1] \\ 
f[i][j - 2], & s[i] \neq p[j - 1] 
\end{cases}
$$

3. **在任意情况下，只要 p[j] 是 `.`**，那么 p[j] 一定成功匹配 s 中的任意一个小写字母。

最终的状态转移方程如下：

$$
f[i][j] = \begin{cases} \text{if} (p[j] \neq \text{'*'}) = \begin{cases} f[i - 1][j - 1], & \textit{matches}(s[i], p[j])\\ \text{false}, & \text{otherwise} \end{cases} \\ \text{otherwise} = \begin{cases} f[i - 1][j] \text{ or } f[i][j - 2], & \textit{matches}(s[i], p[j-1]) \\ f[i][j - 2], & \text{otherwise} \end{cases} \end{cases}
$$
​	其中 $\textit{matches}(x, y)$ 判断两个字符是否匹配的辅助函数。只有当 y 是 `.` 或者 x 和 y 本身相同时，这两个字符才会匹配。

**细节**

​	动态规划的边界条件为 $f[0][0] = \text{true}$，即两个空字符串是可以匹配的。最终的答案即为 $f[m][n]$，其中 m 和 n 分别是字符串 s 和 p 的长度。由于大部分语言中，字符串的字符下标是从 0 开始的，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。

在上面的状态转移方程中，如果字符串 p 中包含一个「字符 + 星号」的组合（例如 `a*`），那么在进行状态转移时，会先将 a 进行匹配（当 p[j]p[j] 为 a 时），再将 `a*` 作为整体进行匹配（当 `p[j]p[j]` 为 `*` 时）。然而，在题目描述中，我们必须将 `a*` 看成一个整体，因此将 a 进行匹配是不符合题目要求的。看来我们进行了额外的状态转移，这样会对最终的答案产生影响吗？这个问题留给读者进行思考。

```C++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        auto matches = [&](int i, int j) {
            if (i == 0) 
                return false;
            if (p[j - 1] == '.')
                return true;
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        dp[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    dp[i][j] |= dp[i][j - 2];
                    if (matches(i, j - 1))dp[i][j] |= dp[i - 1][j];
                }
                else {
                    if (matches(i, j)) dp[i][j] |= dp[i - 1][j - 1];
                }
            }
        }
        return dp[m][n];
    }
};
```








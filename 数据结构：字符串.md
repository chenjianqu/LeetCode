# 字符串

## 常见算法



### 有限状态机

确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：

* 有一个特殊的状态，被称作「初始状态」。
* 还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。

起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。

**注意**：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。

一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。

自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。

自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。



### KMP算法

[文章](https://zhuanlan.zhihu.com/p/105629613)

Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(m+n)。

**构造Next数组**：next[i] 对应的下标，为 P[0...i - 1] 的最长*公共前缀后缀*的长度，令 P[0] = -1。 具体解释如下：

例如对于字符串 abcba：

前缀：它的前缀包括：a, ab, abc, abcb，不包括本身；
后缀：它的后缀包括：bcba, cba, ba, a，不包括本身；
最长公共前缀后缀：abcba 的前缀和后缀中只有 a 是公共部分，字符串 a 的长度为 1。
所以，我们将 P[0...i - 1] 的最长公共前后缀的长度作为 next[i] 的下标，就得到了 next 数组。



```C++
int strStr(string haystack, string needle) {
    int n = haystack.size(), m = needle.size();
    if (m == 0)  return 0;
    vector<int> pi(m);///构造Next数组
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && needle[i] != needle[j]) j = pi[j - 1];
        if (needle[i] == needle[j])  j++;
        pi[i] = j;
    }
    for (int i = 0, j = 0; i < n; i++) {
        while (j > 0 && haystack[i] != needle[j])
            j = pi[j - 1];
        if (haystack[i] == needle[j])
            j++;
        if (j == m) 
            return i - m + 1;
    }
    return -1;
}

```





## 题目

### L344. 反转字符串

**题目**：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**思路**：遍历法，使用双指针。

```C++
void reverseString(vector<char>& s) {
	for(int i=0;i<s.size()/2;++i) 
        std::swap(s[i],s[s.size()-i-1]);
}
```





### L14. 最长公共前缀

**题目**：编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

 ```C++
示例 1：
输入：strs = ["flower","flow","flight"]
输出："fl"
 ```

**思路1**：纵向扫描。双重循环，外层循环从左往右遍历字符，内层循环从左往右遍历字符串，比较每个字符串在相同位置上是否拥有相同的元素。

```C++
string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty())
            return "";
        string output;
        for(int i=0;i<strs[0].size();++i){
            bool flag=true;
            char c = strs[0][i];
            for(int j=1;j<strs.size();++j){
                if(strs[j][i]!=c){
                    flag=false;
                    break;
                }
            }
            if(flag) output.push_back(c);
            else break;
        }
        return output;
    }
```



**思路2**：横向扫描。 依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。 

```
string longestCommonPrefix(vector<string>& strs) {
	if (!strs.size()) return "";
	string prefix = strs[0];
	int count = strs.size();
    for (int i = 1; i < count; ++i) {
        prefix = longestCommonPrefix(prefix, strs[i]);
        if (!prefix.size()) break;
    }
    return prefix;
}

string longestCommonPrefix(const string& str1, const string& str2) {
    int length = min(str1.size(), str2.size());
    int index = 0;
    while (index < length && str1[index] == str2[index])
	    ++index;
    return str1.substr(0, index);
}

```

**思路3**：分治法。

注意到  $\textit{LCP}$ 的计算满足结合律，有以下结论：

$$
\textit{LCP}(S_1 \ldots S_n) 
\\ = \textit{LCP}(\textit{LCP}(S_1 \ldots S_k), \textit{LCP} (S_{k+1} \ldots S_n))
$$
其中 ${LCP}(S_1 \ldots S_n)$ 是字符串$S_1 \ldots S_n$的最长公共前缀。基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题 ${LCP}(S_i \ldots S_j)$，可以分解成两个子问题 ${LCP}(S_i \ldots S_{mid})$和${LCP}(S_{mid+1} \ldots S_j)$，其中 $mid=\frac{i+1}{2}$。

**思路4**：二分查找。

显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用minLength 表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值mid，判断每个字符串的长度为mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于mid，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。







### L205. 同构字符串

**题目**：给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

```
输入：s = "egg", t = "add"
输出：true

输入：s = "foo", t = "bar"
输出：false

输入：s = "paper", t = "title"
输出：true
```

**思路1**：用哈希表。由于要求“不同字符不能映射到同一个字符上”，因此需要两个哈希表，一个用来将s映射到t，另一个用来将t映射到s。

```C++
bool isIsomorphic(string s, string t) {
    if(s.size()!=t.size())
        return false;
    std::unordered_map<char,char> hash_map;
    std::unordered_map<char,char> value_map;
    for(int i=0;i<s.size();++i){
        bool find_s = hash_map.find(s[i])!=hash_map.end();
        if(!find_s){
            if(value_map.find(t[i])!=value_map.end())//题目要求不同字符不能映射到同一个字符
                return false;
            hash_map.insert({s[i],t[i]});
            value_map.insert({t[i],s[i]});
        }
        else if(hash_map[s[i]]!=t[i])
                return false;
    }
    return true;
}
```



### L151. 翻转字符串里的单词

**题目**：给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。

```C++
输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
```

**思路1**：单层遍历法。这种方法需要额外的字符串。空间复杂度为(n)。从后往前遍历输入字符串，当遇到空格时，将刚刚经过的字符串添加到输出字符串。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    //翻转单词
    int n=s.size();
    string out,tmp;
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' ' && s[i]==s[i+1] ){//去除重复的字符串
            continue;
        }
        if(s[i]==' '){
            out += s.substr(i+1,len);
            out+=" ";//补上空格
            len=0;
            continue;
        }
        else if(i==0){
            out += s.substr(i,len+1);//由于最后一次结束没到' '，因此len需要补上1
        }
        len++;
    }
    return out;
}
```



**思路2**：先翻转整个字符串，再逐个翻转单词。时间复杂度O(n)，空间复杂度O(1)。



**思路3**：使用队列，队列具有先进先出的特性，在遍历字符串时从后往前，将每个单词入到队列中。最后将队列中的单词串联成输出字符串。时间复杂度:O(n)，空间复杂度O(n)。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    int n=s.size();
    std::queue<string> q;
    //从后往前遍历字符串，将单词放入队列中。
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' '){
            if(s[i]==s[i+1])//去除连续空格
                continue;
            else
                q.push(s.substr(i+1,len));
            len=0;
            continue;
        }
        else if(i==0){
            q.push(s.substr(0,len+1));
        }
        len++;
    }
    //将队列中的单词串联成输出字符串。
    int qsize=q.size();;
    string out;
    for(int i=0;i<qsize;++i){
        out += q.front();
        if(i!=qsize-1)out+=" ";
        q.pop();
    }
    return out;
}
```





### L151. 实现strStr()

**题目**：给实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。



**思路1**：这是一道典型的KMP问题。

```C++
 int strStr(string haystack, string needle) {
        if(needle.empty())
            return 0;
        if(haystack.size()<needle.size() )
            return -1;
        vector<int> arr(needle.size());
        for(int i=1,j=0;i<needle.size();++i){
            while(j>0 && needle[i]!=needle[j])
                j = arr[j-1];//回溯
            if(needle[i]==needle[j])
                j++;
            arr[i]=j;
        }
        for(int i=0,j=0;i<haystack.size();++i){
            while(j>0 && haystack[i]!=needle[j])
                j=arr[j-1];
            if(haystack[i]==needle[j])
                j++;
            if(j==needle.size())
                return i-needle.size()+1;
        }
        
        return -1;
    }
```





### J20. 表示数值的字符串

**[题目](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)**：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。

**数值**（按顺序）可以分成以下几个部分：

* 若干空格
* 一个 小数 或者 整数
* （可选）一个 'e' 或 'E' ，后面跟着一个 整数
* 若干空格

**小数**（按顺序）可以分成以下几个部分：

* （可选）一个符号字符（'+' 或 '-'）

* 下述格式之一：

  * 至少一位数字，后面跟着一个点 '.'
  * 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
  * 一个点 '.' ，后面跟着至少一位数字

**整数**（按顺序）可以分成以下几个部分：

* （可选）一个符号字符（'+' 或 '-'）

* 至少一位数字

例子：

  部分数值列举如下：`["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"]`
  部分非数值列举如下：`["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"]`

```
示例 1：
输入：s = "0"
输出：true

示例 2：
输入：s = "e"
输出：false

示例 3：
输入：s = "."
输出：false

示例 4：
输入：s = "    .1  "
输出：true
```


提示：

1 <= s.length <= 20
s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，空格 ' ' 或者点 '.' 。



**思路1**：确定有限状态机。

**问题描述**

在 C++ 文档 中，描述了一个合法的数值字符串应当具有的格式。具体而言，它包含以下部分：

* 符号位，即 +、− 两种符号
* 整数部分，即由若干字符 0-90−9 组成的字符串
* 小数点
* 小数部分，其构成与整数部分相同
* 指数部分，其中包含开头的字符 \text{e}e（大写小写均可）、可选的符号位，和整数部分

相比于 C++ 文档而言，本题还有一点额外的不同，即允许字符串首末两端有一些额外的空格。

在上面描述的五个部分中，每个部分都不是必需的，但也受一些额外规则的制约，如：

* 如果符号位存在，其后面必须跟着数字或小数点。
* 小数点的前后两侧，至少有一侧是数字。

**思路与算法**

根据上面的描述，现在可以定义自动机的「状态集合」了。那么怎么挖掘出所有可能的状态呢？一个常用的技巧是，用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：

* 起始的空格
* 符号位
* 整数部分
* 左侧有整数的小数点
* 左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）
* 小数部分
* 字符 e
* 指数部分的符号位
* 指数部分的整数部分
* 末尾的空格

  下一步是找出「初始状态」和「接受状态」的集合。根据题意，「初始状态」应当为状态 1，而「接受状态」的集合则为状态 3、状态 4、状态 6、状态 9 以及状态 10。换言之，字符串的末尾要么是空格，要么是数字，要么是小数点，但前提是小数点的前面有数字。

  最后，需要定义「转移规则」。结合数值字符串应当具备的格式，将自动机转移的过程以图解的方式表示出来：

![](https://assets.leetcode-cn.com/solution-static/jianzhi_20/jianzhi_20_fig1.png)

比较上图与「预备知识」一节中对自动机的描述，可以看出有一点不同：

我们没有单独地考虑每种字符，而是划分为若干类。由于全部 1010 个数字字符彼此之间都等价，因此只需定义一种统一的「数字」类型即可。对于正负号也是同理。
在实际代码中，我们需要处理转移失败的情况。例如当位于状态 1（起始空格）时，没有对应字符 e 的状态。为了处理这种情况，我们可以创建一个特殊的拒绝状态。如果当前状态下没有对应读入字符的「转移规则」，我们就转移到这个特殊的拒绝状态。一旦自动机转移到这个特殊状态，我们就可以立即判定该字符串不「被接受」。

代码：

```C++
class Solution {
private:
    enum State {
        STATE_INITIAL,
        STATE_INT_SIGN,
        STATE_INTEGER,
        STATE_POINT,
        STATE_POINT_WITHOUT_INT,
        STATE_FRACTION,
        STATE_EXP,
        STATE_EXP_SIGN,
        STATE_EXP_NUMBER,
        STATE_END
    };
    enum CharType {
        CHAR_NUMBER,
        CHAR_EXP,
        CHAR_POINT,
        CHAR_SIGN,
        CHAR_SPACE,
        CHAR_ILLEGAL
    };

    CharType toCharType(char ch) {
        if (ch >= '0' && ch <= '9') {
            return CHAR_NUMBER;
        } else if (ch == 'e' || ch == 'E') {
            return CHAR_EXP;
        } else if (ch == '.') {
            return CHAR_POINT;
        } else if (ch == '+' || ch == '-') {
            return CHAR_SIGN;
        } else if (ch == ' ') {
            return CHAR_SPACE;
        } else {
            return CHAR_ILLEGAL;
        }
    }
    
    std::unordered_map<State, std::unordered_map<CharType, State>> transfer{
            {
                STATE_INITIAL, {
                    {CHAR_SPACE, STATE_INITIAL},
                    {CHAR_NUMBER, STATE_INTEGER},
                    {CHAR_POINT, STATE_POINT_WITHOUT_INT},
                    {CHAR_SIGN, STATE_INT_SIGN}
                }
            }, {
                STATE_INT_SIGN, {
                    {CHAR_NUMBER, STATE_INTEGER},
                    {CHAR_POINT, STATE_POINT_WITHOUT_INT}
                }
            }, {
                STATE_INTEGER, {
                    {CHAR_NUMBER, STATE_INTEGER},
                    {CHAR_EXP, STATE_EXP},
                    {CHAR_POINT, STATE_POINT},
                    {CHAR_SPACE, STATE_END}
                }
            }, {
                STATE_POINT, {
                    {CHAR_NUMBER, STATE_FRACTION},
                    {CHAR_EXP, STATE_EXP},
                    {CHAR_SPACE, STATE_END}
                }
            }, {
                STATE_POINT_WITHOUT_INT, {
                    {CHAR_NUMBER, STATE_FRACTION}
                }
            }, {
                STATE_FRACTION,
                {
                    {CHAR_NUMBER, STATE_FRACTION},
                    {CHAR_EXP, STATE_EXP},
                    {CHAR_SPACE, STATE_END}
                }
            }, {
                STATE_EXP,
                {
                    {CHAR_NUMBER, STATE_EXP_NUMBER},
                    {CHAR_SIGN, STATE_EXP_SIGN}
                }
            }, {
                STATE_EXP_SIGN, {
                    {CHAR_NUMBER, STATE_EXP_NUMBER}
                }
            }, {
                STATE_EXP_NUMBER, {
                    {CHAR_NUMBER, STATE_EXP_NUMBER},
                    {CHAR_SPACE, STATE_END}
                }
            }, {
                STATE_END, {
                    {CHAR_SPACE, STATE_END}
                }
            }
        };
    
public:
    bool isNumber(string s) {
        int len = s.length();
        State st = STATE_INITIAL;

        for (int i = 0; i < len; i++) {
            CharType typ = toCharType(s[i]);
            if (transfer[st].find(typ) == transfer[st].end()) {
                return false;
            } else {
                st = transfer[st][typ];
            }
        }
        return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;
    }
};
```







**思路2**：剑指Offer的实现

**分析**：表示数值的字符串遵循模式`A[.[B]][e|EC]`或者`.B[e|EC]`，其中A为数值的整数部分，B紧跟着小数点为数值的小数部分，C紧跟着`'e'`或者`'E'`为数值的指数部分。在小数里可能没有数值的整数部分。例如，小数.123等于0.123。因此A 部分不是必需的。如果一个数没有整数部分，那么它的小数部分不能为空。上述`A`和`C`都是可能以`'+'`或者`'-'`开头的`0～9`的数位串; `B`也是`0～9`的数位串，但前面不能有正负号。

​	以表示数值的字符串`"123.45e+6"`为例，`"123"`是它的整数部分A，`"45"`是它的小数部分B，`"+6"`是它的指数部分C。

​	判断一个字符串是否符合上述模式时，首先尽可能多地扫描0~9的数位（有可能在起始处有`'+'`或者`'-'`），也就是前面模式中表示数值整数的 A部分。如果遇到小数点，则开始扫描表示数值小数部分的 B部分。如果遇到`'e'`或者`'E'`，则开始扫描表示数值指数的C部分。

```C++
class Solution {
private:
    // 整数的格式可以用[+|-]B表示, 其中B为无符号整数
    bool scanInteger(const string s, int& index){
        if(s[index] == '+' || s[index] == '-')
            ++index;
        return scanUnsignedInteger(s, index);
    }
    
    bool scanUnsignedInteger(const string s, int& index){
        int befor = index;
        while(index != s.size() && s[index] >= '0' && s[index] <= '9')
            index ++;
        return index > befor;
    }
    
public:
    // 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，
    // 其中A和C都是整数（可以有正负号，也可以没有），而B是一个无符号整数
    bool isNumber(string s) {
        if(s.size() == 0)
            return false;
        int index = 0;
        while(s[index] == ' ')++index; //字符串开始有空格，可以返回true
        bool numeric = scanInteger(s, index);
        // 如果出现'.'，接下来是数字的小数部分
        if(s[index] == '.'){
            ++index;
            // 下面一行代码用||的原因：
            // 1. 小数可以没有整数部分，例如.123等于0.123；
            // 2. 小数点后面可以没有数字，例如233.等于233.0；
            // 3. 当然小数点前面和后面可以有数字，例如233.666
            numeric = scanUnsignedInteger(s, index) || numeric;
        }

        // 如果出现'e'或者'E'，接下来跟着的是数字的指数部分
        if(s[index] == 'e' || s[index] == 'E'){
            ++index;
            // 下面一行代码用&&的原因：
            // 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；
            // 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4
            numeric = numeric && scanInteger(s ,index);
        }
        //字符串结尾有空格，可以返回true
        while(s[index] == ' ')
            ++index;
        return numeric && index == s.size();
    }
};
```







## 正则表达式

### L10. 正则表达式匹配

**[题目](https://leetcode-cn.com/problems/regular-expression-matching/)**：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

```
示例 1：
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

示例 2:
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3：
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4：
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

示例 5：
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```


提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 只含小写英文字母。
p 只含小写英文字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符



**思路1**：动态规划。
	题目中的匹配是一个「逐步匹配」的过程：我们每次从字符串 p 中取出一个字符或者`字符+星号`的组合，并在 s 中进行匹配。对于 p 中一个字符而言，它只能在 s 中匹配一个字符，匹配的方法具有唯一性；而对于 p 中`字符+星号`的组合而言，它可以在 s 中匹配任意自然数个字符，并不具有唯一性。因此我们可以考虑使用动态规划，对匹配的方案进行枚举。

**我们用 `f[i][j]`表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配**。在进行状态转移时，我们考虑 p 的第 j 个字符的匹配情况：

1. **如果 p 的第 j 个字符是一个小写字母**，那么我们必须在 s 中匹配一个相同的小写字母，即


$$
f[i][j] = \begin{cases} f[i - 1][j - 1], & s[i] = p[j]\\ \text{false}, & s[i] \neq p[j] \end{cases}
$$

​	也就是说，如果 s 的第 i 个字符与 p 的第 j 个字符不相同，那么无法进行匹配；否则我们可以匹配两个字符串的最后一个字符，完整的匹配结果取决于两个字符串前面的部分。

2. **如果 p 的第 j 个字符是 `*`**，那么就表示我们可以对 p 的第 j−1个字符`p[j-1]`匹配任意自然数次。在匹配 0 次的情况下，我们有

$$
f[i][j] = f[i][j - 2]
$$

​	也就是我们「浪费」了一个`字符+星号`的组合，没有匹配任何 s 中的字符。在匹配 1,2,3,⋯ 次的情况下，类似地我们有

$$
\begin{aligned} 
& f[i][j] = f[i - 1][j - 2], \quad && \text{if } s[i] = p[j - 1] \\ 
& f[i][j] = f[i - 2][j - 2], \quad && \text{if } s[i - 1] = s[i] = p[j - 1] \\ 
& f[i][j] = f[i - 3][j - 2], \quad && \text{if } s[i - 2] = s[i - 1] = s[i] = p[j - 1] \\
& \cdots\cdots 
& \end{aligned}
$$

​	如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了 s 中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：`字母+星号`的组合在匹配的过程中，本质上只会有两种情况：

* 匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；

* 不匹配字符，将该组合扔掉，不再进行匹配。

如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：
$$
f[i][j] = 
\begin{cases} f[i - 1][j] \text{ or } f[i][j - 2], & s[i] = p[j - 1] \\ 
f[i][j - 2], & s[i] \neq p[j - 1] 
\end{cases}
$$

3. **在任意情况下，只要 p[j] 是 `.`**，那么 p[j] 一定成功匹配 s 中的任意一个小写字母。

最终的状态转移方程如下：

$$
f[i][j] = \begin{cases} \text{if} (p[j] \neq \text{'*'}) = \begin{cases} f[i - 1][j - 1], & \textit{matches}(s[i], p[j])\\ \text{false}, & \text{otherwise} \end{cases} \\ \text{otherwise} = \begin{cases} f[i - 1][j] \text{ or } f[i][j - 2], & \textit{matches}(s[i], p[j-1]) \\ f[i][j - 2], & \text{otherwise} \end{cases} \end{cases}
$$
​	其中 $\textit{matches}(x, y)$ 判断两个字符是否匹配的辅助函数。只有当 y 是 `.` 或者 x 和 y 本身相同时，这两个字符才会匹配。

**细节**

​	动态规划的边界条件为 $f[0][0] = \text{true}$，即两个空字符串是可以匹配的。最终的答案即为 $f[m][n]$，其中 m 和 n 分别是字符串 s 和 p 的长度。由于大部分语言中，字符串的字符下标是从 0 开始的，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。

在上面的状态转移方程中，如果字符串 p 中包含一个「字符 + 星号」的组合（例如 `a*`），那么在进行状态转移时，会先将 a 进行匹配（当 p[j]p[j] 为 a 时），再将 `a*` 作为整体进行匹配（当 `p[j]p[j]` 为 `*` 时）。然而，在题目描述中，我们必须将 `a*` 看成一个整体，因此将 a 进行匹配是不符合题目要求的。看来我们进行了额外的状态转移，这样会对最终的答案产生影响吗？这个问题留给读者进行思考。

```C++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        auto matches = [&](int i, int j) {
            if (i == 0) 
                return false;
            if (p[j - 1] == '.')
                return true;
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        dp[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    dp[i][j] |= dp[i][j - 2];
                    if (matches(i, j - 1))dp[i][j] |= dp[i - 1][j];
                }
                else {
                    if (matches(i, j)) dp[i][j] |= dp[i - 1][j - 1];
                }
            }
        }
        return dp[m][n];
    }
};
```





### J19.正则表达式匹配

**[题目](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)**: 题目同上（L10）


# 字符串

## 常见算法

### KMP算法

[文章](https://zhuanlan.zhihu.com/p/105629613)

Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(m+n)。

**构造Next数组**：next[i] 对应的下标，为 P[0...i - 1] 的最长*公共前缀后缀*的长度，令 P[0] = -1。 具体解释如下：

例如对于字符串 abcba：

前缀：它的前缀包括：a, ab, abc, abcb，不包括本身；
后缀：它的后缀包括：bcba, cba, ba, a，不包括本身；
最长公共前缀后缀：abcba 的前缀和后缀中只有 a 是公共部分，字符串 a 的长度为 1。
所以，我们将 P[0...i - 1] 的最长公共前后缀的长度作为 next[i] 的下标，就得到了 next 数组。

```C++
int strStr(string haystack, string needle) {
    int n = haystack.size(), m = needle.size();
    if (m == 0)  return 0;
    vector<int> pi(m);///构造Next数组
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && needle[i] != needle[j]) j = pi[j - 1];
        if (needle[i] == needle[j])  j++;
        pi[i] = j;
    }
    for (int i = 0, j = 0; i < n; i++) {
        while (j > 0 && haystack[i] != needle[j])
            j = pi[j - 1];
        if (haystack[i] == needle[j])
            j++;
        if (j == m) 
            return i - m + 1;
    }
    return -1;
}
```





## 题目



### J50. 第一个只出现一次的字符

**[题目](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)**：在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

```
示例 1:
输入：s = "abaccdeff"
输出：'b'

示例 2:
输入：s = "" 
输出：' '
```


限制：

0 <= s 的长度 <= 50000



**思路1**：哈希表，存储频次。

我们可以对字符串进行两次遍历。

在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回该字符，否则在遍历结束后返回空格。

```C++
char firstUniqChar(string s) {
    //哈希表
    vector<int> hash_vec(26);
    vector<char> sequence;
    for(auto c : s){
        if(hash_vec[c-'a']==0)
            sequence.push_back(c);
        hash_vec[c-'a']++;
    }
    //找到第一个只出现一次的字符
    for(char c: sequence){
        if(hash_vec[c-'a']==1)
            return c;
    }
    return ' ';
}
```

或直接用哈希表。

```C++
char firstUniqChar(string s) {
    unordered_map<int, int> frequency;
    for (char ch: s) 
        ++frequency[ch];
    for (int i = 0; i < s.size(); ++i) {
        if (frequency[s[i]] == 1) 
            return s[i];
    }
    return ' ';
}
```

时间复杂度：O(n)，其中 n 是字符串 s 的长度。我们需要进行两次遍历。

空间复杂度：O(∣Σ∣)，其中 Σ 是字符集，在本题中 s 只包含小写字母，因此 ∣Σ∣≤26。我们需要 O(∣Σ∣) 的空间存储哈希映射。



**思路2**：哈希表，存储索引。

我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。

具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 −1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 −1。

在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 −1 的最小值，即为第一个不重复字符的索引，然后返回该索引对应的字符。如果哈希映射中的所有值均为 −1，我们就返回空格。

```C++
char firstUniqChar(string s) {
    unordered_map<char, int> position;
    int n = s.size();
    for (int i = 0; i < n; ++i) {
        if (position.count(s[i]))
            position[s[i]] = -1;
        else 
            position[s[i]] = i;
    }
    int first = n;
    for (auto [_, pos]: position) {
        if (pos != -1 && pos < first)
            first = pos;
    }
    return first == n ? ' ' : s[first];
}
```

时间复杂度：O(n)，其中 n 是字符串 s 的长度。第一次遍历字符串的时间复杂度为 O(n)，第二次遍历哈希映射的时间复杂度为 O(∣Σ∣)，由于 s 包含的字符种类数一定小于 s 的长度，因此 O(∣Σ∣) 在渐进意义下小于 O(n)，可以忽略。

空间复杂度：O(∣Σ∣)，其中 Σ 是字符集，在本题中 s 只包含小写字母，因此 ∣Σ∣≤26。我们需要 O(∣Σ∣) 的空间存储哈希映射。





### L344. 反转字符串

**题目**：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**思路**：遍历法，使用双指针。

```C++
void reverseString(vector<char>& s) {
	for(int i=0;i<s.size()/2;++i) 
        std::swap(s[i],s[s.size()-i-1]);
}
```





### L14. 最长公共前缀

**题目**：编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

 ```C++
示例 1：
输入：strs = ["flower","flow","flight"]
输出："fl"
 ```

**思路1**：纵向扫描。双重循环，外层循环从左往右遍历字符，内层循环从左往右遍历字符串，比较每个字符串在相同位置上是否拥有相同的元素。

```C++
string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty())
            return "";
        string output;
        for(int i=0;i<strs[0].size();++i){
            bool flag=true;
            char c = strs[0][i];
            for(int j=1;j<strs.size();++j){
                if(strs[j][i]!=c){
                    flag=false;
                    break;
                }
            }
            if(flag) output.push_back(c);
            else break;
        }
        return output;
    }
```



**思路2**：横向扫描。 依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。 

```
string longestCommonPrefix(vector<string>& strs) {
	if (!strs.size()) return "";
	string prefix = strs[0];
	int count = strs.size();
    for (int i = 1; i < count; ++i) {
        prefix = longestCommonPrefix(prefix, strs[i]);
        if (!prefix.size()) break;
    }
    return prefix;
}

string longestCommonPrefix(const string& str1, const string& str2) {
    int length = min(str1.size(), str2.size());
    int index = 0;
    while (index < length && str1[index] == str2[index])
	    ++index;
    return str1.substr(0, index);
}

```

**思路3**：分治法。

注意到  $\textit{LCP}$ 的计算满足结合律，有以下结论：

$$
\textit{LCP}(S_1 \ldots S_n) 
\\ = \textit{LCP}(\textit{LCP}(S_1 \ldots S_k), \textit{LCP} (S_{k+1} \ldots S_n))
$$
其中 ${LCP}(S_1 \ldots S_n)$ 是字符串$S_1 \ldots S_n$的最长公共前缀。基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题 ${LCP}(S_i \ldots S_j)$，可以分解成两个子问题 ${LCP}(S_i \ldots S_{mid})$和${LCP}(S_{mid+1} \ldots S_j)$，其中 $mid=\frac{i+1}{2}$。

**思路4**：二分查找。

显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用minLength 表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值mid，判断每个字符串的长度为mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于mid，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。







### L205. 同构字符串

**题目**：给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

```
输入：s = "egg", t = "add"
输出：true

输入：s = "foo", t = "bar"
输出：false

输入：s = "paper", t = "title"
输出：true
```

**思路1**：用哈希表。由于要求“不同字符不能映射到同一个字符上”，因此需要两个哈希表，一个用来将s映射到t，另一个用来将t映射到s。

```C++
bool isIsomorphic(string s, string t) {
    if(s.size()!=t.size())
        return false;
    std::unordered_map<char,char> hash_map;
    std::unordered_map<char,char> value_map;
    for(int i=0;i<s.size();++i){
        bool find_s = hash_map.find(s[i])!=hash_map.end();
        if(!find_s){
            if(value_map.find(t[i])!=value_map.end())//题目要求不同字符不能映射到同一个字符
                return false;
            hash_map.insert({s[i],t[i]});
            value_map.insert({t[i],s[i]});
        }
        else if(hash_map[s[i]]!=t[i])
                return false;
    }
    return true;
}
```



### L151. 翻转字符串里的单词

**题目**：给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。

```C++
输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
```

**思路1**：单层遍历法。这种方法需要额外的字符串。空间复杂度为(n)。从后往前遍历输入字符串，当遇到空格时，将刚刚经过的字符串添加到输出字符串。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    //翻转单词
    int n=s.size();
    string out,tmp;
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' ' && s[i]==s[i+1] ){//去除重复的字符串
            continue;
        }
        if(s[i]==' '){
            out += s.substr(i+1,len);
            out+=" ";//补上空格
            len=0;
            continue;
        }
        else if(i==0){
            out += s.substr(i,len+1);//由于最后一次结束没到' '，因此len需要补上1
        }
        len++;
    }
    return out;
}
```



**思路2**：先翻转整个字符串，再逐个翻转单词。时间复杂度O(n)，空间复杂度O(1)。



**思路3**：使用队列，队列具有先进先出的特性，在遍历字符串时从后往前，将每个单词入到队列中。最后将队列中的单词串联成输出字符串。时间复杂度:O(n)，空间复杂度O(n)。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    int n=s.size();
    std::queue<string> q;
    //从后往前遍历字符串，将单词放入队列中。
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' '){
            if(s[i]==s[i+1])//去除连续空格
                continue;
            else
                q.push(s.substr(i+1,len));
            len=0;
            continue;
        }
        else if(i==0){
            q.push(s.substr(0,len+1));
        }
        len++;
    }
    //将队列中的单词串联成输出字符串。
    int qsize=q.size();;
    string out;
    for(int i=0;i<qsize;++i){
        out += q.front();
        if(i!=qsize-1)out+=" ";
        q.pop();
    }
    return out;
}
```





### L151. 实现strStr()

**题目**：给实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。



**思路1**：这是一道典型的KMP问题。

```C++
 int strStr(string haystack, string needle) {
        if(needle.empty())
            return 0;
        if(haystack.size()<needle.size() )
            return -1;
        vector<int> arr(needle.size());
        for(int i=1,j=0;i<needle.size();++i){
            while(j>0 && needle[i]!=needle[j])
                j = arr[j-1];//回溯
            if(needle[i]==needle[j])
                j++;
            arr[i]=j;
        }
        for(int i=0,j=0;i<haystack.size();++i){
            while(j>0 && haystack[i]!=needle[j])
                j=arr[j-1];
            if(haystack[i]==needle[j])
                j++;
            if(j==needle.size())
                return i-needle.size()+1;
        }
        
        return -1;
    }
```





### J46. 把数字翻译成字符串

**[题目](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)**：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

```
示例 1:
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

提示：

0 <= num < 2^31



**分析**：

`[1,4,02]`，这种情况也是不合法的，含有前导零的两位数不在题目规定的翻译规则中，那么 `[14,02]` 显然也是不合法的。 

**思路1**：动态规划。

题目是求多少种方法，而不是求出所有的方法。前者可以用动态规划，后者可以用回溯。

1. 确定dp数组（dp table）以及下标的含义 

   `dp[i]`表示对于前i个位数，有多少种方法

2. 确定递推公式 

   递推公式要根据前两个字母的情况来判断的：

   如果前一个字母是( '1') 或 ('2'且 当前字母<='5')，则有`dp[i] = dp[i-1] + dp[i-2];`；否则`dp[i] = dp[i-1]`。

```C++
if(s[i-2]=='1' || (s[i-2]=='2' && s[i-1]<='5'))
    dp[i] = dp[i-1] + dp[i-2];
else
    dp[i] = dp[i-1];
```

3. dp数组如何初始化 

   dp[0]=1，无意义。

   dp[1]=1，第一个字母只有一种方法。

4. 确定遍历顺序 

   从前往后。

5. 举例推导dp数组

```C++
int translateNum(int num) {
    string s = std::to_string(num);
    vector<int> dp(s.size()+1);//dp[i]表示对于前i个位数，有多少种方法
    dp[0]=1;
    dp[1]=1;
    for(int i=2;i<=s.size();++i){
        if(s[i-2]=='1' || (s[i-2]=='2' && s[i-1]<='5'))//注意，对s来说，下标应该从1开始，因此这里比标砖的遍历少1
            dp[i] = dp[i-1] + dp[i-2];
        else
            dp[i] = dp[i-1];
    }
    return *(dp.end()-1);
}
```



**思路2**：动态规划-滚动数组。

首先我们来通过一个例子理解一下这里「翻译」的过程：我们来尝试翻译「1402」。

分成两种情况：

首先我们可以把每一位单独翻译，即 `[1, 4, 0, 2]`，翻译的结果是 `beac`
然后我们考虑组合某些连续的两位：

* [`14, 0, 2]`，翻译的结果是 `oac`。
* `[1,40,2]`，这种情况是不合法的，因为 40 不能翻译成任何字母。
* `[1,4,02]`，这种情况也是不合法的，含有前导零的两位数不在题目规定的翻译规则中，那么 `[14,02]` 显然也是不合法的。

那么我们可以归纳出翻译的规则，字符串的第 i 位置：

* 可以单独作为一位来翻译
* 如果第 i - 1 位和第 i 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译

​	到这里，我们发现它和「198. 打家劫舍」非常相似。我们可以用 f(i) 表示以第 i 位结尾的前缀串翻译的方案数，考虑第 i 位单独翻译和与前一位连接起来再翻译对 f(i) 的贡献。单独翻译对 f(i) 的贡献为 f(i−1)；如果第 i−1 位存在，并且第 i−1 位和第 i 位形成的数字 x 满足 10≤x≤25，那么就可以把第 i−1 位和第 i 位连起来一起翻译，对 f(i) 的贡献为 f(i−2)，否则为 0。我们可以列出这样的动态规划转移方程：

`f(i)=f(i−1)+f(i−2)[i−1≥0,10≤x≤25]`

边界条件是 `f(−1)=0`，`f(0) = 1`。方程中 `[c]` 的意思是 c 为真的时候 `[c] = 1`，否则 `[c] = 0`。

有了这个方程我们不难给出一个时间复杂度为 O(n)，空间复杂度为 O(n) 的实现。考虑优化空间复杂度：这里的 f(i) 只和它的前两项 f(i−1) 和 f(i−2) 相关，我们可以运用「滚动数组」思想把 f 数组压缩成三个变量，这样空间复杂度就变成了 O(1)。

```C++
int translateNum(int num) {
    string src = to_string(num);
    int p = 0, q = 0, r = 1;
    for (int i = 0; i < src.size(); ++i) {
        p = q; 
        q = r; 
        r = 0;
        r += q;
        if (i == 0) {
            continue;
        }
        auto pre = src.substr(i - 1, 2);
        if (pre <= "25" && pre >= "10") {
            r += p;
        }
    }
    return r;
}
```



### J48. 最长不含重复字符的子字符串

[题目](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)：同L3

### L3. 无重复字符的最长子串

**[题目](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)**：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

 ```
示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

示例 4:
输入: s = ""
输出: 0
 ```


提示：

0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成



**思路1**：滑动窗口。

我们先用一个例子考虑如何在较优的时间复杂度内通过本题。

我们不妨以示例一中的字符串 `abcabcbb` 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：

以 `(a)bcabcbb` 开始的最长字符串为 `(abc)abcbb`；
以 `a(b)cabcbb` 开始的最长字符串为 `a(bca)bcbb`；
以 `ab(c)abcbb` 开始的最长字符串为 `ab(cab)cbb`；
以 `abc(a)bcbb` 开始的最长字符串为 `abc(abc)bb`；
以 `abca(b)cbb` 开始的最长字符串为 `abca(bc)bb`；
以 `abcab(c)bb` 开始的最长字符串为 `abcab(cb)b`；
以 `abcabc(b)b` 开始的最长字符串为 `abcabc(b)b`；
以 `abcabcb(b)` 开始的最长字符串为 `abcabcb(b)`。
发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 r_k 。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 r_k 的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 r_k ，直到右侧出现了重复字符为止。

这样一来，我们就可以使用「滑动窗口」来解决这个问题了：

我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 r_k；

在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；

在枚举结束后，我们找到的最长的子串的长度即为答案。

判断重复字符

在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 C++ 中的 `std::unordered_set`，Java 中的 `HashSet`，Python 中的 `set`, JavaScript 中的 `Set`）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。

至此，我们就完美解决了本题。

```C++
int lengthOfLongestSubstring(string s) {
    // 哈希集合，记录每个字符是否出现过
    unordered_set<char> occ;
    int n = s.size();
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    int rk = -1, ans = 0;
    // 枚举左指针的位置，初始值隐性地表示为 -1
    for (int i = 0; i < n; ++i) {
        if (i != 0) {
            // 左指针向右移动一格，移除一个字符
            occ.erase(s[i - 1]);
        }
        while (rk + 1 < n && !occ.count(s[rk + 1])) {
            // 不断地移动右指针
            occ.insert(s[rk + 1]);
            ++rk;
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk - i + 1);
    }
    return ans;
}
```



我的代码：

```C++
int lengthOfLongestSubstring(string s) {
    std::unordered_set<char> hash_set;
    int left=0, right=0;//滑动窗口的标号
    int ans=0;
    while(right<s.size()){
        while(right < s.size() && hash_set.find(s[right])==hash_set.end()){//滑动窗口右边扩展
            hash_set.insert(s[right]);
            ++right;
        }
        if(hash_set.size() > ans)
            ans = hash_set.size();
        //滑动窗口左边移动
        hash_set.erase(s[left]);
        left++;
    }
    return ans;
}
```





## 正则表达式

### L10. 正则表达式匹配

**[题目](https://leetcode-cn.com/problems/regular-expression-matching/)**：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

```
示例 1：
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

示例 2:
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3：
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4：
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

示例 5：
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```


提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 只含小写英文字母。
p 只含小写英文字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符











### J19.正则表达式匹配

**[题目](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)**: 题目同上（L10）


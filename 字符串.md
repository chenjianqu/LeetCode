# 字符串

## 常见算法

### KMP算法

[文章](https://zhuanlan.zhihu.com/p/105629613)

Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(m+n)。

**构造Next数组**：next[i] 对应的下标，为 P[0...i - 1] 的最长*公共前缀后缀*的长度，令 P[0] = -1。 具体解释如下：

例如对于字符串 abcba：

前缀：它的前缀包括：a, ab, abc, abcb，不包括本身；
后缀：它的后缀包括：bcba, cba, ba, a，不包括本身；
最长公共前缀后缀：abcba 的前缀和后缀中只有 a 是公共部分，字符串 a 的长度为 1。
所以，我们将 P[0...i - 1] 的最长公共前后缀的长度作为 next[i] 的下标，就得到了 next 数组。

换句话说，next[i]就是，从模式串p[0]往后数（往右数）、同时从p[i]往前数（往左数）相同的位数，

```C++
int strStr(string haystack, string needle) {
    int n = haystack.size(), m = needle.size();
    if (m == 0)  return 0;
    vector<int> pi(m);
    ///构造Next数组
    pi[0]=0;
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && needle[i] != needle[j]) 
            j = pi[j - 1];
        if (needle[i] == needle[j])  
            j++;
        pi[i] = j;
    }
    for (int i = 0, j = 0; i < n; i++) {
        while (j > 0 && haystack[i] != needle[j])
            j = pi[j - 1];
        if (haystack[i] == needle[j])
            j++;
        if (j == m) 
            return i - m + 1;
    }
    return -1;
}
```





## 题目














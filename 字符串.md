# 字符串

## 常见算法

### KMP算法

[文章](https://zhuanlan.zhihu.com/p/105629613)

Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(m+n)。

**构造Next数组**：next[i] 对应的下标，为 P[0...i - 1] 的最长*公共前缀后缀*的长度，令 P[0] = -1。 具体解释如下：

例如对于字符串 abcba：

前缀：它的前缀包括：a, ab, abc, abcb，不包括本身；
后缀：它的后缀包括：bcba, cba, ba, a，不包括本身；
最长公共前缀后缀：abcba 的前缀和后缀中只有 a 是公共部分，字符串 a 的长度为 1。
所以，我们将 P[0...i - 1] 的最长公共前后缀的长度作为 next[i] 的下标，就得到了 next 数组。

```C++
int strStr(string haystack, string needle) {
    int n = haystack.size(), m = needle.size();
    if (m == 0)  return 0;
    vector<int> pi(m);///构造Next数组
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && needle[i] != needle[j]) j = pi[j - 1];
        if (needle[i] == needle[j])  j++;
        pi[i] = j;
    }
    for (int i = 0, j = 0; i < n; i++) {
        while (j > 0 && haystack[i] != needle[j])
            j = pi[j - 1];
        if (haystack[i] == needle[j])
            j++;
        if (j == m) 
            return i - m + 1;
    }
    return -1;
}
```





## 题目

### L344. 反转字符串

**题目**：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**思路**：遍历法，使用双指针。

```C++
void reverseString(vector<char>& s) {
	for(int i=0;i<s.size()/2;++i) 
        std::swap(s[i],s[s.size()-i-1]);
}
```





### L14. 最长公共前缀

**题目**：编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

 ```C++
示例 1：
输入：strs = ["flower","flow","flight"]
输出："fl"
 ```

**思路1**：纵向扫描。双重循环，外层循环从左往右遍历字符，内层循环从左往右遍历字符串，比较每个字符串在相同位置上是否拥有相同的元素。

```C++
string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty())
            return "";
        string output;
        for(int i=0;i<strs[0].size();++i){
            bool flag=true;
            char c = strs[0][i];
            for(int j=1;j<strs.size();++j){
                if(strs[j][i]!=c){
                    flag=false;
                    break;
                }
            }
            if(flag) output.push_back(c);
            else break;
        }
        return output;
    }
```



**思路2**：横向扫描。 依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。 

```
string longestCommonPrefix(vector<string>& strs) {
	if (!strs.size()) return "";
	string prefix = strs[0];
	int count = strs.size();
    for (int i = 1; i < count; ++i) {
        prefix = longestCommonPrefix(prefix, strs[i]);
        if (!prefix.size()) break;
    }
    return prefix;
}

string longestCommonPrefix(const string& str1, const string& str2) {
    int length = min(str1.size(), str2.size());
    int index = 0;
    while (index < length && str1[index] == str2[index])
	    ++index;
    return str1.substr(0, index);
}

```

**思路3**：分治法。

注意到  $\textit{LCP}$ 的计算满足结合律，有以下结论：

$$
\textit{LCP}(S_1 \ldots S_n) 
\\ = \textit{LCP}(\textit{LCP}(S_1 \ldots S_k), \textit{LCP} (S_{k+1} \ldots S_n))
$$
其中 ${LCP}(S_1 \ldots S_n)$ 是字符串$S_1 \ldots S_n$的最长公共前缀。基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题 ${LCP}(S_i \ldots S_j)$，可以分解成两个子问题 ${LCP}(S_i \ldots S_{mid})$和${LCP}(S_{mid+1} \ldots S_j)$，其中 $mid=\frac{i+1}{2}$。

**思路4**：二分查找。

显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用minLength 表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值mid，判断每个字符串的长度为mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于mid，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。







### L205. 同构字符串

**题目**：给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

```
输入：s = "egg", t = "add"
输出：true

输入：s = "foo", t = "bar"
输出：false

输入：s = "paper", t = "title"
输出：true
```

**思路1**：用哈希表。由于要求“不同字符不能映射到同一个字符上”，因此需要两个哈希表，一个用来将s映射到t，另一个用来将t映射到s。

```C++
bool isIsomorphic(string s, string t) {
    if(s.size()!=t.size())
        return false;
    std::unordered_map<char,char> hash_map;
    std::unordered_map<char,char> value_map;
    for(int i=0;i<s.size();++i){
        bool find_s = hash_map.find(s[i])!=hash_map.end();
        if(!find_s){
            if(value_map.find(t[i])!=value_map.end())//题目要求不同字符不能映射到同一个字符
                return false;
            hash_map.insert({s[i],t[i]});
            value_map.insert({t[i],s[i]});
        }
        else if(hash_map[s[i]]!=t[i])
                return false;
    }
    return true;
}
```



### L151. 翻转字符串里的单词

**题目**：给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。

```C++
输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
```

**思路1**：单层遍历法。这种方法需要额外的字符串。空间复杂度为(n)。从后往前遍历输入字符串，当遇到空格时，将刚刚经过的字符串添加到输出字符串。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    //翻转单词
    int n=s.size();
    string out,tmp;
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' ' && s[i]==s[i+1] ){//去除重复的字符串
            continue;
        }
        if(s[i]==' '){
            out += s.substr(i+1,len);
            out+=" ";//补上空格
            len=0;
            continue;
        }
        else if(i==0){
            out += s.substr(i,len+1);//由于最后一次结束没到' '，因此len需要补上1
        }
        len++;
    }
    return out;
}
```



**思路2**：先翻转整个字符串，再逐个翻转单词。时间复杂度O(n)，空间复杂度O(1)。



**思路3**：使用队列，队列具有先进先出的特性，在遍历字符串时从后往前，将每个单词入到队列中。最后将队列中的单词串联成输出字符串。时间复杂度:O(n)，空间复杂度O(n)。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    int n=s.size();
    std::queue<string> q;
    //从后往前遍历字符串，将单词放入队列中。
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' '){
            if(s[i]==s[i+1])//去除连续空格
                continue;
            else
                q.push(s.substr(i+1,len));
            len=0;
            continue;
        }
        else if(i==0){
            q.push(s.substr(0,len+1));
        }
        len++;
    }
    //将队列中的单词串联成输出字符串。
    int qsize=q.size();;
    string out;
    for(int i=0;i<qsize;++i){
        out += q.front();
        if(i!=qsize-1)out+=" ";
        q.pop();
    }
    return out;
}
```





### L151. 实现strStr()

**题目**：给实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。



**思路1**：这是一道典型的KMP问题。

```C++
 int strStr(string haystack, string needle) {
        if(needle.empty())
            return 0;
        if(haystack.size()<needle.size() )
            return -1;
        vector<int> arr(needle.size());
        for(int i=1,j=0;i<needle.size();++i){
            while(j>0 && needle[i]!=needle[j])
                j = arr[j-1];//回溯
            if(needle[i]==needle[j])
                j++;
            arr[i]=j;
        }
        for(int i=0,j=0;i<haystack.size();++i){
            while(j>0 && haystack[i]!=needle[j])
                j=arr[j-1];
            if(haystack[i]==needle[j])
                j++;
            if(j==needle.size())
                return i-needle.size()+1;
        }
        
        return -1;
    }
```















## 正则表达式

### L10. 正则表达式匹配

**[题目](https://leetcode-cn.com/problems/regular-expression-matching/)**：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

```
示例 1：
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

示例 2:
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3：
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4：
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

示例 5：
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```


提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 只含小写英文字母。
p 只含小写英文字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符











### J19.正则表达式匹配

**[题目](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)**: 题目同上（L10）


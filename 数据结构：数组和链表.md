**哈希表**
**链表**





# 1.数组

## 常见算法

### 双指针



## 数组的生成

### J17. 打印从1到最大的n位数

**[题目](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)**：输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

```
示例 1:

输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```


说明：

用返回一个整数列表来代替打印
n 为正整数



**思路1**：简单法：不考虑大数问题。

```C++
vector<int> printNumbers(int n) {
    int max=std::pow(10,n)-1;
    vector<int> arr(max);
    std::iota(arr.begin(),arr.end(),1);
    return arr;
}
```



**思路2**：当n很大时，会超出32位，此时需要考虑大数问题。





### L31. 下一个排列

**[题目](https://leetcode-cn.com/problems/next-permutation/)**：整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

* 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

* 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
* 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
* 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。

给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。

 ```
示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]
 ```


提示：

1 <= nums.length <= 100
0 <= nums[i] <= 100



**分析**：

​	“下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。

以 1,2,3,4,5,6 为例，其排列依次为：

```
123456
123465
123546
...
654321
```

可以看到有这样的关系：123456 < 123465 < 123546 < ... < 654321。



**思路1**：

我们希望下一个数**比当前数大**，这样才满足“下一个排列”的定义。因此只需要**将后面的「大数」与前面的「小数」交换**，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
我们还希望下一个数**增加的幅度尽可能的小**，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：

* 在尽可能**靠右**的低位进行交换，需要从后向前查找

* **将一个 尽可能小的「大数」 与前面的「小数」交换**。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换

* 将「大数」换到前面后，需要将「大数」后面的所有数**重置为升序，升序排列就是最小的排列**。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列

以上就是求“下一个排列”的分析过程。

**算法过程**

标准的“下一个排列”算法可以描述为：

* 1.从后向前查找第一个相邻升序的元素对 `(i,j)`，满足 `A[i] < A[j]`。此时 `[j,end)` 必然是降序

* 2.在 `[j,end)` 从后向前查找第一个满足 `A[i] < A[k]` 的 `k`。`A[i]`、`A[k]` 分别就是上文所说的「小数」、「大数」
* 3.将 `A[i]` 与 `A[k]` 交换

* 4.可以断定这时 `[j,end)` 必然是降序，逆置 `[j,end)`，使其升序

* 5.如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4

该方法支持数据重复，且在 C++ STL 中被采用。

```C++
void nextPermutation(vector<int>& nums) {
    int i=nums.size()-2;
    //从后往前 寻找第一个升序
    while(i>=0 && nums[i+1]<=nums[i])i--;
    if(i>=0){
        //寻找比nums[i]大的最小的数
        int j=nums.size()-1;
        while(nums[j]<=nums[i])j--;
        std::swap(nums[i],nums[j]);
        std::reverse(nums.begin()+i+1,nums.end());//将num[i]后面的降序变为升序
    }
    else{
        std::reverse(nums.begin(),nums.end());
    }
}
```

时间复杂度：O(N)，其中 NN 为给定序列的长度。我们至多只需要扫描两次序列，以及进行一次反转操作。

空间复杂度：O(1)，只需要常数的空间存放若干变量。









## 数组的查找和计算



### J03. 数组中重复的数字

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)**:找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 



```

限制：

2 <= n <= 100000



**思路1**：暴力法。先排序，后遍历。

简单粗暴，时间复杂度为O(nlogn)。

```c++
int findRepeatNumber(vector<int>& nums) {
    std::sort(nums.begin(),nums.end());
    for(int i=0;i<nums.size()-1;++i)
	    if(nums[i]==nums[i+1])
	    	return nums[i];
    return nums[0];
}
```



**思路2**：普通的哈希表。



**思路3**：原地交换。

题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。
因此，可遍历数组并通过交换操作，使**元素的 索引 与 值 一一对应**（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。

遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x] = x，此时即可得到一组重复数字。

```C++
int findRepeatNumber(vector<int>& nums) {
    for(int i=0;i<nums.size();++i){
        int n=nums[i];
        if(i!=n && nums[n]==n) 
            return n;
        else
            std::swap(nums[i],nums[n]);
    }
    return nums[0];
}
```



### J03 II. 数组中重复的数字∶不修改数组

**题目**：在一个长度为n+1的数组里的所有数字都在1～n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2， 3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。

**思路1**：哈希表。时间复杂度O(n)，空间复杂度O(n)



**思路2**：二分查找的思路。时间复杂度O(nlogn)，空间复杂度O(1)





### L2022. 将一维数组转变成二维数组

**题目**:
给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有
元素创建一个 m 行 n 列的二维数组。  
original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都
包含 ）的元素构成二维数组的第二行，依此类推。
请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。

**代码：**

```C++
    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
        if(original.size() != m*n)
            return vector<vector<int>>();
        vector<vector<int>> arr(m);
        for(int i=0;i<original.size();i+=n ){
                vector<int> row(n);
            for(int j=0;j<n;++j){
                row[j] = original[i+j];
            }
            arr[static_cast<int>(i/n)]=row;
        }
        return arr;
    }
```



### L136. 只出现一次的数字

**题目**:题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。  
说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**思路1**：使用哈希表对数组元素进行计数，最后遍历哈希表，找到计数为1的数。

```C++
int singleNumber(vector<int>& nums) {
    std::unordered_map<int,int> d;
    for(int i=0;i<nums.size();++i){
        if(d.find(nums[i])==d.end())
            d.insert({nums[i],1});
        else
            d[nums[i]]++;
    }
    for(auto [num,count] : d) if(count==1) return num;
    return 0;
}
```

**思路2**：使用异或运算。
  如何才能做到线性时间复杂度和常数空间复杂度呢？答案是使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。  
任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。   
任何数和其自身做异或运算，结果是 0，即 a⊕a=0。   
异或运算满足交换律和结合律，即 a⊕b⊕a = b⊕a⊕a = b⊕(a⊕a) = b⊕0=b。  
 因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。  

```C++
int singleNumber1(vector<int>& nums) {
        int result =0;
        for(int i=0;i<nums.size();++i)
            result ^= nums[i];
        return result;
}
```

### L169. 多数元素

**题目**：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。  
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**思路1**：采用哈希表（简单粗暴）

```C++
int majorityElement(vector<int>& nums) {
std::unordered_map<int,int> d;
for(int i=0;i<nums.size();++i){
    if(d.find(nums[i])==d.end())
	d.insert({nums[i],1});
    else
	d[nums[i]]++;
}
for(auto [num,count]:d){
    if(count>std::floor(nums.size()/2))
	return num;
}
return 0;
}
```

**思路2**：先排序，排序后数组的中间值肯定是众数。



**思路3**：分治算法。
如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。  
我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l / 2 + r / 2 次，
其中 l 和 r 分别是左半部分和右半部分的长度。由于 l / 2 + r / 2 <= (l + r) / 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。  
这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。  



**思路4**：Boyer-Moore 投票算法（重要）
Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：  
我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；  
我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：  
如果 x 与 candidate 相等，那么计数器 count 的值增加 1；  
如果 x 与 candidate 不等，那么计数器 count 的值减少 1。  
在遍历完成后，candidate 即为整个数组的众数。

```C++
int majorityElement(vector<int>& nums) {
    int condidate=nums[0];
    int count=0;
    for(int i=1;i<nums.size();++i){
        if(condidate==nums[i])
            count++;
        else
            count--;
        if(count<0){
            condidate=nums[i];
            count=0;
        }
    }
    return condidate;
}
```



### J39. 数组中出现次数超过一半的数字

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)**:  同L169。





### J40. 最小的k个数

**[题目](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)**：输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

 ```
示例 1：
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]

示例 2：
输入：arr = [0,1,2,1], k = 1
输出：[0]
 ```


限制：

0 <= k <= arr.length <= 10000
0 <= arr[i] <= 10000



**思路1**：排序。

先排序，使得数组从小到大递增；再截取前k个数作为输出。

时间复杂度：O(nlogn)，其中 nn 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。

空间复杂度：O(logn)，排序所需额外的空间复杂度为 O(logn)。



```C++
vector<int> getLeastNumbers(vector<int>& arr, int k) {
    if(k>arr.size())return {};
    std::sort(arr.begin(),arr.end());
    return vector<int>(arr.begin(),arr.begin()+k);
}
```



**思路2**：堆。

​	我们用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。

```C++
vector<int> getLeastNumbers(vector<int>& arr, int k) {
    if (k == 0) return {};
    vector<int> vec(k, 0);
    priority_queue<int> Q;
    for (int i = 0; i < k; ++i) //将k个元素插入到堆中
        Q.push(arr[i]);
    for (int i = k; i < (int)arr.size(); ++i) {//将剩余的元素与堆顶进行比较，再插入到堆中
        if (Q.top() > arr[i]) {
            Q.pop();
            Q.push(arr[i]);
        }
    }
    for (int i = 0; i < k; ++i) {//将元素从堆转移到数组中
        vec[i] = Q.top();
        Q.pop();
    }
    return vec;
}
```

时间复杂度：O(nlogk)，其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 O(logk) 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 O(nlogk) 的时间复杂度。

空间复杂度：O(k)，因为大根堆里最多 k 个数。



**思路3**：快排思想。

我们可以借鉴快速排序的思想。我们知道快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。

我们定义函数 `randomized_selected(arr, l, r, k)` 表示划分数组 arr 的 `[l,r]` 部分，使前 k 小的数在数组的左侧，在函数里我们调用快排的划分函数，假设划分函数返回的下标是 pos（表示分界值 pivot 最终在数组中的位置），即 pivot 是数组中第 pos - l + 1 小的数，那么一共会有三种情况：

* 如果 `pos - l + 1 == k`，表示 `pivot` 就是第 k 小的数，直接返回即可；

* 如果 `pos - l + 1 < k`，表示第 k 小的数在 pivot 的右侧，因此递归调用 `randomized_selected(arr, pos + 1, r, k - (pos - l + 1))`；

* 如果 `pos - l + 1 > k`，表示第 k 小的数在 pivot 的左侧，递归调用 `randomized_selected(arr, l, pos - 1, k)`。

函数递归入口为 `randomized_selected(arr, 0, arr.length - 1, k)`。在函数返回后，将前 k 个数放入答案数组返回即可。

  ```C++
class Solution {
    int partition(vector<int>& nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[i + 1], nums[r]);
        return i + 1;
    }

    // 基于随机的划分
    int randomized_partition(vector<int>& nums, int l, int r) {
        int i = rand() % (r - l + 1) + l;
        swap(nums[r], nums[i]);
        return partition(nums, l, r);
    }

    void randomized_selected(vector<int>& arr, int l, int r, int k) {
        if (l >= r) {
            return;
        }
        int pos = randomized_partition(arr, l, r);
        int num = pos - l + 1;
        if (k == num) {
            return;
        } else if (k < num) {
            randomized_selected(arr, l, pos - 1, k);
        } else {
            randomized_selected(arr, pos + 1, r, k - num);
        }
    }

public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        srand((unsigned)time(NULL));
        randomized_selected(arr, 0, (int)arr.size() - 1, k);
        vector<int> vec;
        for (int i = 0; i < k; ++i) {
            vec.push_back(arr[i]);
        }
        return vec;
    }
};
  ```

**时间复杂度**：期望为 O(n) ，由于证明过程很繁琐，所以不在这里展开讲。具体证明可以参考《算法导论》第 9 章第 2 小节。最坏情况下的时间复杂度为 O(n^2)。情况最差时，每次的划分点都是最大值或最小值，一共需要划分n−1 次，而一次划分需要线性的时间复杂度，所以最坏情况下时间复杂度为 O(n^2)

**空间复杂度**：期望为 O(logn)，递归调用的期望深度为 O(logn)，每层需要的空间为 O(1)，只有常数个变量。

最坏情况下的空间复杂度为 O(n)。最坏情况下需要划分 n 次，即 randomized_selected 函数递归调用最深 n−1 层，而每层由于需要 O(1) 的空间，所以一共需要 O(n) 的空间复杂度。







### L1. 两数之和

**题目**：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，
并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。  

**思路1**：遍历。  

```C++
vector<int> twoSum(vector<int>& nums, int target) {
    for(int i=0;i<nums.size();++i)
        for(int j=i+1;j<nums.size();++j)
            if(nums[i]+nums[j]==target)
                return vector<int>{i,j};
    return vector<int>{0,1};
}
```

**思路2**:哈希表。记录遍历过的值到哈希表。

```C++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int,int> d;
    for(int i=0;i<nums.size();++i){
        if(d.find(target-nums[i])!=d.end())
            return vector<int>{i,d[target-nums[i]]};
        if(d.find(nums[i])==d.end())
            d.insert({nums[i],i});
    }
    return vector<int>{0,1};
}
```



### L167. 两数之和 II - 输入有序数组

**题目**：给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

**思路1**：由于给定的是一个排序好的数组，则直接双指针。

```C++
vector<int> twoSum(vector<int>& numbers, int target) {
    for(int i=0,j=numbers.size()-1;i<j;){
        while(i<j && numbers[i]+numbers[j]>target)
            --j;
        if(numbers[i]+numbers[j] == target)
            return vector<int>{i+1,j+1};
        while(i<j && numbers[i]+numbers[j]<target)
            ++i;
    }
    return vector<int>();
}
```



**思路2**：二分查找。对于遍历每个元素numbers[i]，使用二分查找target - numbers[i]即可。时间复杂度为nlogn。





### L15. 三数之和

**题目**：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？
请你找出所有和为 0 且不重复的三元组。  
注意：答案中不可以包含重复的三元组。  

**思路1**:遍历法，双重循环，外层单指针，内双指针。时间复杂度O(n^2)  

```C++
int Partition(vector<int> &arr,int low,int high){
    int key=arr[low];
    while(low<high){
        while(low<high && arr[high]>=key)
            high--;
        arr[low]=arr[high];
        while(low<high && arr[low]<=key)
            low++;
        arr[high]=arr[low];
    }
    arr[low]=key;
    return low;
}
void QSort(vector<int> &arr,int low,int high){
    if(low < high){
        int parting = Partition(arr,low,high);
        QSort(arr,low,parting-1);
        QSort(arr,parting+1,high);
    }
}

vector<vector<int>> threeSum(vector<int>& nums) {
    const int n = nums.size();
    vector<vector<int>> output;
    //先排序
    QSort(nums,0,nums.size()-1);
    //外层单指针，内层双指针
    for (int first = 0; first < n; ++first) {
        if (first > 0 && nums[first] == nums[first - 1])  // 需要和上一次枚举的数不相同
            continue;
        int third = n - 1;// c 对应的指针初始指向数组的最右端
        int target = -nums[first];
        for (int second = first + 1; second < n; ++second) {
            if (second > first + 1 && nums[second] == nums[second - 1]) // 需要和上一次枚举的数不相同
                continue;
            while (second < third && nums[second] + nums[third] > target)  // 需要保证 b 的指针在 c 的指针的左侧
                --third;
            if (second == third)
                break;
            if (nums[second] + nums[third] == target)
                output.push_back({nums[first], nums[second], nums[third]});
        }
    }
    return output;
}
```


### L16. 最接近的三数之和

**题目**：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，
使它们的和与 target 最接近。 返回这三个数的和。  
假定每组输入只存在恰好一个解。

**思路1**: 直接暴力解法的时间复杂度时O(n^3)。同上一题一样，内层循环可以用双指针降低复杂度。  
为了使用双指针，需要首先对数组进行排序，复杂度为O(nlogn)。与上一题不同的是，不需要考虑重复的3元组。

```C++
int threeSumClosest(vector<int>& nums, int target) {
    std::sort(nums.begin(),nums.end());
    int closest_sum=0;
    int delta = INT_MAX;
    for(int i=0;i<nums.size();++i){
        int j=i+1,k=nums.size()-1;
        while(j<k){
            int sum = nums[i]+nums[j]+nums[k];
            if(std::abs(target-sum)<delta){
                delta = std::abs(target-sum);
                closest_sum = sum;
                if(delta==0)break;
            }
            if(sum<=target)
                j++;
            else if(sum>target)
                k--;
        }
    }
    return closest_sum;
}
```





### L18. 四数之和

**题目**：
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] 
（若两个四元组元素一一对应，则认为两个四元组重复）：  

* 0 <= a, b, c, d < n
* a、b、c 和 d 互不相同
* nums[a] + nums[b] + nums[c] + nums[d] == target
  你可以按 任意顺序 返回答案 。

**思路1**: 与L16差不多，外层是两个暴力双循环，内层是一个双指针。为了去掉重复的4元组，这里通过
集合set来保存结果。注意，本题还要考虑数据范围的问题。

```C++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> arr;
    if(nums.size()<4)
        return arr;
    std::set<vector<int>> num_set;
    //排序
    std::sort(nums.begin(),nums.end());
    //内外层双指针
    int n = nums.size();
    for(int i=0;i<n;++i){
        for(int j=i+1;j<n;++j){
            int k=j+1,l= n-1;
            while(k<l){
                int64_t sum = static_cast<int64_t>(nums[i])+static_cast<int64_t>(nums[j])+
                        static_cast<int64_t>(nums[k])+static_cast<int64_t>(nums[l]);
                if(sum==target){
                    num_set.insert({nums[i],nums[j],nums[k],nums[l]});
                    k++;
                }
                else if(sum>target) l--;
                else k++;
            }
        }
    }

    for(auto &v : num_set)
        arr.push_back(v);
    return arr;
}

```





### L724. 寻找数组的中心下标

**题目**：给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

**思路1**：暴力解法。从左到右遍历每一个可能的中心下标，计算左右两边的和，并判断两边是否相等。

```C++
int pivotIndex(vector<int>& nums) {
    int left_sum=0;
    int right_sum=0;
    for(int j=1;j<nums.size();++j) right_sum+=nums[j];//算法中心下标在0处的情况
    if(right_sum==0) return 0;

    for(int i=0;i<nums.size()-1;++i){
        left_sum+=nums[i];
        right_sum=0;
        for(int j=i+2;j<nums.size();++j) right_sum+=nums[j];
        if(left_sum==right_sum)
            return i+1;
    }
    return -1;
}
```

**思路2**：单层循环。只需要遍历一边中心下标即可，每次迭代时，更新左边的和，右边的和。

```C++
int pivotIndex(vector<int>& nums) {
    int left_sum=0;
    int right_sum=std::accumulate(nums.begin()+1,nums.end(),0);
    for(int i=0;i<nums.size();++i){
        if(left_sum == right_sum) return i;
        if(i==nums.size()-1) break;
        left_sum+=nums[i];
        right_sum -=nums[i+1];
    }
    return -1;
}
```











## 数组的合并和拆分



### J21. 调整数组顺序使奇数位于偶数前面

**[题目](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)**:  输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

 ```
示例：

输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
 ```


提示：

0 <= nums.length <= 50000
0 <= nums[i] <= 10000



**思路1**：首尾双指针，额外数组。

```C++
vector<int> exchange(vector<int>& nums) {
    vector<int> arr(nums.size());
    int index_o=0,index_e=nums.size()-1;
    for(int i=0;i<nums.size();++i){
        if(nums[i]%2==1){
            arr[index_o]=nums[i];
            index_o++;
        }
        else{
            arr[index_e]=nums[i];
            index_e--;
        }
    }
    return arr;
}
```



**思路2**：首尾双指针，原地交换。

```C++
vector<int> exchange(vector<int>& nums) {
    int left=0,right=nums.size()-1;
    while(left<right){
        while(left<right && nums[left]%2==1)left++;
        while(left<right && nums[right]%2==0)right--;
        std::swap(nums[left],nums[right]);
        left++;
        right--;
    }
    return nums;
}
```



**思路3**：快慢双指针。

定义快慢双指针 fast 和 low ，fast 在前， low 在后 .
fast的作用是向前搜索奇数位置，low 的作用是指向下一个奇数应当存放的位置
fast 向前移动，当它搜索到奇数时，将它和 nums[low] 交换，此时 low 向前移动一个位置 .
重复上述操作，直到 fast 指向数组末尾 .

```C++
vector<int> exchange(vector<int>& nums) {
    int low = 0, fast = 0;
    while (fast < nums.size()) {
        if (nums[fast] & 1) {
            swap(nums[low], nums[fast]);
            low ++;
        }
        fast ++;
    }
    return nums;
}
```







### L349. 两个数组的交集

**题目**: 给定两个数组，编写一个函数来计算它们的交集。 

说明：

- 输出结果中的每个元素一定是唯一的。
- 我们可以不考虑输出结果的顺序。

**思路1**：使用两个哈希集合，第一个哈希集合存放第一个数组的元素，第二个哈希集合存放 交集元素。最后再把第二个哈希集合转移到输出数组中。

```C++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    std::unordered_set<int> hash_set,out_set;
    std::vector<int> arr;
    for(int i=0;i<nums1.size();++i)
        hash_set.insert(nums1[i]);
    for(int i=0;i<nums2.size();++i)
        if(hash_set.count(nums2[i])>0)
            out_set.insert(nums2[i]);
    for(auto e:out_set) arr.push_back(e);
    return arr;
}
```

**思路2**： 排序+双指针。首先对两个数组进行排序，然后分别对两个数组设置一个指针，用于指向正在比较的数组的元素。对于每个指针，还需要判断去掉重复的元素。

```C++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    std::sort(nums1.begin(),nums1.end());
    std::sort(nums2.begin(),nums2.end());
    vector<int> arr;
    for(int i=0,j=0;i<nums1.size()&&j<nums2.size();){
        if(i>0 && nums1[i]==nums1[i-1]){
            ++i;
            continue;
        }
        if(j>0 && nums2[j]==nums2[j-1]){
            ++j;
            continue;
        }
        if(nums1[i]==nums2[j]){
            arr.push_back(nums1[i]);
            ++i;
            ++j;
        }
        else if(nums1[i]<nums2[j]){
            ++i;
        }
        else{
            ++j;
        }
    }
    return arr;
}
```





### L56. 合并区间

**题目**：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**思路1**：暴力法，双重循环比较两个之间是否重叠。该方法会“超出时间限制”。

**思路2**：（这道题第9次提交才对）首先对输入的区间数组进行排序，则重叠的区间肯定相邻。遍历一遍，对相邻重叠区间进行合并。当第i个区间与i+1个区间不相邻时，将第i个区间添加到输出数组。

```C++
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    int n=intervals.size();
    if(n==1)
        return vector<vector<int>>{intervals[0]};
    std::sort(intervals.begin(),intervals.end());
    vector<vector<int>> output;
    for(int i=0;i<intervals.size()-1;++i){
        if(intervals[i][1]>=intervals[i+1][0]){//i和i+1重叠
            intervals[i+1][0] = intervals[i][0];
            intervals[i+1][1] = std::max(intervals[i][1],intervals[i+1][1]);
        }else{
            output.push_back(intervals[i]);
        }
    }
    if(intervals[n-2][1]>=intervals[n-1][0]){//n-1和n-2重叠
        intervals[n-1][0] = intervals[n-2][0];
        intervals[n-1][1] = std::max(intervals[n-2][1],intervals[n-1][1]);
    }
    output.push_back(intervals[n-1]);
    return output;
}
```









### L561. 数组拆分I

给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。

返回该 最大总和 。

```
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```



**思路1**：首先进行排序，得到升序数组，0-1,2-3, 4-5 ...划分为一组。因此结果为第0个、第2个、第4个...元素的和。

```C++
int arrayPairSum(vector<int>& nums) {
    std::sort(nums.begin(),nums.end());
    int sum=0;
    for(int i=0;i<nums.size();i+=2)
        sum+=nums[i];
    return sum;
}
```





## 矩阵的搜索

### J04. 二维数组中的查找

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)**: 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 ```
示例:
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
 ```

限制：

0 <= n <= 1000

0 <= m <= 1000



**思路1**：暴力法。

遍历二维数组，时间复杂度O(n*m)



**思路2**：线性查找法。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。

若数组为空，返回 false
初始化行下标为 0，列下标为二维数组的列数减 1
重复下列步骤，直到行下标或列下标超出边界
获得当前下标位置的元素 num
如果 num 和 target 相等，返回 true
如果 num 大于 target，列下标减 1
如果 num 小于 target，行下标加 1
循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false

```C++
bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
    if(matrix.empty()) return false;
    for(int i=0,j=matrix[0].size()-1;i<matrix.size() && j>=0;){
        if(matrix[i][j]==target)
            return true;
        else if(matrix[i][j]<target)
            ++i;
        else if(matrix[i][j]>target)
            --j;
    }
    return false;
}
```





### L54. 螺旋矩阵

**[题目](https://leetcode-cn.com/problems/spiral-matrix/)**：给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 ```
示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
 ```

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
示例 2：
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

提示：

```
m == matrix.length
n == matrix[i].length
1 <= m, n <= 10
-100 <= matrix[i][j] <= 100
```



**思路1**：观察法。

观察下面的例子：

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

可知，打印的顺序为：

1 2 3 4

8 12

11 10 9

5

6 7

设矩阵的宽为cols, 高为rows，则每一圈，各步骤打印的长度为：

cols

rows-1

cols-1

rows-2

根据这个规律，得到的代码如下：

```C++
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    int rows=matrix.size(),cols=matrix[0].size();
    int size = rows*cols;
    vector<int> arr;
    int r=0,c=0;//（r,c）表示每一步的起点
    rows--;
    while(true){
        //printf("r:%d c:%d rows:%d cols:%d\n",r,c,rows,cols);
        for(int i=0;i<cols;++i)arr.push_back(matrix[r][c+i]);
        c+= cols-1;
        r++;
        cols--;
        if(arr.size()==size)break;

        for(int i=0;i<rows;++i)arr.push_back(matrix[r+i][c]);
        c--;
        r += rows-1;
        rows--;
        if(arr.size()==size)break;

        for(int i=0;i<cols;++i)arr.push_back(matrix[r][c-i]);
        c -= (cols-1);
        r--;
        cols--;
        if(arr.size()==size)break;

        for(int i=0;i<rows;++i)arr.push_back(matrix[r-i][c]);
        c++;
        r -= (rows-1);
        rows--;
        if(arr.size()==size)break;
    }
    return arr;
}
```



**思路2**：模拟螺旋矩阵的路径。

可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。

判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 \textit{visited}visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 \textit{visited}visited 中的对应位置的元素设为已访问。

如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

```C++
class Solution {
private:
    static constexpr int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0)
            return {};
        int rows = matrix.size(), columns = matrix[0].size();
        //辅助数组，标志是否访问过该元素
        vector<vector<bool>> visited(rows, vector<bool>(columns));
        int total = rows * columns;
        vector<int> order(total);
        int row = 0, column = 0;
        int directionIndex = 0;
        for (int i = 0; i < total; i++) {
            order[i] = matrix[row][column];
            visited[row][column] = true;
            //判断是否应该转换方向
            int nextRow = row + directions[directionIndex][0];
            int nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn])
                directionIndex = (directionIndex + 1) % 4;//换一个方向
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
};
```



**思路3**：按层遍历。

可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。

定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。

```
[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]
```

​	对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 (top,left)，右下角位于(bottom,right)，按照如下顺序遍历当前层的元素。从左到右遍历上侧元素，依次为 (top,left) 到(top,right)。

从上到下遍历右侧元素，依次为(top+1,right) 到 (bottom,right)。

如果 left<right 且top<bottom，则从右到左遍历下侧元素，依次为(bottom,right−1) 到 (bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到 (top+1,left)。

遍历完当前层的元素之后，将 left 和top 分别增加 11，将right 和 bottom 分别减少 11，进入下一层继续遍历，直到遍历完所有元素为止。

```c++
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    if(matrix.size()==0 || matrix[0].size()==0) return {};
    int rows=matrix.size(), cols=matrix[0].size();
    vector<int> arr;
    int left=0,right=cols-1,top=0,bottom=rows-1;
    while(left<=right && top<=bottom){
        //从左上角到右上角
        for(int i=left;i<=right;++i) arr.push_back(matrix[top][i]);
        //从右上角到右下角
        for(int i=top+1;i<=bottom;++i) arr.push_back(matrix[i][right]);
        if(left==right || top==bottom) //为了防止重复遍历
            break;
        //从右下角到左下角
        for(int i=right-1;i>=left;--i) arr.push_back(matrix[bottom][i]);
        //从左下角到左上角
        for(int i=bottom-1;i>top;--i) arr.push_back(matrix[i][left]);
        top++;
        bottom--;
        left++;
        right--;
    }
    return arr;
}
```



### J29. 顺时针打印矩阵

**[题目](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)**: 同上L54







# 2. 链表

## 基础知识











## 搜索

### J22. 链表中倒数第k个节点

**[题目](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)**：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

 ```
示例：
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.
 ```



**思路1**：双指针，让其中一个指针先走k步。

```C++
ListNode* getKthFromEnd(ListNode* head, int k) {
    int index=0;
    auto curr=head;
    auto prev=head;
    while(curr){
        if(index < k){
            index++;
            curr=curr->next;
        }
        else{
            curr=curr->next;
            prev=prev->next;
        }
    }
    return prev;
}
```



**思路2**：两次遍历。

第一次首先计算出链表的长度n，第二次遍历到n-k处。

```C++
ListNode* getKthFromEnd(ListNode* head, int k) {
    int n=0;
    auto node=head;
    while(node){
        ++n;
        node=node->next;
    }
    node=head;
    int index=n-k;
    while(index>0){
        node=node->next;
        index--;
    }
    return node;
}
```



## 插入和删除



### J18. 删除链表的节点

**[题目](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)**: 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

```
示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```


说明：

题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点



**思路**：

```C++
ListNode* deleteNode(ListNode* head, int val) {
    if(!head)return head;
    if(head->val==val)return head->next;
    auto node=head;
    while(node->next){
        if(node->next->val == val){
            node->next = node->next->next;
            break;
        }
        node=node->next;
    }
    return head;
}
```





### L203. 移除链表元素

**题目**：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。   

**思路**：首先找到第一个不是val的节点，作为新链表的头节点。然后定义两个节点prev和p，p用来判断是否是val，prev用来当删除
p时保存链表的连接。

```C++
ListNode* removeElements(ListNode* head, int val) {
    struct ListNode* dummyHead = new ListNode(0, head);
    struct ListNode* temp = dummyHead;
    while (temp->next != NULL) {
        if (temp->next->val == val) {
            temp->next = temp->next->next;
        } else {
            temp = temp->next;
        }
    }
    return dummyHead->next;
}
```





### L83. 删除排序链表中的重复元素

**题目**：存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。
返回同样按升序排列的结果链表。

**思路**：定义一个while循环，当p->next && p->val == p->next->val 删除p即可。  
**解法**：

```C++
ListNode* deleteDuplicates(ListNode* head) {
    auto p = head;
    while(p){
        while(p->next && p->val == p->next->val){
            auto tmp =p->next;
            p->next = p->next->next;
            delete tmp;
        }
        if(p)
            p = p->next;
        else
            break;
    }
    return head;
}
```





### L19. 删除链表的倒数第N个节点

**[题目](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)**：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

 ```
示例 1：
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

示例 2：
输入：head = [1], n = 1
输出：[]

示例 3：
输入：head = [1,2], n = 1
输出：[1]
 ```


提示：

链表中结点的数目为 sz
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz



**思路1**：双指针。

先令一个curr指针先走n+1步。

然后使curr指针和prev指针同时前进，当curr指针到结尾时，prev指针刚好是要删除节点的前一个节点。

注意这里需要区分是否删除的是头节点。判断是不是头节点的方法是令curr走n步之后，判断是否为空。

```C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    if(!head)return head;
    auto prev=head;
    auto curr=head;
    for(int i=0;i<n && curr;++i)
        curr=curr->next;//curr先前进了n步
    if(!curr){//前进n步就为null，表明要删除的是头节点
        auto tmp=head;
        head=head->next;
        delete tmp;
    }
    else{
        //为了删除curr，需要curr再前进一步，使得curr比prev多前进n+1步
        curr=curr->next;
        while(prev && curr){
            prev=prev->next;
            curr=curr->next;
        }
        auto tmp=prev->next;
        prev->next=prev->next->next;
        delete tmp;
    }

    return head;
}
```
另一种实现方法：创建新的头节点指针。

```C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0, head);
    ListNode* first = head;
    ListNode* second = dummy;
    for (int i = 0; i < n; ++i) 
        first = first->next;
    while (first) {
        first = first->next;
        second = second->next;
    }
    second->next = second->next->next;
    ListNode* ans = dummy->next;
    delete dummy;
    return ans;
}
```



**思路2**：栈。

```C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0, head);
    stack<ListNode*> stk;
    ListNode* cur = dummy;
    while (cur) {
        stk.push(cur);
        cur = cur->next;
    }
    for (int i = 0; i < n; ++i) {
        stk.pop();
    }
    ListNode* prev = stk.top();
    prev->next = prev->next->next;
    ListNode* ans = dummy->next;
    delete dummy;
    return ans;
}
```



**思路3**：计算链表长度。

```C++
int getLength(ListNode* head) {
    int length = 0;
    while (head) {
        ++length;
        head = head->next;
    }
    return length;
}

ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0, head);
    int length = getLength(head);
    ListNode* cur = dummy;
    for (int i = 1; i < length - n + 1; ++i) {
        cur = cur->next;
    }
    cur->next = cur->next->next;
    ListNode* ans = dummy->next;
    delete dummy;
    return ans;
}
```





## 反转



### L206. 反转链表

**题目**：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 



**思路1**：迭代，设置前向和后向迭代两个指针。

​	假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。 在遍历链表时，将当前节点的 next 指针改为
指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后
返回新的头引用。  
代码：  

```C++
ListNode* reverseList(ListNode* head) {
    if(!head)return head;
    auto prev=head;//反转链表的指针
    auto curr=head;//前向链表的指针
    while(curr){
        auto tmp=curr;//记录前向链表
        curr=curr->next;//前向
        tmp->next=prev;
        prev=tmp;
    }
    head->next=NULL;
    return prev;
}
```



**思路2**：递归。

```C++
ListNode* reverseList(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode* newHead = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return newHead;
}
```



**思路3**：栈。

使用栈保存遍历得到的节点。

```C++
ListNode* reverseList(ListNode* head) {
    if(!head)return head;
    std::stack<ListNode*> stk;
    auto node=head;
    while(node){
        stk.push(node);
        node=node->next;
    }
    auto r_head=stk.top();
    stk.pop();
    node=r_head;
    while(!stk.empty()){
        node->next = stk.top();
        stk.pop();
        node=node->next;
        node->next=NULL;
    }
    return r_head;
}
```





### J24. 反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

 ```
示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
 ```


限制：

0 <= 节点个数 <= 5000



解法：同L206





## 合并



### L21. 合并两个有序链表

**[题目]( https://leetcode-cn.com/problems/merge-two-sorted-lists/)**：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```
示例 1：
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

示例 2：
输入：l1 = [], l2 = []
输出：[]

示例 3：
输入：l1 = [], l2 = [0]
输出：[0]
```


提示：

两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列



**思路1**：双指针。

我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。  

```C++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if(!list1)return list2;
    else if(!list2) return list1;
    auto node1=list1;
    auto node2=list2;
    //计算头节点
    ListNode* list3=nullptr;
    if(node1->val < node2->val){
        list3=node1;
        node1=node1->next;
    }
    else{
        list3=node2;
        node2=node2->next;
    }
    //双指针循环
    auto node3=list3;
    while(true){
        if(!node1){
            node3->next = node2;
            break;
        }
        else if(!node2){
            node3->next = node1;
            break;
        }
        else{
            if(node1->val < node2->val){
                node3->next = node1;
                node1=node1->next;
                node3=node3->next;
                node3->next=nullptr;
            }
            else{
                node3->next = node2;
                node2=node2->next;
                node3=node3->next;
                node3->next=nullptr;
            }
        }
    }
    return list3;
}
```



代码简化版：

```C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    auto l3=new ListNode(3);
    auto prev=l3;
    while(l1 && l2){
        if(l1->val < l2->val){
            prev->next=l1;
            l1=l1->next;
        }
        else{
            prev->next=l2;
            l2=l2->next;
        }
        prev=prev->next;
    }
    prev->next = l1?l1:l2;
    prev=l3->next;
    delete l3;
    return prev;
}
```



**思路2**：递归法。

我们直接将以上递归过程建模，同时需要考虑边界情况。

如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

```C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    if (l1 == nullptr) {
        return l2;
    } else if (l2 == nullptr) {
        return l1;
    } else if (l1->val < l2->val) {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    } else {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}
```



### J25. 合并两个排序的链表

题目和答案：同L21





## 环形链表



### L141. 环形链表

**[题目](https://leetcode-cn.com/problems/linked-list-cycle/)**：给你一个链表的头节点 head ，判断链表中是否有环。  
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，
评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链
表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。  
如果链表中存在环，则返回 true 。 否则，返回 false 。  

```
示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```


提示：

```
链表中节点的数目范围是 [0, 104]
-105 <= Node.val <= 105
pos 为 -1 或者链表中的一个 有效索引 。
```



**思路1**:  哈希表  

```C++
bool hasCycle(ListNode *head) {
    std::unordered_set<ListNode*> hash_set;
    auto node=head;
    while(node){
        if(hash_set.find(node)!=hash_set.end())
            return true;
        else
            hash_set.insert(node);
        node=node->next;
    }
    return false;
}
```



**思路2**： Floyd 判圈算法 

​	我们先设置慢指针 slow 和快指针 fast ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 slow 放置起点 0，两个指针每次同时移动一步，相遇的点就是答案。 

​	这里简单解释为什么后面将 slow 放置起点后移动相遇的点就一定是答案了。假设环长为 L，从起点到环的入口的步数是 a，从环的入口继续走 b 步到达相遇位置，从相遇位置继续走 c 步回到环的入口，则有 b+c=L，其中 L、a、b、c 都是正整数。根据上述定义，慢指针走了a+b 步，快指针走了 2(a+b)步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 a+b+kL，其中 k 表示快指针在环上走的圈数。联立等式，可以得到2(a+b)=a+b+kL解得 a=kL-b，整理可得 a=(k-1)L+(L-b)=(k-1)L+c  。从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 a 步之后到达环的入口，快指针在环里走了 k−1 圈之后又走了 c 步，由于从相遇位置继续走 c 步即可回到环的入口，因此快指针也到达环的入口。两个指针在 环的入口相遇，相遇点就是答案。  

注意特点： 适用于判断图，判断环路，有且只有一个环的情况。图中有且只有一个点存在两个入度为 1，其他入度均为 0。  

```C++
bool hasCycle(ListNode *head) {
    if(!head || !head->next)return false;
    auto prev=head;//走一步的指针
    auto curr=head;//走两步的指针
    while(curr && curr->next){
        prev=prev->next;
        curr=curr->next->next;
        if(prev==curr) return true;
    }
    return false;
}
```





### L142. 环形链表 II

**[题目](https://leetcode-cn.com/problems/linked-list-cycle-ii/)**: 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

 ```
示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
 ```


提示：

链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引



**思路1**：哈希集合。

```C++
ListNode *detectCycle(ListNode *head) {
    std::unordered_set<ListNode*> hash_set;
    while(head){
        if(hash_set.find(head)!=hash_set.end())
            return head;
        else
            hash_set.insert(head);
        head=head->next;
    }
    return nullptr;
}
```



**思路2**：Floyd 判圈算法

分析同L141。

​	假设环长为 `L`，从起点到环的入口的步数是 `a`，从环的入口继续走 `b` 步到达相遇位置，从相遇位置继续走 `c` 步回到环的入口，则有 `b+c=L`，其中 `L、a、b、c `都是正整数。根据上述定义，慢指针走了`a+b` 步，快指针走了 `2(a+b)`步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 `a+b+kL`，其中 `k `表示快指针在环上走的圈数。

​	联立等式，可以得到`2(a+b)=a+b+kL`解得 `a=kL-b`，整理可得 `a=(k-1)L+(L-b)=(k-1)L+c ` 。

​	**即在两个指针相遇后，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了` a `步之后到达环的入口，快指针在环里走了 `k−1` 圈之后又走了 `c` 步，由于从相遇位置继续走 `c `步即可回到环的入口，因此快指针也到达环的入口。两个指针在 环的入口相遇，相遇点就是答案。**  

```C++
ListNode *detectCycle(ListNode *head) {
    auto slow=head;
    auto fast=head;
    while(fast && fast->next){
        fast=fast->next->next;
        slow=slow->next;
        if(fast==slow){//到达相遇点
            slow=head;//slow重头开始走
            while(slow!=fast){//slow==fast即为入口点
                slow=slow->next;
                fast=fast->next;
            }
            return slow;
        }
    }
    return nullptr;
}
```





### JII 22.链表中环的入口节点

**[题目](https://leetcode-cn.com/problems/c32eOV/)**：同上（L142）





## 复杂链表

### L138. 复制带随机指针的链表

**[题目](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)**：给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **深拷贝**。 深拷贝应该正好由 n 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。

返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

* val：一个表示 Node.val 的整数。
* random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
  你的代码 只 接受原链表的头节点 head 作为传入参数。

 ```
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

示例 2：
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]

示例 3：
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
 ```


提示：

0 <= n <= 1000
-104 <= Node.val <= 104
Node.random 为 null 或指向链表中的节点。



**思路1**：迭代+哈希表实现。

​	在复制新的节点时，将旧节点和对应的新节点放入哈希表中，成为键值对。其中旧节点是key，新节点是值。

​	创建所有的新节点完成后，遍历旧链表，根据哈希表，查询每个旧节点的random指针，设置新节点的random指针，即：`cnode->random = hash_map[node->random]`。

```C++
Node* copyRandomList(Node* head) {
    if(!head) return NULL;
    Node* chead=new Node(head->val);

    std::unordered_map<Node*,Node*> hash_map;//用于映射：old node -> new node
    hash_map.insert({head,chead});

    //构建新的链表
    auto prev = chead;
    auto node = head->next;
    while(node){
        Node* new_node=new Node(node->val);
        hash_map.insert({node,new_node});
        prev->next = new_node;
        prev = prev->next;
        node = node->next;
    }
    //设置新链表的random指针
    node=head;
    auto cnode = chead;
    while(node){
        if(node->random){
            cnode->random = hash_map[node->random];
        }
        else{
            cnode->random=NULL;
        }
        node = node->next;
        cnode = cnode->next;
    }
    return chead;
}
```



**思路2**：回溯+哈希表实现。

本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。

具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。

在实际代码中，我们需要特别判断给定节点为空节点的情况。

```C++
class Solution {
private:
    std::unordered_map<Node*,Node*> hash_map;
public:
    Node* copyRandomList(Node* head) {
        if(!head)
            return NULL;
        if(auto cnode=hash_map.find(head); cnode==hash_map.end()){
            Node* new_node=new Node(head->val);
            hash_map.insert({head,new_node});
            new_node->next = copyRandomList(head->next);
            new_node->random = copyRandomList(head->random);
            return new_node;
        }
        else{
            return cnode->second;
        }
    }
};
```



**思路3**：迭代+节点拆分

注意到方法一需要使用哈希表记录每一个节点对应新节点的创建情况，而我们可以使用一个小技巧来省去哈希表的空间。

我们首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 A→B→C，我们可以将其拆分为 'A→A′ →B→B′ →C→C′ 。对于任意一个原节点 S，其拷贝节点 S' 即为其后继节点。

这样，我们可以直接找到每一个拷贝节点 S' 的随机指针应当指向的节点，即为其原节点 S 的随机指针指向的节点 T 的后继节点 T'。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。

当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。

```C++
Node* copyRandomList(Node* head) {
    if (head == nullptr) {
        return nullptr;
    }
    //拷贝每个节点
    for (Node* node = head; node != nullptr; node = node->next->next) {
        Node* nodeNew = new Node(node->val);
        nodeNew->next = node->next;
        node->next = nodeNew;
    }
    //为每个拷贝节点 设置随机指针
    for (Node* node = head; node != nullptr; node = node->next->next) {
        Node* nodeNew = node->next;
        nodeNew->random = (node->random != nullptr) ? node->random->next : nullptr;
    }
    //将拷贝节点从原链表中拆分出来
    Node* headNew = head->next;
    for (Node* node = head; node != nullptr; node = node->next) {
        Node* nodeNew = node->next;
        node->next = node->next->next;
        nodeNew->next = (nodeNew->next != nullptr) ? nodeNew->next->next : nullptr;
    }
    return headNew;
}
```









### J35. 复杂链表的复制

**[题目](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)**：同L138.





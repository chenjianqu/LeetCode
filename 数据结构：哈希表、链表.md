**哈希表**
**链表**
**查找**





# 哈希表

## 基础知识





## 题目

### L705. 设计哈希集合
**题目**：不使用任何内建的哈希表库设计一个哈希集合（HashSet）。  
实现 MyHashSet 类：
void add(key) 向哈希集合中插入值 key 。  
bool contains(key) 返回哈希集合中是否存在这个值 key 。  
void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。  

**思路1**：使用数组作为容器，一开始就设置数组的容量。使用除留余数法作为哈希函数。使用链地址法解决哈希冲突。即
数组的每个元素是一个list，这样增删比较方便。

```C++
class MyHashSet {
public:
    MyHashSet() {
        data.resize(kSize);
    }
    int hash(int key){
        return key%kSize;
    }
    void add(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it)
            if(*it == key)
                return;
        data[index].push_back(key);
    }
    void remove(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(*it == key){
                data[index].erase(it);
                return;
            }
        }
    }
    bool contains(int key) {
        int index = hash(key);
        for(auto p: data[index]) if(p==key) return true;
        return false;
    }
private:
    vector<list<int>> data;
    static constexpr int kSize=1000;
};
```

**思路2**：使用一个**数组**来表示哈希集。数组中的每个元素都是一个桶。在每个桶中，我们使用 vector来存储所有值。

```C++
#define MAX_LEN 100000          // the amount of buckets
class MyHashSet {
private:
    vector<int> set[MAX_LEN];   // hash set implemented by array
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        // Each bucket contains a list. Iterate all the elements in the bucket to find the target key.
        for (int i = 0; i < set[index].size(); ++i) 
            if (set[index][i] == key) 
                return i;
        return -1;
    }
public:
    MyHashSet() {
    }
    
    void add(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) set[index].push_back(key);
    }
    
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) set[index].erase(set[index].begin() + pos);
    }
    /** Returns true if this set did not already contain the specified element */
    bool contains(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        return pos >= 0;
    }
};
```





### L706. 设计哈希映射

**题目**：不使用任何内建的哈希表库设计一个哈希映射（HashMap）。  
实现 MyHashMap 类：  
MyHashMap() 用空映射初始化对象  
void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。  
int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。  
void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。  

**思路1**：使用数组作为容器，一开始就设置数组的容量。使用除留余数法作为哈希函数。使用链地址法解决哈希冲突。即
数组的每个元素是一个list，这样增删比较方便。
```C++
class MyHashMap {
public:
    MyHashMap() {
        data.resize(kSize);
    }
    int hash(int key){
        return key%kSize;
    }
    void put(int key, int value) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(it->first==key){
                it->second = value;
                return;
            }
        }
        data[index].push_back({key,value});
    }
    
    int get(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(it->first==key){
                return it->second;
            }
        }
        return -1;
    }
    
    void remove(int key) {
        int index = hash(key);
        for(auto it=data[index].begin();it!=data[index].end();++it){
            if(it->first==key){
                data[index].erase(it);
                return;
            }
        }
    }
private:
    vector<list<pair<int,int>>> data;
    static constexpr int kSize=1000;
};
```

**思路2**：使用一个**数组**来表示哈希集。数组中的每个元素都是一个桶。在每个桶中，我们使用 vector来存储所有值。

```C++
#define MAX_LEN 100000            // the amount of buckets

class MyHashMap {
private:
    vector<pair<int, int>> map[MAX_LEN];       // hash map implemented by array
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        for (int i = 0; i < map[index].size(); ++i) 
            if (map[index][i].first == key) 
                return i;
        return -1;
    }
public:
    /** Initialize your data structure here. */
    MyHashMap() {
    }
    /** value will always be positive. */
    void put(int key, int value) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            map[index].push_back(make_pair(key, value));
        } else {
            map[index][pos].second = value;
        }
    }
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    int get(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) 
            return -1;
         else 
            return map[index][pos].second;
    }
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) 
            map[index].erase(map[index].begin() + pos);
    }
};
```









### L202. 快乐数

**题目**：难度简单769收藏分享切换为英文接收动态反馈

编写一个算法来判断一个数 `n` 是不是快乐数。

「快乐数」定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果 **可以变为** 1，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**思路1**：通过哈希集合std::unordered_set记录每次迭代中中平方和num，若发现哈希集合中已经存在了该值，则返回false。

```C++
bool isHappy(int n) {
    if(n==1)
        return true;
    else if(n==0)
        return false;
    int num=0;
    std::unordered_set<int> hash_set;
    while(true){
        while(n>0){//split
            num += std::pow(n%10,2);
            n/=10;
        }
        if(num==1)
            return true;
        if(hash_set.count(num)>0)
            return false;
        hash_set.insert(num);
        n=num;
        num=0;
    }
    return false;
}
```

**思路2**：使用快慢指针法。通过反复调用 getNext(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 getNext(n) 函数获得。

意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。

不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。

我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。

如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。

如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。





### L75. 颜色分类
**题目**:
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。  
**思路1：**: 最简单粗暴的方法是，直接使用排序算法，进行升序排列。
```C++
//快速排序
void QSort(vector<int> &nums,int low,int high){
    static auto partition = [](vector<int> &arr,int left,int right){
        int key = arr[left];
        while(left<right){
            while(left < right && arr[right]>=key) right--;
            arr[left]=arr[right];
            while(left<right && arr[left]<=key) left++;
            arr[right] = arr[left];
        }
        arr[left] = key;
        return left;
    };
    if(low>=high) return;
    int mid = partition(nums,low,high);
    QSort(nums,low,mid-1);
    QSort(nums,mid+1,high);
}


void sortColors(vector<int>& nums) {
    QSort(nums,0,nums.size()-1);
}
```

**思路2**：这是一个荷兰国旗问题。单指针，遍历两次，第一次遍历将0 交换到数组的前部，第二次遍历将1 交换到0后数组的中间区域。
```C++
void sortColors(vector<int>& nums) {
    int k=0;
    for(int i=0;i<nums.size();++i){
        if( nums[i]==0){
            std::swap(nums[i],nums[k]);
            k++;
        }
    }
    for(int i=k;i<nums.size();++i){
        if( nums[i]==1){
            std::swap(nums[i],nums[k]);
            k++;
        }
    }
}
```

**思路3**：采用双指针，一个从前往后，一个从后往前同时遍历。
```C++
void sortColors(vector<int>& nums) {
    int k = nums.size()-1;
    int j=0;
    for(int i=0;i<=k;++i){
        while(i<=k && nums[i]==2){
            std::swap(nums[i],nums[k]);
            k--;
        }
        if(nums[i]==0){
            std::swap(nums[i],nums[j]);
            j++;
        }
    }
}
```



# 链表

## 基础知识











## 搜索

### J22. 链表中倒数第k个节点

**[题目](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)**：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

 ```
示例：
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.
 ```



**思路1**：双指针，让其中一个指针先走k步。

```C++
ListNode* getKthFromEnd(ListNode* head, int k) {
    int index=0;
    auto curr=head;
    auto prev=head;
    while(curr){
        if(index < k){
            index++;
            curr=curr->next;
        }
        else{
            curr=curr->next;
            prev=prev->next;
        }
    }
    return prev;
}
```



**思路2**：两次遍历。

第一次首先计算出链表的长度n，第二次遍历到n-k处。

```C++
ListNode* getKthFromEnd(ListNode* head, int k) {
    int n=0;
    auto node=head;
    while(node){
        ++n;
        node=node->next;
    }
    node=head;
    int index=n-k;
    while(index>0){
        node=node->next;
        index--;
    }
    return node;
}
```



## 插入和删除



### J18. 删除链表的节点

**[题目](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)**: 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

```
示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```


说明：

题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点



**思路**：

```C++
ListNode* deleteNode(ListNode* head, int val) {
    if(!head)return head;
    if(head->val==val)return head->next;
    auto node=head;
    while(node->next){
        if(node->next->val == val){
            node->next = node->next->next;
            break;
        }
        node=node->next;
    }
    return head;
}
```





### L203. 移除链表元素

**题目**：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。   

**思路**：首先找到第一个不是val的节点，作为新链表的头节点。然后定义两个节点prev和p，p用来判断是否是val，prev用来当删除
p时保存链表的连接。

```C++
ListNode* removeElements(ListNode* head, int val) {
    struct ListNode* dummyHead = new ListNode(0, head);
    struct ListNode* temp = dummyHead;
    while (temp->next != NULL) {
        if (temp->next->val == val) {
            temp->next = temp->next->next;
        } else {
            temp = temp->next;
        }
    }
    return dummyHead->next;
}
```





### L83. 删除排序链表中的重复元素

**题目**：存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。
返回同样按升序排列的结果链表。

**思路**：定义一个while循环，当p->next && p->val == p->next->val 删除p即可。  
**解法**：

```C++
ListNode* deleteDuplicates(ListNode* head) {
    auto p = head;
    while(p){
        while(p->next && p->val == p->next->val){
            auto tmp =p->next;
            p->next = p->next->next;
            delete tmp;
        }
        if(p)
            p = p->next;
        else
            break;
    }
    return head;
}
```





### L19. 删除链表的倒数第N个节点

**[题目](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)**：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

 ```
示例 1：
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

示例 2：
输入：head = [1], n = 1
输出：[]

示例 3：
输入：head = [1,2], n = 1
输出：[1]
 ```


提示：

链表中结点的数目为 sz
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz



**思路1**：双指针。

先令一个curr指针先走n+1步。

然后使curr指针和prev指针同时前进，当curr指针到结尾时，prev指针刚好是要删除节点的前一个节点。

注意这里需要区分是否删除的是头节点。判断是不是头节点的方法是令curr走n步之后，判断是否为空。

```C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    if(!head)return head;
    auto prev=head;
    auto curr=head;
    for(int i=0;i<n && curr;++i)
        curr=curr->next;//curr先前进了n步
    if(!curr){//前进n步就为null，表明要删除的是头节点
        auto tmp=head;
        head=head->next;
        delete tmp;
    }
    else{
        //为了删除curr，需要curr再前进一步，使得curr比prev多前进n+1步
        curr=curr->next;
        while(prev && curr){
            prev=prev->next;
            curr=curr->next;
        }
        auto tmp=prev->next;
        prev->next=prev->next->next;
        delete tmp;
    }

    return head;
}
```
另一种实现方法：创建新的头节点指针。

```C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0, head);
    ListNode* first = head;
    ListNode* second = dummy;
    for (int i = 0; i < n; ++i) 
        first = first->next;
    while (first) {
        first = first->next;
        second = second->next;
    }
    second->next = second->next->next;
    ListNode* ans = dummy->next;
    delete dummy;
    return ans;
}
```



**思路2**：栈。

```C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0, head);
    stack<ListNode*> stk;
    ListNode* cur = dummy;
    while (cur) {
        stk.push(cur);
        cur = cur->next;
    }
    for (int i = 0; i < n; ++i) {
        stk.pop();
    }
    ListNode* prev = stk.top();
    prev->next = prev->next->next;
    ListNode* ans = dummy->next;
    delete dummy;
    return ans;
}
```



**思路3**：计算链表长度。

```C++
int getLength(ListNode* head) {
    int length = 0;
    while (head) {
        ++length;
        head = head->next;
    }
    return length;
}

ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummy = new ListNode(0, head);
    int length = getLength(head);
    ListNode* cur = dummy;
    for (int i = 1; i < length - n + 1; ++i) {
        cur = cur->next;
    }
    cur->next = cur->next->next;
    ListNode* ans = dummy->next;
    delete dummy;
    return ans;
}
```





## 反转



### L206. 反转链表

**题目**：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 



**思路1**：迭代，设置前向和后向迭代两个指针。

​	假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。 在遍历链表时，将当前节点的 next 指针改为
指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后
返回新的头引用。  
代码：  

```C++
ListNode* reverseList(ListNode* head) {
    if(!head)return head;
    auto prev=head;//反转链表的指针
    auto curr=head;//前向链表的指针
    while(curr){
        auto tmp=curr;//记录前向链表
        curr=curr->next;//前向
        tmp->next=prev;
        prev=tmp;
    }
    head->next=NULL;
    return prev;
}
```



**思路2**：递归。

```C++
ListNode* reverseList(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode* newHead = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return newHead;
}
```



**思路3**：栈。

使用栈保存遍历得到的节点。

```C++
ListNode* reverseList(ListNode* head) {
    if(!head)return head;
    std::stack<ListNode*> stk;
    auto node=head;
    while(node){
        stk.push(node);
        node=node->next;
    }
    auto r_head=stk.top();
    stk.pop();
    node=r_head;
    while(!stk.empty()){
        node->next = stk.top();
        stk.pop();
        node=node->next;
        node->next=NULL;
    }
    return r_head;
}
```





### J24. 反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

 ```
示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
 ```


限制：

0 <= 节点个数 <= 5000



解法：同L206





## 合并



### L21. 合并两个有序链表

**[题目]( https://leetcode-cn.com/problems/merge-two-sorted-lists/)**：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```
示例 1：
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

示例 2：
输入：l1 = [], l2 = []
输出：[]

示例 3：
输入：l1 = [], l2 = [0]
输出：[0]
```


提示：

两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列



**思路1**：双指针。

我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。  

```C++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if(!list1)return list2;
    else if(!list2) return list1;
    auto node1=list1;
    auto node2=list2;
    //计算头节点
    ListNode* list3=nullptr;
    if(node1->val < node2->val){
        list3=node1;
        node1=node1->next;
    }
    else{
        list3=node2;
        node2=node2->next;
    }
    //双指针循环
    auto node3=list3;
    while(true){
        if(!node1){
            node3->next = node2;
            break;
        }
        else if(!node2){
            node3->next = node1;
            break;
        }
        else{
            if(node1->val < node2->val){
                node3->next = node1;
                node1=node1->next;
                node3=node3->next;
                node3->next=nullptr;
            }
            else{
                node3->next = node2;
                node2=node2->next;
                node3=node3->next;
                node3->next=nullptr;
            }
        }
    }
    return list3;
}
```



代码简化版：

```C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    auto l3=new ListNode(3);
    auto prev=l3;
    while(l1 && l2){
        if(l1->val < l2->val){
            prev->next=l1;
            l1=l1->next;
        }
        else{
            prev->next=l2;
            l2=l2->next;
        }
        prev=prev->next;
    }
    prev->next = l1?l1:l2;
    prev=l3->next;
    delete l3;
    return prev;
}
```



**思路2**：递归法。

我们直接将以上递归过程建模，同时需要考虑边界情况。

如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

```C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    if (l1 == nullptr) {
        return l2;
    } else if (l2 == nullptr) {
        return l1;
    } else if (l1->val < l2->val) {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    } else {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}
```



### J25. 合并两个排序的链表

题目和答案：同L21





## 题目



### L141. 环形链表

**题目**：给你一个链表的头节点 head ，判断链表中是否有环。  
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，
评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链
表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。  
如果链表中存在环，则返回 true 。 否则，返回 false 。  

**解法：1** 哈希表  

**解法：2** Floyd 判圈算法  
我们先设置慢指针 slow 和快指针 fast ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环
的情况下一定会相遇，此时我们再将 slow 放置起点 0，两个指针每次同时移动一步，相遇的点就是答案。  
这里简单解释为什么后面将 slow 放置起点后移动相遇的点就一定是答案了。假设环长为 L，从起点到环的入口的步数是 a，
从环的入口继续走 b 步到达相遇位置，从相遇位置继续走 c 步回到环的入口，则有 b+c=L，其中 L、a、b、c 都是正整数。
根据上述定义，慢指针走了a+b 步，快指针走了 2(a+b)步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，
因此快指针走的步数还可以表示成 a+b+kL，其中 k 表示快指针在环上走的圈数。联立等式，可以得到2(a+b)=a+b+kL解
得 a=kL-b，整理可得 a=(k-1)L+(L-b)=(k-1)L+c  

从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 a 步之后到达环的入口，
快指针在环里走了 k−1 圈之后又走了 c 步，由于从相遇位置继续走 c 步即可回到环的入口，因此快指针也到达环的入口。两个指针在
环的入口相遇，相遇点就是答案。  

注意特点： 适用于判断图，判断环路，有且只有一个环的情况。图中有且只有一个点存在两个入度为 1，其他入度均为 0。  










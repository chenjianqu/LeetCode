







# 数学

## 基础知识



### 质数

**质数的定义**：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x−1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)。

```C++
bool isPrime(int x) {
    for (int i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            return false;
        }
    }
    return true;
}
```



#### 所有小于非负整数 n 的质数的数量

算法：**埃氏筛**

该算法由希腊数学家厄拉多塞提出，称为厄拉多塞筛法，简称埃氏筛。

我们考虑这样一个事实：**如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数**，因此我们可以从这里入手。

我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为**合数**（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。

这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。

当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们**从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了**，例如 2 的所有倍数，3 的所有倍数等。

```C++
int countPrimes(int n) {
    vector<int> isPrime(n, 1);
    int ans = 0;
    for (int i = 2; i < n; ++i) {
        if (isPrime[i]) {
            ans += 1;
            if ((long long)i * i < n) {
                for (int j = i * i; j < n; j += i) {
                    isPrime[j] = 0;
                }
            }
        }
    }
    return ans;
}
```

时间复杂度：$O(nloglogn)$。具体证明这里不再展开，读者可以自行思考或者上网搜索，本质上是要求解 $\sum_{p}\frac{n}{p}$   的和，其中 p 为质数。当然我们可以了解这个算法一个比较松的上界 O(nlogn) 怎么计算，这个等价于考虑 $\sum_{i=1}^{n}\frac{n}{i}$

  的和，而 $O(\sum_{i=1}^{n}\frac{n}{i}) = O(n\sum_{i=1}^{n}\frac{1}{i})$，而 1 到 n 中所有数的倒数和趋近于 logn，因此 $O(n\sum_{i=1}^{n}\frac{1}{i})=O(n\log n)$
空间复杂度：O(n)。我们需要 O(n) 的空间记录每个数是否为质数。









### 最大公约数、最小公倍数、互质

参考 [知乎](https://zhuanlan.zhihu.com/p/77669220)

**最大公约数**

•几个数公有的约数，叫做这几个数的公约数，其中最大的一个叫做这几个数的最大公约数

•数学上，a和b的最大公约数记为(a, b)

•编程中，计算两个数最大公约数的方法通常记为gcd(a,b)

**最小公倍数**

•几个数公有的倍数，叫做这几个数的公倍数，其中最小的一个叫做这几个数的最小公倍数

•数学上，a和b的最小公倍数记为[a,b]

•编程中，计算两个数最小公倍数的方法通常记为lcm(a,b)

**性质**：

•a x b = gcd(a, b) * lcm(a,b)

**互质**

•如果两个数的最大公约数是1，则称这两个数互质

下面看如何求两个数的最大公约数和最小公倍数

#### 分解质因数法

例：求24和60的最大公约数与最小公倍数

每个合数都可以写成几个质数相乘的形式：

> 24=2x2x2x3
>
> 60=2x2x3x5

**最大公约数**是两个数所有公有质因数的乘积：24和60公有的质因数是2、2、3，所以24和60的最大公约数是2x2x3=12

**最小公倍数**是两个数所有公有质因数和其各自独有质因数的乘积：24和60公有的质因数是2、2、3，24的独有质因数是2，60的独有质因数是5，所以24和60的最小公倍数是2x2x3x2x5=120

#### 短除法

例：求24和60的最大公约数与最小公倍数

![](https://pic2.zhimg.com/80/v2-fca390e61e2d4cac6a239f9f924d98f5_1440w.jpg) 

24和60的最大公约数为2x2x3=12（左侧3个数之积）

24和60的最小公倍数为2x2x3x2x5=120（左侧3个数和下面2个数之积）



#### 辗转相除法（欧几里德算法）

算法步骤：

> 1.输入两个正整数m, n(m>n)
>
> 2.计算m除以n的余数r
>
> 3.m=n, n=r
>
> 4.若r＝0, 则m和n的最大公因数等于m；否则转到第2步
>
> 5.输出最大公因数m
>
> 

例：求24和60的最大公约数与最小公倍数

60 %24 = 12

24 %12 = 0

24和60的最大公约数是12

a x b = gcd(a, b) x lcm(a,b) —》 lcm(a,b) = a x b / gcd(a, b)

24和60的最小公倍数=24x60/12=120



主要代码：

递归：

```C++
int gcd(int a, int b){ 
    return (b==0) ? a : gcd(b, a%b); 
}
```

非递归：

```C++
int gcd(int a, int b){
    int t=a%b;
    while(t){
	    a=b;
    	b=t;
    	t=a%b;
    }
    return b;
}

int lcm(inta, int b){ 
    return a/gcd(a, b)*b; 
}
```



或

**辗转相除法**又叫欧几里得算法,是欧几里得最先提出来的.辗转相除法的实现,是基于下面的原理(在这里用(a,b)表示a和b的最大公因数)：

> 　　(a,b)=(a,ka+b),其中a、b、k都为自然数

　也就是说,两个数的最大公约数,将其中一个数加到另一个数上,得到的新数,其公约数不变,比如(4,6)=(4+6,6)=(4,6+2×4)=2.

​    要证明这个原理很容易：如果p是a和ka+b的公约数,p整除a,也能整除ka+b.那么就必定要整除b,所以p又是a和b的公约数,从而证明他们的最大公约数也是相等的.
　　基于上面的原理,就能实现我们的迭代相减法：

```
(78,14)=(64,14)=(50,14)=(36,14)=(22,14)=(8,14)=(8,6)=(2,6)=(2,4)=(2,2)=(0,2)=2
```

　　**基本上思路就是大数减去小数,一直减到能算出来为止**,在作为练习的时候,往往进行到某一步就已经可以看出得值.迭代相减法简单,不过步数比较多,实际上我们可以看到,在上面的过程中,由(78,14)到(8,14)完全可以一步到位,因为(78,14)=(14×5+8,14)=(8,14),由此就诞生出我们的辗转相除法.
　　用辗转相除法求(a,b).设r0=b,r1=a,反复运用除法算式,得到一系列整数qi,ri和下面的方程：
　　相当于每一步都运用原理①把数字进行缩小,上面右边就是每一步对应的缩小结果,可以看出,最后的余数rn就是a和b的公约数.迭代相减法和辗转相除法在本质上是一样的,相对来说,减法比较简单（需要10步）,但是除法步数少（仅需4步）.





## 常见知识点

### 判断两个数是否互质

```C++
///辗转相除法
bool isrp(int a, int b) {
    if (a == 1 || b == 1)     // 两个正整数中，只有其中一个数值为1，两个正整数为互质数
        return true;
    while (true) {          // 求出两个正整数的最大公约数
        int t = a % b;
        if (t == 0) {
            break;
        }
        else {
            a = b;
            b = t;
        }
    }
    if (b > 1) 
        return false;// 如果最大公约数大于1，表示两个正整数不互质
    else 
        return true;    // 如果最大公约数等于1,表示两个正整数互质
}
```



### 逆波兰表达式

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

* 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
* 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中







## 题目



### L118. 杨辉三角

**[题目](https://leetcode-cn.com/problems/pascals-triangle/) **:  给给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

```C++
示例 1:
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

示例 2:
输入: numRows = 1
输出: [[1]]
```

提示:

1 <= numRows <= 30



**思路1**：数学递推。

杨辉三角，是二项式系数在三角形中的一种几何排列。它是中国古代数学的杰出研究成果之一，它把二项式系数图形化，把组合数内在的一些代数性质直观地从图形中体现出来，是一种离散型的数与形的结合。

杨辉三角具有以下性质：

>每行数字左右对称，由 1 开始逐渐变大再变小，并最终回到 1。
>
>第 n 行（从 0 开始编号）的数字有 n+1 项，前 n 行共有 $\frac{n(n+1)}{2}$ 个数。
>
>第 n 行的第 m 个数（从 0 开始编号）可表示为可以被表示为组合数 $\mathcal{C}(n,m)$，记作 $\mathcal{C}_n^m$  或 $\binom{n}{m}$ ，即为从 n 个不同元素中取 m 个元素的组合数。我们可以用公式来表示它：$\mathcal{C}_n^m=\dfrac{n!}{m!\times (n-m)!}$ 
>每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n 行的第 i 个数等于第 n−1 行的第 i−1 个数和第 i 个数之和。这也是组合数的性质之一，即 $\mathcal{C}_n^i=\mathcal{C}_{n-1}^i+\mathcal{C}_{n-1}^{i-1}$ 。
>
>$(a+b)^n$   的展开式（二项式展开）中的各项系数依次对应杨辉三角的第 n 行中的每一项。

依据性质 4，我们可以一行一行地计算杨辉三角。每当我们计算出第 i 行的值，我们就可以在线性时间复杂度内计算出第 i+1 行的值。

```C++
vector<vector<int>> generate(int numRows) {
    vector<vector<int>> ret(numRows);
    for (int i = 0; i < numRows; ++i) {
        ret[i].resize(i + 1);
        ret[i][0] = ret[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            ret[i][j] = ret[i - 1][j] + ret[i - 1][j - 1];
        }
    }
    return ret;
}
```







### L119. 杨辉三角 II

**[题目](https://leetcode-cn.com/problems/pascals-triangle-ii/)**:  给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

```C++
示例 1:
输入: rowIndex = 3
输出: [1,3,3,1]

示例 2:
输入: rowIndex = 0
输出: [1]

示例 3:
输入: rowIndex = 1
输出: [1,1]
```

提示:

0 <= rowIndex <= 33



**思路1**：滚动数组。

```C++
vector<int> getRow(int rowIndex) {
    vector<int> last_row(rowIndex+1);
    vector<int> curr_row(rowIndex+1);
    last_row[0]=1;
    for(int i=1;i<=rowIndex;++i){
        for(int j=0;j<=i;++j){
            if(j==0){//第一个
                curr_row[j]=last_row[j];
            }
            else if(j==i){//最后一个
                curr_row[j]=last_row[j-1];
            }
            else{
                curr_row[j]=last_row[j-1]+last_row[j];
            }
        }
        last_row=curr_row;
    }
    return last_row;
}
```







### L66.加一

**[题目](https://leetcode-cn.com/problems/plus-one/)**:  实现 p给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

 ```
示例 1：
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。

示例 2：
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。

示例 3：
输入：digits = [0]
输出：[1]
 ```


提示：

1 <= digits.length <= 100
0 <= digits[i] <= 9



**思路1**：设置一个进位标志位carry，一开始设置carry为1.

```C++
vector<int> plusOne(vector<int>& digits) {
    bool carry=true;
    for(int j=digits.size()-1;j>=0;--j){
        if(carry){
            if(digits[j]==9){
                digits[j]=0;
            }
            else{
                ++digits[j];
                carry=false;
            }
        }
    }
    if(carry){
        digits.insert(digits.begin(),1);
    }
    return digits;
}
```



**思路2**：找出最长的后缀 9

​	当我们对数组 digits 加一时，我们只需要关注 digits 的末尾出现了多少个 9 即可。我们可以考虑如下的三种情况：

* 如果 digits 的末尾没有 9，例如 [1,2,3]，那么我们直接将末尾的数加一，得到 [1, 2, 4] 并返回；

* 如果 digits 的末尾有若干个 9，例如 [1,2,3,9,9]，那么我们只需要找出从末尾开始的第一个不为 9 的元素，即 3，将该元素加一，得到 [1,2,4,9,9]。随后将末尾的 9 全部置零，得到 [1,2,4,0,0] 并返回。

* 如果 digits 的所有元素都是 9，例如 9,9,9,9,9]，那么答案为 [1,0,0,0,0,0]。我们只需要构造一个长度比digits 多 1 的新数组，将首元素置为 1，其余元素置为 0 即可。

**算法**：只需要对数组 digits 进行一次逆序遍历，找出第一个不为 9 的元素，将其加一并将后续所有元素置零即可。如果 digits 中所有的元素均为 9，那么对应着「思路」部分的第三种情况，我们需要返回一个新的数组。

```C++
vector<int> plusOne(vector<int>& digits) {
    int n = digits.size();
    for (int i = n - 1; i >= 0; --i) {
        if (digits[i] != 9) {
            ++digits[i];
            for (int j = i + 1; j < n; ++j)
                digits[j] = 0;
            return digits;
        }
    }
    // digits 中所有的元素均为 9
    vector<int> ans(n + 1);
    ans[0] = 1;
    return ans;
}
```





### J16. 数值的整数次方

**[题目](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)**:  实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

 ```
示例 1：

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
示例 3：

输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
 ```


提示：

-100.0 < x < 100.0
-2^31 <= n <= 2^31-1
-10^4 <= x^n <= 10^4



**思路1**：暴力法。（超时）



**思路2**：提前计算$x^{2^{i}}$。

当n很大时，需要能以$log_2(n)$的时间复杂度计算结果。因此，首先计算$x^{2^{i}}$，如$x,x^2,x^4,x^8,x^{16},...$。将结果存放到数组中。

我的实现：

```C++
class Solution {
public:
    double myPow(double x, int n) {
        //异常值处理
        if(n==0) return 1;
        int flag=n>0?1:-1;
        int64_t number=int64_t(n)*flag;
        //预计算
        int max_n = std::log((double)number)/std::log(2.) ;
        vector<double> arr(max_n+1);//arr[i]= x^(2^i)
        vector<int> indexs(max_n+1);
        arr[0]=x;
        indexs[0]=1;
        for(int i=1;i<=max_n;++i){
            arr[i]=arr[i-1]*arr[i-1];
            indexs[i]=2*indexs[i-1];
        }
        //正式计算
        double result=1;
        int index=max_n;
        while(number>0){
            while(number < indexs[index])index--;
            result *= arr[index];
            number-=indexs[index];
        }
        if(flag==-1)result=1./result;
        return result;
    }
};
```



**思路3**：快速幂法。

「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ ，我们可以按照：$x \to x^2 \to x^4 \to x^8 \to x^{16} \to x^{32} \to x^{64}$的顺序，从 x 开始，每次直接把上一次的结果进行平方，计算 66 次就可以得到 $x^{64}$ 的值，而不需要对 x 乘 63 次 x。再举一个例子，如果我们要计算 $x^{77}$，我们可以按照：

$x \to x^2 \to x^4 \to x^9 \to x^{19} \to x^{38} \to x^{77}$的顺序，在 $x \to x^2，x^2 \to x^4，x^{19} \to x^{38}$这些步骤中，我们直接把上一次的结果进行平方，而在 $x^4 \to x^9$，$x^9 \to x^{19}$，$x^{38} \to x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。

直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：

* 当我们要计算 $x^n$ 时，我们可以先递归地计算出 $y = x^{\lfloor n/2 \rfloor}$，其中 $\lfloor a \rfloor$表示对 a 进行下取整；

* 根据递归计算的结果，如果 n 为偶数，那么 $x^n = y^2$；如果 n 为奇数，那么 $x^n = y^2 \times x$；

* 递归的边界为 n = 0，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 $O(\log n)$，算法可以在很快的时间内得到结果。

```c++
class Solution {
private:
   	double quickMul(double x, long long N) {
        if (N == 0)
            return 1.0;
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }
public:
    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```





由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 x。但我们不妨找一找规律，看看哪些地方额外乘了 x，并且它们对答案产生了什么影响。我们还是以 $x^{77}$ 作为例子：

$x \to x^2 \to x^4 \to^+ x^9 \to^+ x^{19} \to x^{38} \to^+ x^{77}$
并且把需要额外乘 x 的步骤打上了 + 标记。可以发现：

* $x^{38} \to^+ x^{77}$  中额外乘的 x 在 $x^{77}$中贡献了 x；

* $x^9 \to^+ x^{19}$中额外乘的 x 在之后被平方了 2 次，因此在 $x^{77}$中贡献了 $x^{2^2} = x^4$；

* $x^4 \to^+ x^9$ 中额外乘的 xx 在之后被平方了 3 次，因此在 $x^{77}$中贡献了 $x^{2^3} = x^8$；

* 最初的 x 在之后被平方了 6 次，因此在 $x^{77}$中贡献了 $x^{2^6} = x^{64}$。

我们把这些贡献相乘，$x \times x^4 \times x^8 \times x^{64}$  恰好等于 $x^{77}$。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 x 在之后都会被平方若干次。**而这些指数 1，4，8 和 64，恰好就对应了 77 的二进制表示 $(1001101)_2$中的每个 1！**

因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 n 的二进制拆分为$n = 2^{i_0} + 2^{i_1} + \cdots + 2^{i_k}$, 那么$x^n = x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}$
这样以来，我们从 x 开始不断地进行平方，得到 $x^2, x^4, x^8, x^{16}, \cdots$,如果 n 的第 k 个（从右往左，从 0 开始计数）二进制位为 1，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。

```C++
class Solution {
public:
    double quickMul(double x, long long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```



### L400. 第 N 位数字

[题目](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)：同J44.

### J44. 数字序列中某一位的数字

**[题目](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)**：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

 ```
示例 1：
输入：n = 3
输出：3

示例 2：
输入：n = 11
输出：0
 ```


限制：

0 <= n < 2^31



**思路1**：找规律。

根据题目，可知：

```C++
//0-9 长度 10
//0-99 长度10 + 2*90 =190
//0-999 长度 190 + 3*900 = 2890

因此：
arr[0]=10;
for(int i=1;i<N;++i) 
	arr[i]=arr[i-1]+ (i+1)*(9*std::pow(10,i));
```

因此，可以跟判断输入数字n属于的数字number是几位数的，比如对于n=200，可知对应的number的范围在100-999之间，因此n有3位数。

对于数字n，对应的数字为number，number的位数为digits。首先将n减去比n小一个级别的长度，比如对于n=200，大于0-99对应的190，则有res = n-190 =10。

number的计算：number = res/digits

n在number的第几位的计算： idx = res % digits

代码如下：

```C++
int findNthDigit(int n) {
    if(n<=9) return n;//0-9特殊处理
    int index=0;
    int start=10;
    for(int i=1;i<9;++i){//判断n是属于几次方的，比如n=200，大于0-99对应的190，此时得index=1
        long long count = start + (i+1LL)*(9LL*std::pow(10,i));
        if(n<count){
            index=i;
            break;
        }
        start=count;
    }
    int res = n - start;//比如对于n=200, 减去190后，得res=10
    int digits = index+1;//表示几位数，对于n=200，其对应的数字number的位数为3
    int number = res/digits+std::pow(10,index);//number表示n对应的数字
    int idx=res%(digits);//idx表示n对应于num第几位数
    return std::to_string(number)[idx]-'0';
}
```



**思路2**：官方的实现。

已知 `x` 位数共有 $9 \times 10^{x - 1}$ 个，所有 `x` 位数的位数之和是 $x \times 9 \times 10^{x - 1}$。使用 `d` 和 `count` 分别表示当前遍历到的位数和当前位数下的所有整数的位数之和，初始时 `d = 1`，`count=9`。每次将 `n` 减去 $d×count$，然后将 `d` 加 1，将 `count` 乘以 10，直到 $n \le d \times \textit{count}$，此时的 `d` 是目标数字所在整数的位数，`n` 是所有 `d` 位数中从第一位到目标数字的位数。

为了方便计算目标数字，使用目标数字在所有 d 位数中的下标进行计算，下标从 0 开始计数。令 `index=n−1`，则 `index` 即为目标数字在所有 d 位数中的下标，`index` 的最小可能取值是 0。

得到下标 `index` 之后，即可使用方法一的做法得到无限整数序列中的第 `n` 位数字。

```C++
int findNthDigit(int n) {
    int d = 1, count = 9;
    while (n > (long) d * count) {//计算位数d和当下位数所有整数的位数和count
        n -= d * count;
        d++;
        count *= 10;
    }
    int index = n - 1;//为目标数字在所有 d 位数中的下标
    int start = (int) pow(10, d - 1);//d位数的首数字
    int num = start + index / d;//n对应的数字num
    int digitIndex = index % d;//n在num中的索引
    int digit = (num / (int) (pow(10, d - digitIndex - 1))) % 10;//获得数字
    return digit;
}
```





**思路3**：二分查找。





### L263. 丑数

**[题目](https://leetcode-cn.com/problems/ugly-number/)**：给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

 ```
示例 1：
输入：n = 6
输出：true
解释：6 = 2 × 3

示例 2：
输入：n = 8
输出：true
解释：8 = 2 × 2 × 2

示例 3：
输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。

示例 4：
输入：n = 1
输出：true
解释：1 通常被视为丑数。
 ```


提示：

-2^31 <= n <= 2^31 - 1



**分析**：

根据丑数的定义，0 和负整数一定不是丑数。

当 n>0 时，若 n 是丑数，则 n 可以写成 $n = 2^a \times 3^b \times 5^c$ 的形式，其中 a,b,c 都是非负整数。特别地，当 a,b,c 都是 0 时，n=1。

为判断 n 是否满足上述形式，可以对 n 反复除以 2,3,5 , 直到 n 不再包含质因数2,3,5。若剩下的数等于 1，则说明 n 不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。



**思路1**：递归。

```C++
bool isUgly(int n) {
    if(n==1) 
        return true;
    else if(n%2!=0 && n%3!=0 && n%5!=0)
        return false;
    else if(n<1)
        return false;
    bool a=false,b=false,c=false;
    if(n%2==0 && isUgly(n/2)) return true;
    if(n%3==0 && isUgly(n/3)) return true;
    if(n%5==0 && isUgly(n/5)) return true;
    return false;
}
```



**思路2**：迭代。

```C++
bool isUgly(int n) {
    if (n <= 0) 
        return false;
    vector<int> factors = {2, 3, 5};
    for (int factor : factors) {
        while (n % factor == 0)
            n /= factor;
    }
    return n == 1;
}
```

时间复杂度：O(logn)。时间复杂度取决于对 n 除以 2,3,5 的次数，由于每次至少将 n 除以 2，因此除法运算的次数不会超过 O(logn)。

空间复杂度：O(1) 。



### L264. 丑数 II

**[题目](https://leetcode-cn.com/problems/ugly-number-ii/)**：同 J49。

### J49. 丑数

**[题目](https://leetcode-cn.com/problems/chou-shu-lcof/)**：我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

 ```
示例:
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
 ```


说明:  

1 是丑数。
n 不超过1690。



**分析**：本题的关键在于找到丑数递推的公式。

**思路1**：最小堆。

要得到从小到大的第 n 个丑数，可以使用最小堆实现。

初始时堆为空。首先将最小的丑数 1 加入堆。

每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x, 3x, 5x 也是丑数，因此将 2x, 3x, 5x 加入堆。

上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。

在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。

**时间复杂度**：O(nlogn)。得到第 n 个丑数需要进行 n 次循环，每次循环都要从最小堆中取出 1 个元素以及向最小堆中加入最多 3 个元素，因此每次循环的时间复杂度是 O(logn)，总时间复杂度是 O(nlogn)。

**空间复杂度**：O(n)。空间复杂度主要取决于最小堆和哈希集合的大小，最小堆和哈希集合的大小都不会超过 3n。

```C++
int nthUglyNumber(int n) {
    std::priority_queue<int64_t, std::vector<int64_t>, std::greater<int64_t>> small_heap;//最小堆
    std::unordered_set<int64_t> hash_set;
    small_heap.push(1);
    hash_set.insert(1);
    for(int i=1;i<n;++i){
        int64_t min = small_heap.top();//取出堆中的最小值
        small_heap.pop();
        if(int64_t tmp=min*2;hash_set.count(tmp)==0) {
            small_heap.push(tmp);
            hash_set.insert(tmp);
        }
        if(int64_t tmp=min*3;hash_set.count(tmp)==0) {
            small_heap.push(tmp);
            hash_set.insert(tmp);
        }
        if(int64_t tmp=min*5;hash_set.count(tmp)==0) {
            small_heap.push(tmp);
            hash_set.insert(tmp);
        }
    }
    return small_heap.top();
}
```



**思路2**：动态规划。

丑数的递推性质： 丑数只包含因子 2, 3, 5 ，因此有 “**丑数 == 某较小丑数 × 某因子**” （例如：10=5×2）。

设已知长度为 n 的丑数序列 $x_1, x_2, \cdots , x_n$，求第 n+1 个丑数 $x_{n+1}$ 。根根据递推性质，丑数 $x_{n+1}$  只可能是以下三种情况其中之一（索引 a, b, c为未知数）：

$$
x_{n+1} = \begin{cases} x_{a} \times 2 & ,a \in [1, n] \\ x_{b} \times 3 & ,b \in [1, n] \\ x_{c} \times 5 & ,c \in [1, n] \end{cases}
$$

​	丑数递推公式： 若索引 a,b,c 满足以上条件，则下个丑数 $x_{n+1}$  为以下三种情况中的 最小值 ；

$$
x_{n+1} = \min(x_{a} \times 2, x_{b} \times 3, x_{c} \times 5)
$$
​	由于 $x_{n+1}$ 是 最接近 $x_n$  的丑数，因此索引 a, b, c 需满足以下条件：

$$
\begin{cases} 
x_{a} \times 2 > x_n \geq x_{a-1} \times 2 & ，即 x_a 为首个乘以 2 后大于x_n 的丑数 \\ 
x_{b} \times 3 > x_n \geq x_{b-1} \times 3 & ，即 x_b 为首个乘以 3 后大于 x_n 的丑数 \\ 
x_{c} \times 5 > x_n \geq x_{c-1} \times 5 & ，即 x_c 为首个乘以 5 后大于 x_n 的丑数 \\ 
\end{cases}
$$

​	因此，可设置指针 a,b,c 指向首个丑数（即 1 ），循环根据递推公式得到下个丑数，并每轮将对应指针执行 +1 即可。

**动态规划解析**：

* 状态定义： 设动态规划列表 dp ，dp[i] 代表第 i+1 个丑数；
* 转移方程：
  * 当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；
  * 每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 ,dp[c]×5 的大小关系，若相等则将对应索引 a , b , c 加 1 ；

$$
\begin{cases} dp[a] \times 2 > dp[i-1] \geq dp[a-1] \times 2 \\ 
dp[b] \times 3 > dp[i-1] \geq dp[b-1] \times 3 \\ 
dp[c] \times 5 > dp[i-1] \geq dp[c-1] \times 5 \\ 
\end{cases}
$$

* 初始状态： dp[0] = 1 ，即第一个丑数为 1 ；
* 返回值： dp[n−1] ，即返回第 n 个丑数；



时间复杂度 O(N)： 其中 N = n ，动态规划需遍历计算 dp 列表。
空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N) 的额外空间。

```C++
int nthUglyNumber(int n) {
    int a = 0, b = 0, c = 0;
    int dp[n];
    dp[0] = 1;
    for(int i = 1; i < n; i++) {
        int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
        dp[i] = min(min(n2, n3), n5);
        if(dp[i] == n2) a++;
        if(dp[i] == n3) b++;
        if(dp[i] == n5) c++;
    }
    return dp[n - 1];
}
```



### J57. 和为s的连续正数序列

**[题目](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)**：输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 ```
示例 1：
输入：target = 9
输出：[[2,3,4],[4,5]]

示例 2：
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
 ```


限制：

1 <= target <= 10^5



**思路1**：滑动窗口，暴力枚举。

遍历从1到`target/2`的每个值`i`，计算以`i`作为起点的连续序列的和，当和等于`target`时，表示找到一个序列。当和大于`target`时，表示以`i`作为起点的连续序列的和不等于`target`。

```C++
vector<vector<int>> findContinuousSequence(int target) {
    vector<vector<int>> result;
    //滑动窗口法
    for(int i=1;i<=target/2;++i){
        int sum=i;
        for(int j=i+1;j<target;++j){//计算以i为起点的窗口大小
            sum+=j;
            if(sum==target){
                vector<int> tmp(j-i+1);
                std::iota(tmp.begin(), tmp.end(), i); //生成递增序列
                result.push_back(tmp);
            }
            else if(sum>target){
                break;
            }
        }
    }
    return result;
}
```



**思路2**：双指针。

我们用两个指针 `l` 和 `r` 表示当前枚举到的以 `l` 为起点到 `r` 的区间，`sum`表示 `[l,r]` 的区间和，由求和公式可 O(1) 求得为 $\textit{sum}=\frac{(l+r) \times (r-l+1)}{2}$  ，起始 `l=1,r=2`。

一共有三种情况：

* 如果 `sum<target` 则说明指针 r 还可以向右拓展使得 sum 增大，此时指针 r 向右移动，即 r+=1
* 如果 `sum>target` 则说明以 l 为起点不存在一个 r 使得 sum=target ，此时要枚举下一个起点，指针 ll 向右移动，即l+=1
* 如果 `sum==target` 则说明我们找到了以 `l` 为起点得合法解 `[l,r]` ，我们需要将 `[l,r]` 的序列放进答案数组，且我们知道以 `l` 为起点的合法解最多只有一个，所以需要枚举下一个起点，指针 `l` 向右移动，即 `l+=1`
  终止条件即为 `l>=r` 的时候，这种情况的发生指针 `r` 移动到了$\lfloor\frac{\textit{target}}{2}\rfloor+1$ 的位置，导致 `l<r` 的时候区间和始终大于 `target` 。

此方法其实是对方法一的优化，因为方法一是没有考虑区间与区间的信息可以复用，只是单纯的枚举起点，然后从起点开始累加，而该方法就是考虑到了如果已知 `[l,r]` 的区间和等于 `target` ，那么枚举下一个起点的时候，区间 `[l+1,r]` 的和必然小于 `target` ，我们就不需要再从 `l+1` 再开始重复枚举，而是从 `r+1` 开始枚举，充分的利用了已知的信息来优化时间复杂度。

```C++
vector<vector<int>> findContinuousSequence(int target) {
    vector<vector<int>> output;
    //双指针
    int left=1,right=2;
    while(left<=target/2){
        int n = right-left+1;
        int sum= (left+right)*(right-left+1)/2;
        //cout<<left<<":"<<right<<" ,"<<sum<<endl;
        if(sum == target){
            vector<int> tmp(right-left+1);
            std::iota(tmp.begin(),tmp.end(),left);
            output.push_back(tmp);
            left++;
        }
        else if(sum > target){
            left++;
        }
        else{
            right++;
        }
    }
    return output;
}
```

时间复杂度：由于两个指针移动均单调不减，且最多移动 $\lfloor\frac{\textit{target}}{2}\rfloor$次，即方法一提到的枚举的上界，所以时间复杂度为 O(target) 。

空间复杂度：O(1) ，除了答案数组只需要常数的空间存放若干变量。

另一个实现：

```C++
vector<vector<int>> findContinuousSequence(int target) {
    vector<vector<int>>vec;
    vector<int> res;
    for (int l = 1, r = 2; l < r;){
        int sum = (l + r) * (r - l + 1) / 2;//求和公式
        if (sum == target) {
            res.clear();
            for (int i = l; i <= r; ++i) 
                res.emplace_back(i);
            vec.emplace_back(res);
            l++;
        } else if (sum < target) {
            r++;
        } else {
            l++;
        }
    }
    return vec;
}
```



### J62. 圆圈中最后剩下的数字

**[题目](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)**：0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 ```
示例 1：
输入: n = 5, m = 3
输出: 3

示例 2：
输入: n = 10, m = 17
输出: 2
 ```


限制：

1 <= n <= 10^5
1 <= m <= 10^6



**思路1**：数学关系。

著名的**约瑟夫环**问题，是有数学解法的！
因为数据是放在数组里，所以我在数组后面加上了数组的复制，以体现是环状的。我们先忽略图片里的箭头：
【下图中第一轮后面的数字应该是[0, 1, 2 ,3 ,4]】

![](https://pic.leetcode-cn.com/9dda886441be8d249abb76e35f53f29fd6e780718d4aca2ee3c78f947fb76e75-image.png)


很明显我们每次删除的是第 m 个数字，我都标红了。

第一轮是 [0, 1, 2, 3, 4] ，所以是 [0, 1, 2, 3, 4] 这个数组的多个复制。这一轮 2 删除了。

第二轮开始时，从 3 开始，所以是 [3, 4, 0, 1] 这个数组的多个复制。这一轮 0 删除了。

第三轮开始时，从 1 开始，所以是 [1, 3, 4] 这个数组的多个复制。这一轮 4 删除了。

第四轮开始时，还是从 1 开始，所以是 [1, 3] 这个数组的多个复制。这一轮 1 删除了。

最后剩下的数字是 3。

图中的绿色的线指的是新的一轮的开头是怎么指定的，每次都是固定地向前移位 m 个位置。

然后我们从最后剩下的 3 倒着看，我们可以反向推出这个数字在之前每个轮次的位置。

最后剩下的 3 的下标是 0。

第四轮反推，补上 m 个位置，然后模上当时的数组大小 2，位置是(0 + 3) % 2 = 1。

第三轮反推，补上 m 个位置，然后模上当时的数组大小 3，位置是(1 + 3) % 3 = 1。

第二轮反推，补上 m 个位置，然后模上当时的数组大小 4，位置是(1 + 3) % 4 = 0。

第一轮反推，补上 m 个位置，然后模上当时的数组大小 5，位置是(0 + 3) % 5 = 3。

所以最终剩下的数字的下标就是3。因为数组是从0开始的，所以最终的答案就是3。

总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。



```C++
int lastRemaining(int n, int m) {
    if(n==1)//序列长度为1，肯定是0
        return 0;
    int index = lastRemaining(n-1,m);//从下一轮保留的位置
    int result = (index+m)%n;//反推公式
    return result;
}
```



### L29. 两数相除

**[题目](https://leetcode-cn.com/problems/divide-two-integers/)**：给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

```
示例 1:
输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = truncate(3.33333..) = truncate(3) = 3

示例 2:
输入: dividend = 7, divisor = -3
输出: -2
解释: 7/-3 = truncate(-2.33333..) = -2
```


提示：

被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。



**思路1**： [朴素的想法，没有位运算，没有移位操作 - 两数相除 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/divide-two-integers/solution/po-su-de-xiang-fa-mei-you-wei-yun-suan-mei-you-yi-/) 

```C++
class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend == 0) return 0;
        if(divisor == 1) return dividend;
        if(divisor == -1){
            if(dividend>INT_MIN) return -dividend;// 只要不是最小的那个整数，都是直接返回相反数就好啦
            return INT_MAX;// 是最小的那个，那就返回最大的整数啦
        }
        //设置符号
        long a = dividend;
        long b = divisor;
        int sign = 1; 
        if((a>0&&b<0) || (a<0&&b>0)){
            sign = -1;
        }
        a = a>0?a:-a;
        b = b>0?b:-b;
        //递归地进行除法
        long res = div(a,b);
        //输出结果
        if(sign>0)
            return res>INT_MAX?INT_MAX:res;
        return -res;
    }
    
    //返回正整数 a/b 的结果
    //简单概括为： 60/8 = (60-32)/8 + 4 = (60-32-16)/8 + 2 + 4 = 1 + 2 + 4 = 7
    int div(long a, long b){  
        if(a<b) return 0;
        long count = 1;
        long tb = b; // 在后面的代码中不更新b
        while((tb+tb)<=a){
            count = count + count; // 最小解翻倍
            tb = tb+tb; // 当前测试的值也翻倍
        }
        return count + div(a-tb,b);
    }
};
```





**思路2**：官方解答：二分查找+快速乘法。

**分析**：

如果除法结果溢出，那么我们需要返回 $2^{31} - 1$ 作为答案。因此在编码之前，我们可以首先对于溢出或者容易出错的边界情况进行讨论：

* 当被除数为 32 位有符号整数的最小值 $-2^{31}$  时：
  * 如果除数为 1，那么我们可以直接返回答案 $-2^{31}$ ；
  * 如果除数为 −1，那么答案为 $2^{31}$ ，产生了溢出。此时我们需要返回 $2^{31} - 1$ 。

* 当除数为 32 位有符号整数的最小值 $-2^{31}$ 时：
  * 如果被除数同样为 $-2^{31} $ ，那么我们可以直接返回答案 1；
  * 对于其余的情况，我们返回答案 0。

* 当被除数为 0 时，我们可以直接返回答案 0。

  对于一般的情况，根据除数和被除数的符号，我们需要考虑 4 种不同的可能性。因此，为了方便编码，我们可以将被除数或者除数取相反数，使得它们符号相同。

如果我们将被除数和除数都变为正数，那么可能会导致溢出。例如当被除数为 $-2^{31}$ 时，它的相反数 $2^{31}$  产生了溢出。因此，我们可以考虑将被除数和除数都变为负数，这样就不会有溢出的问题，在编码时只需要考虑 1 种情况了。

如果我们将被除数和除数的其中（恰好）一个变为了正数，那么在返回答案之前，我们需要对答案也取相反数。

**思路**：根据上面的讨论，我们记被除数为 X，除数为 Y，并且 X 和 Y 都是负数。我们需要找出 X/Y 的结果 Z。Z 一定是正数或 0。

根据除法以及余数的定义，我们可以将其改成乘法的等价形式，即：

$Z \times Y \geq X > (Z+1) \times Y$
    因此，我们可以使用二分查找的方法得到 Z，即找出最大的 Z 使得 Z×Y≥X 成立。

由于我们不能使用乘法运算符，因此我们需要使用「快速乘」算法得到 Z×Y 的值。「快速乘」算法与「快速幂」类似，前者通过加法实现乘法，后者通过乘法实现幂运算。「快速幂」算法可以参考「50. Pow(x, n)」的官方题解，「快速乘」算法只需要在「快速幂」算法的基础上，将乘法运算改成加法运算即可。

由于我们只能使用 32 位整数，因此二分查找中会有很多细节。

首先，二分查找的下界为 1，上界为 $2^{31}-1$ 。唯一可能出现的答案为 $2^{31}$  的情况已经被我们在「前言」部分进行了特殊处理，因此答案的最大值为 $2^{31} - 1$。如果二分查找失败，那么答案一定为 0。

在实现「快速乘」时，我们需要使用加法运算，然而较大的 Z 也会导致加法运算溢出。例如我们要判断 A+B 是否小于 C 时（其中 A,B,C 均为负数），A+B 可能会产生溢出，因此我们必须将判断改为 A<C−B 是否成立。由于任意两个负数的差一定在 $[-2^{31} + 1, 2^{31} - 1]$范围内，这样就不会产生溢出。

```C++
class Solution {
private:
    // 快速乘
    // x 和 y 是负数，z 是正数
    bool quickAdd(int y, int z, int x) {
        // 需要判断 z * y >= x 是否成立
        int result = 0, add = y;
        while (z) {
            if (z & 1) {
                if (result < x - add) // 需要保证 result + add >= x
                    return false;
                result += add;
            }
            if (z != 1) {
                if (add < x - add) // 需要保证 add + add >= x
                    return false;
                add += add;
            }
            z >>= 1;// 不能使用除法
        }
        return true;
    }
    
public:
    int divide(int dividend, int divisor) {
        ///判断特殊情况
        if (dividend == INT_MIN) {// 考虑被除数为最小值的情况
            if (divisor == 1)
                return INT_MIN;
            if (divisor == -1) 
                return INT_MAX;
        }
        if (divisor == INT_MIN) // 考虑除数为最小值的情况
            return dividend == INT_MIN ? 1 : 0;
        if (dividend == 0) // 考虑被除数为 0 的情况
            return 0;
        
        // 一般情况，使用二分查找
        // 将所有的正数取相反数，这样就只需要考虑一种情况
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }
		///进行二分查找
        int left = 1, right = INT_MAX, ans = 0;
        while (left <= right) {
            // 注意溢出，并且不能使用除法
            //(right - left) >> 1等于(right - left)/2
            int mid = left + ((right - left) >> 1);
            bool check = quickAdd(divisor, mid, dividend);
            if (check) {
                ans = mid;
                if (mid == INT_MAX) // 注意溢出
                    break;
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }

        return rev ? -ans : ans;
    }
};
```















# 位运算

## 基础知识





### 异或

 在逻辑学中，逻辑算符异或（`exclusive or`）是对两个运算元的一种逻辑析取类型，符号为 XOR 或 EOR 或 ⊕（编程语言中常用`^`）。但与一般的逻辑或不同，异或算符的值为真仅当两个运算元中恰有一个的值为真，而另外一个的值为非真。转化为命题，就是：“两者的值不同。”或“有且仅有一个为真。” 

```
1 ⊕ 1 = 0
0 ⊕ 0 = 0
1 ⊕ 0 = 1
0 ⊕ 1 = 1
```

**性质**：

恒等律：`X ⊕ 0 = X` 

归零律：`X ⊕ X = 0` 

交换律：`A ⊕ B = B ⊕ A` 

结合律：`A ⊕ (B ⊕ C) = (A ⊕ B) ⊕ C` 





## 题目

### J15. 二进制中1的个数

**[题目](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)**: 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。

 提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

```
示例 1：
输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：
输入：n = 128 (控制台输入 00000000000000000000000010000000)
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```


提示：

输入必须是长度为 32 的 二进制串 。



**思路1**：通过&运算统计1的位数。

```C++
int hammingWeight(uint32_t n) {
    int ret = 0;
    for (int i = 0; i < 32; i++) 
    	if (n & (1 << i)) 
    		ret++;
    return ret;
}
```



**思路2**：位运算优化。

观察这个运算：n&(n - 1)，其预算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。

如：$6\&(6-1) = 4$,  $6 = (110)_2, 4 = (100)_2$ ，运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 n 与 n - 1 做与运算，直到 n 变为 0 即可。因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。

```C++
int hammingWeight(uint32_t n) {
	int ret = 0;
	while (n) {
		n &= n - 1;
		ret++;
	}
	return ret;
}
```





### L191. 位1的个数

**[题目](https://leetcode-cn.com/problems/number-of-1-bits/)**：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

 提示：

   请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

**思路**：同上题J15

```C++
int hammingWeight(uint32_t n) {
    int number=0;
    for(int i=0;i<32;++i){
        if(n & (1<<i))number++;
    }
    return number;
}
```





### L461. 汉明距离

**[题目](https://leetcode-cn.com/problems/hamming-distance/) **：两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 x 和 y，计算并返回它们之间的汉明距离。

```
示例 1：
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。

示例 2：
输入：x = 3, y = 1
输出：1
```


提示：

0 <= x, y <= 2^31 - 1



**思路1**：移位。

![](https://assets.leetcode-cn.com/solution-static/461/2.png)

具体地，记 $s = x \oplus y$ ，我们可以不断地检查 s 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 s 整体右移一位，这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量。

```C++
int hammingDistance(int x, int y) {
    int s = x ^ y, ret = 0;
    while (s) {
        ret += s & 1;
        s >>= 1;
    }
    return ret;
}
```



**思路2**：Brian Kernighan 算法

在方法二中，对于 $s=(10001100)_2$ 的情况，我们需要循环右移 8 次才能得到答案。而实际上如果我们可以跳过两个 1 之间的 0，直接对 1 进行计数，那么就只需要循环 3 次即可。

我们可以使用 Brian Kernighan 算法进行优化，具体地，该算法可以被描述为这样一个结论：**记 f(x) 表示 x 和 x−1 进行与运算所得的结果（即 f(x)=x & (x−1)），那么 f(x) 恰为 x 删去其二进制表示中最右侧的 1 的结果**。

![](https://assets.leetcode-cn.com/solution-static/461/3.png)

基于该算法，当我们计算出 $s = x \oplus y$ ，只需要不断让 s=f(s)，直到 s=0 即可。这样每循环一次，s 都会删去其二进制表示中最右侧的 1，最终循环的次数即为 s 的二进制表示中 1 的数量。

```C++
int hammingDistance(int x, int y) {
    int s = x ^ y, ret = 0;
    while (s) {
        s &= s - 1;
        ret++;
    }
    return ret;
}
```







### L136. 只出现一次的数字

**[题目](https://leetcode-cn.com/problems/single-number/)**：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

```
示例 1:
输入: [2,2,1]
输出: 1

示例 2:
输入: [4,1,2,1,2]
输出: 4
```



**思路1**：异或运算。

如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。

* 使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。

* 使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。

* 使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。

上述三种解法都需要额外使用 O(n)的空间，其中 n 是数组长度。

如何才能做到线性时间复杂度和常数空间复杂度呢？

答案是使用位运算。对于这道题，可使用异或运算⊕。异或运算有以下三个性质。

* 任何数和 0 做异或运算，结果仍然是原来的数，即a⊕0=a。
* 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。
* 异或运算满足交换律和结合律，即 $a \oplus b \oplus a=b \oplus a \oplus a=b \oplus (a \oplus a)=b $

​    假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。令 $a_{1}$ 、$a_{2}$ 、$\ldots…$、$a_{m}$  为出现两次的 m 个数，$a_{m+1}$  为出现一次的数。根据性质 3，数组中的全部元素的异或运算结果总是可以写成如下形式：
$$
(a_{1} \oplus a_{1}) \oplus (a_{2} \oplus a_{2}) \oplus \cdots \oplus (a_{m} \oplus a_{m}) \oplus a_{m+1}
$$

根据性质 2 和性质 1，上式可化简和计算得到如下结果：
$$
0 \oplus 0 \oplus \cdots \oplus 0 \oplus a_{m+1}=a_{m+1}
$$
代码：

```C++
int singleNumber(vector<int>& nums) {
    int result=0;
    for(int x:nums) result^=x;
    return result;
}
```







### J56. 数组中数字出现的次数

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)**：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 

```
示例 1：
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]

示例 2：
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```


限制：

2 <= nums.length <= 10000



**思路1**：分组异或。

让我们先来考虑一个比较简单的问题：

如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？

答案很简单：**全员进行异或操作**即可。考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。

​	那么这一方法如何扩展到找出两个出现一次的数字呢？

​	如果我们可以把所有数字分成两组，使得：

* 两个只出现一次的数字在不同的组中；

* 相同的数字会被分到相同的组中。

  那么对两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。那么如何实现这样的分组呢？

​	记这两个只出现了一次的数字为 a 和 b，那么所有数字异或的结果就等于 a 和 b 异或的结果，我们记为 x。如果我们把 x 写成二进制的形式 $x_k x_{k - 1} \cdots x_2 x_1 x_0$ ，其中 $x_i \in \{ 0, 1 \}$，我们考虑一下 $x_i = 0$  和 $x_i = 1$ 的含义是什么？它意味着如果我们把 a 和 b 写成二进制的形式，$a_i$  和 $b_i$ 的关系——$x_i = 1$ 表示 $a_i$  和 $b_i$ 不等，$x_i = 0$ 表示 $a_i$  和 $b_i$  相等。**假如我们任选一个不为 0 的 $x_i$ ，按照第 i 位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组**，这样就能满足以上两个条件，为什么呢？

* 首先，两个相同的数字的对应位都是相同的，所以一个被分到了某一组，另一个必然被分到这一组，所以满足了条件 2。

* 这个方法在 $x_i = 1$ 的时候 a 和 b 不被分在同一组，因为 $x_i = 1$ 表示 $a_i$  和 $b_i$  不等，根据这个方法的定义「如果该位为 0 就分到第一组，否则就分到第二组」可以知道它们被分进了两组，所以满足了条件 1。

在实际操作的过程中，我们拿到序列的异或和 x 之后，对于这个「位」是可以任取的，只要它满足 $x_i = 1$。但是为了方便，这里的代码选取的是「不为 0 的最低位」，当然你也可以选择其他不为 0 的位置。

至此，答案已经呼之欲出了。

```C++
vector<int> singleNumbers(vector<int>& nums) {
    int ret = 0;
    for (int n : nums) ret ^= n;//计算所有元素的异或
    int div = 1;
    while ((div & ret) == 0) div <<= 1;//求异或结果为1的位
    int a = 0, b = 0;
    for (int n : nums){
        if (div & n)//如果n的第div位为1，则与a进行异或
            a ^= n;
    	else
        	b ^= n;
    }
    return vector<int>{a, b};
}
```



### L137. 只出现一次的数字 II

[题目](https://leetcode-cn.com/problems/single-number-ii/)：同J56 (下面)

### J56. 数组中数字出现的次数 II

**[题目]()**：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

 ```
示例 1：
输入：nums = [3,4,3,3]
输出：4

示例 2：
输入：nums = [9,1,7,9,7,9,7]
输出：1
 ```


限制：

1 <= nums.length <= 10000
1 <= nums[i] < 2^31



**分析**：

如下图所示，考虑数字的二进制形式，**对于出现三次的数字，各 二进制位 出现的次数都是 3 的倍数。**
**因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字**。

![](https://pic.leetcode-cn.com/28f2379be5beccb877c8f1586d8673a256594e0fc45422b03773b8d4c8418825-Picture1.png)



**思路1**：遍历统计。

将 counts各元素对 3 求余，则结果为 “只出现一次的数字” 的各二进制位。

利用 左移操作 和 或运算 ，可将 counts 数组中各二进位的值恢复到数字 res 上（循环区间是i∈[0,31] ）。

```C++
int singleNumber(vector<int>& nums) {
    //统计出每个位出现的次数
    vector<int> statistics(32);
    for(int x:nums){
        int b=1;
        for(int i=0;i<31;++i){
            if(b&x) statistics[i]+=1;
            b<<=1;
        }
    }
    //for(int c : statistics)cout<<c<<" ";
    //对次数进行取余
    int result=0;
    for(int i=0;i<32;++i){
        if((statistics[i]%3)==0)continue;
        result |= (1<<i);
    }
    return result;
}
```

另一种实现：

```C++
int singleNumber(vector<int>& nums) {
    vector<int> bits_num(32, 0);
    const int m = 3;
    for (int num: nums) {
        int index = 0;
        while (num > 1) {
            bits_num[index++] += num & 1;
            num = num/2;
        }
        bits_num[index] += num & 1;
    }
    int b = 0, res = 0;
    for (int bit: bits_num) {
        bit = bit % 3;
        res |= bit<<b;
        ++b;
    }
    return res;
}
```



**思路2**：有限状态机。







### J64. 求1+2+...+n

**[题目](https://leetcode-cn.com/problems/qiu-12n-lcof/)**：求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

 ```
示例 1：
输入: n = 3
输出: 6

示例 2：
输入: n = 9
输出: 45
 ```


限制：

1 <= n <= 10000



**思路1**：使用递归+逻辑运算。

简单的递归代码为：

```C++
int sumNums(int n) {
    if(n==1) return 1;
    return n+sumNums(n-1);
}
```

但是上面使用了`if`语句，因此需要通过别的方式停止递归。

通常实现递归的时候我们都会利用条件判断语句来决定递归的出口，但由于题目的限制我们不能使用条件判断语句，那么我们是否能使用别的办法来确定递归出口呢？答案就是逻辑运算符的短路性质。

以逻辑运算符 `&&` 为例，对于 `A && B` 这个表达式，如果 A 表达式返回 `False` ，那么 `A && B` 已经确定为 `False` ，此时不会去执行表达式 `B`。同理，对于逻辑运算符 `||`， 对于 `A || B` 这个表达式，如果 A 表达式返回 `True` ，那么 `A || B` 已经确定为 `True` ，此时不会去执行表达式 `B`。

利用这一特性，我们可以将判断是否为递归的出口看作 `A && B` 表达式中的 `A` 部分，递归的主体函数看作 `B` 部分。如果不是递归出口，则返回 `True`，并继续执行表达式 `B` 的部分，否则递归结束。当然，你也可以用逻辑运算符 `||` 给出类似的实现，这里我们只提供结合逻辑运算符 && 的递归实现。

```C++
int sumNums(int n) {
    n && (n += sumNums(n-1));
    return n;
}
```



**思路2**：快速乘。

考虑 A 和 B 两数相乘的时候我们如何利用加法和位运算来模拟，其实就是将 B 二进制展开，如果 B 的二进制表示下第`i` 位为 1，那么这一位对最后结果的贡献就是 `A*(1<<i)` ，即 `A<<i`。我们遍历 B 二进制展开下的每一位，将所有贡献累加起来就是最后的答案，这个方法也被称作「**俄罗斯农民乘法**」，感兴趣的读者可以自行网上搜索相关资料。这个方法经常被用于两数相乘取模的场景，如果两数相乘已经超过数据范围，但取模后不会超过，我们就可以利用这个方法来拆位取模计算贡献，保证每次运算都在数据范围内。

```C++
int quickMulti(int A, int B) {
    int ans = 0;
    while(B){
        if (B & 1) //遍历B的每一位
            ans += A;
        A <<= 1; 
       	B >>= 1;
    }
    return ans;
}
```



回到本题，由等差数列求和公式我们可以知道 $1 + 2 + \cdots + n$ 等价于 $\frac{n(n+1)}{2}$  ，对于除以 2 我们可以用右移操作符来模拟，那么等式变成了 n(n+1)>>1，剩下不符合题目要求的部分即为 n(n+1)，根据上文提及的快速乘，我们可以将两个数相乘用加法和位运算来模拟，但是可以看到上面的 C++ 实现里我们还是需要循环语句，有没有办法去掉这个循环语句呢？答案是有的，那就是自己手动展开，因为题目数据范围 n 为 `[1,10000]`，所以 n 二进制展开最多不会超过 14 位，我们手动展开 14 层代替循环即可，至此满足了题目的要求，具体实现可以参考下面给出的代码。

```C++
int sumNums(int n) {
    int ans = 0, A = n, B = n + 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    (B & 1) && (ans += A);
    A <<= 1;
    B >>= 1;

    return ans >> 1;
}
```





### L67. 二进制求和

**[题目](https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/)**：给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 非空 字符串且只包含数字 1 和 0。

 ```
示例 1:
输入: a = "11", b = "1"
输出: "100"

示例 2:
输入: a = "1010", b = "1011"
输出: "10101"
 ```


提示：

每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。



**思路1**：模拟

​	我们可以借鉴「列竖式」的方法，末尾对齐，逐位相加。在十进制的计算中「逢十进一」，二进制中我们需要「逢二进一」。

​	具体的，我们可以取 n=max{∣a∣,∣b∣}，循环 n 次，从最低位开始遍历。我们使用一个变量 carry 表示上一个位置的进位，初始值为 0。记当前位置对其的两个位为 $a_i$ 和 $b_i$，则每一位的答案为 $({\rm carry} + a_i + b_i) \bmod{2}$ ，下一位的进位为 $\lfloor \frac{{\rm carry} + a_i + b_i}{2} \rfloor$。重复上述步骤，直到数字 a 和 b 的每一位计算完毕。最后如果 carry 的最高位不为 0，则将最高位添加到计算结果的末尾。

​	注意，为了让各个位置对齐，你可以先反转这个代表二进制数字的字符串，然后低下标对应低位，高下标对应高位。当然你也可以直接把 a 和 b 中短的那一个补 0 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转。这里的代码给出第一种的实现。

```C++
class Solution {
public:
    string addBinary(string a, string b) {
        string ans;
        reverse(a.begin(), a.end());//翻转后，从低位到高位
        reverse(b.begin(), b.end());
        int n = max(a.size(), b.size());
        int carry = 0;//设置标志位
        for (size_t i = 0; i < n; ++i) {
            carry +=  i < a.size() ? (a.at(i) == '1') : 0;
            carry +=  i < b.size() ? (b.at(i) == '1') : 0;
            ans.push_back((carry % 2) ? '1' : '0');//当前位的结果
            carry /= 2;//设置是否进位，carry==2 || carry==3时设置进位1
        }
        if (carry) {
            ans.push_back('1');
        }
        reverse(ans.begin(), ans.end());

        return ans;
    }
};
```



**思路2**：位运算

我们可以设计这样的算法来计算：

* 把 a 和 b 转换成整型数字 x 和 y，在接下来的过程中，x 保存结果，y 保存进位。
* 当进位不为 0 时
  * 计算当前 x 和 y 的无进位相加结果：answer = x ^ y
  * 计算当前 x 和 y 的进位：carry = (x & y) << 1
  * 完成本次循环，更新  x = answer，y = carry

* 返回 x 的二进制形式

  为什么这个方法是可行的呢？在第一轮计算中，answer 的最后一位是 x 和 y 相加之后的结果，carry 的倒数第二位是 x 和 y 最后一位相加的进位。接着每一轮中，由于 carry 是由 x 和 y 按位与并且左移得到的，那么最后会补零，所以在下面计算的过程中后面的数位不受影响，而每一轮都可以得到一个低 i 位的答案和它向低 i+1 位的进位，也就模拟了加法的过程。

```python
class Solution:
    def addBinary(self, a, b) -> str:
        x, y = int(a, 2), int(b, 2)
        while y:
            answer = x ^ y
            carry = (x & y) << 1
            x, y = answer, carry
        return bin(x)[2:]
```














# 题目





## 题目

### J16. 数值的整数次方

**[题目](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)**:  实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

 ```
示例 1：

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
示例 3：

输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
 ```


提示：

-100.0 < x < 100.0
-2^31 <= n <= 2^31-1
-10^4 <= x^n <= 10^4



**思路1**：暴力法。（超时）



**思路2**：提前计算$x^{2^{i}}$。

当n很大时，需要能以$log_2(n)$的时间复杂度计算结果。因此，首先计算$x^{2^{i}}$，如$x,x^2,x^4,x^8,x^{16},...$。将结果存放到数组中。

我的实现：

```C++
class Solution {
public:
    double myPow(double x, int n) {
        //异常值处理
        if(n==0) return 1;
        int flag=n>0?1:-1;
        int64_t number=int64_t(n)*flag;
        //预计算
        int max_n = std::log((double)number)/std::log(2.) ;
        vector<double> arr(max_n+1);//arr[i]= x^(2^i)
        vector<int> indexs(max_n+1);
        arr[0]=x;
        indexs[0]=1;
        for(int i=1;i<=max_n;++i){
            arr[i]=arr[i-1]*arr[i-1];
            indexs[i]=2*indexs[i-1];
        }
        //正式计算
        double result=1;
        int index=max_n;
        while(number>0){
            while(number < indexs[index])index--;
            result *= arr[index];
            number-=indexs[index];
        }
        if(flag==-1)result=1./result;
        return result;
    }
};
```



**思路3**：快速幂法。

「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ ，我们可以按照：$x \to x^2 \to x^4 \to x^8 \to x^{16} \to x^{32} \to x^{64}$的顺序，从 xx 开始，每次直接把上一次的结果进行平方，计算 66 次就可以得到 $x^{64}$ 的值，而不需要对 x 乘 63 次 x。再举一个例子，如果我们要计算 $x^{77}$，我们可以按照：

$x \to x^2 \to x^4 \to x^9 \to x^{19} \to x^{38} \to x^{77}$的顺序，在 $x \to x^2，x^2 \to x^4，x^{19} \to x^{38}$这些步骤中，我们直接把上一次的结果进行平方，而在 $x^4 \to x^9$，$x^9 \to x^{19}$，$x^{38} \to x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。

直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：

* 当我们要计算 $x^n$ 时，我们可以先递归地计算出 $y = x^{\lfloor n/2 \rfloor}$，其中 $\lfloor a \rfloor$表示对 a 进行下取整；

* 根据递归计算的结果，如果 n 为偶数，那么 $x^n = y^2$；如果 n 为奇数，那么 $x^n = y^2 \times x$；

* 递归的边界为 n = 0，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 $O(\log n)$，算法可以在很快的时间内得到结果。

```c++
class Solution {
public:
    double quickMul(double x, long long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```





由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 x。但我们不妨找一找规律，看看哪些地方额外乘了 x，并且它们对答案产生了什么影响。我们还是以 $x^{77}$ 作为例子：

$x \to x^2 \to x^4 \to^+ x^9 \to^+ x^{19} \to x^{38} \to^+ x^{77}$
并且把需要额外乘 x 的步骤打上了 + 标记。可以发现：

* $x^{38} \to^+ x^{77}$  中额外乘的 x 在 $x^{77}$中贡献了 x；

* $x^9 \to^+ x^{19}$中额外乘的 x 在之后被平方了 2 次，因此在 $x^{77}$中贡献了 $x^{2^2} = x^4$；

* $x^4 \to^+ x^9$ 中额外乘的 xx 在之后被平方了 3 次，因此在 $x^{77}$中贡献了 $x^{2^3} = x^8$；

* 最初的 x 在之后被平方了 6 次，因此在 $x^{77}$中贡献了 $x^{2^6} = x^{64}$。

我们把这些贡献相乘，$x \times x^4 \times x^8 \times x^{64}$  恰好等于 $x^{77}$。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 x 在之后都会被平方若干次。**而这些指数 1，4，8 和 64，恰好就对应了 77 的二进制表示 $(1001101)_2$中的每个 1！**

因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 n 的二进制拆分为$n = 2^{i_0} + 2^{i_1} + \cdots + 2^{i_k}$, 那么$x^n = x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}$
这样以来，我们从 x 开始不断地进行平方，得到 $x^2, x^4, x^8, x^{16}, \cdots$,如果 n 的第 k 个（从右往左，从 0 开始计数）二进制位为 1，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。

```C++
class Solution {
public:
    double quickMul(double x, long long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```









## 位运算

### J15. 二进制中1的个数

**[题目](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)**: 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。

 提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

```
示例 1：
输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：
输入：n = 128 (控制台输入 00000000000000000000000010000000)
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```


提示：

输入必须是长度为 32 的 二进制串 。



**思路1**：通过&运算统计1的位数。

```C++
int hammingWeight(uint32_t n) {
    int ret = 0;
    for (int i = 0; i < 32; i++) 
    	if (n & (1 << i)) 
    		ret++;
    return ret;
}
```



**思路2**：位运算优化。

观察这个运算：n&(n - 1)，其预算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。

如：$6\&(6-1) = 4$,  $6 = (110)_2, 4 = (100)_2$ ，运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 n 与 n - 1 做与运算，直到 n 变为 0 即可。因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。

```C++
int hammingWeight(uint32_t n) {
	int ret = 0;
	while (n) {
		n &= n - 1;
		ret++;
	}
	return ret;
}
```





### L191. 位1的个数

**[题目](https://leetcode-cn.com/problems/number-of-1-bits/)**：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

 提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

**思路**：同上题J15

```C++
int hammingWeight(uint32_t n) {
    int number=0;
    for(int i=0;i<32;++i){
        if(n & (1<<i))number++;
    }
    return number;
}
```





## 正则表达式

### L10. 正则表达式匹配

**[题目](https://leetcode-cn.com/problems/regular-expression-matching/)**：给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

```
示例 1：
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。

示例 2:
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

示例 3：
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

示例 4：
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

示例 5：
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```


提示：

1 <= s.length <= 20
1 <= p.length <= 30
s 只含小写英文字母。
p 只含小写英文字母，以及字符 . 和 *。
保证每次出现字符 * 时，前面都匹配到有效的字符











### J19.正则表达式匹配

**[题目](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)**: 题目同上（L10）


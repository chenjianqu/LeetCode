# 题目





## 题目

### J16. 数值的整数次方

**[题目](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)**:  实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

 ```
示例 1：

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
示例 3：

输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
 ```


提示：

-100.0 < x < 100.0
-2^31 <= n <= 2^31-1
-10^4 <= x^n <= 10^4



**思路1**：暴力法。（超时）



**思路2**：提前计算$x^{2^{i}}$。

当n很大时，需要能以$log_2(n)$的时间复杂度计算结果。因此，首先计算$x^{2^{i}}$，如$x,x^2,x^4,x^8,x^{16},...$。将结果存放到数组中。

我的实现：

```C++
class Solution {
public:
    double myPow(double x, int n) {
        //异常值处理
        if(n==0) return 1;
        int flag=n>0?1:-1;
        int64_t number=int64_t(n)*flag;
        //预计算
        int max_n = std::log((double)number)/std::log(2.) ;
        vector<double> arr(max_n+1);//arr[i]= x^(2^i)
        vector<int> indexs(max_n+1);
        arr[0]=x;
        indexs[0]=1;
        for(int i=1;i<=max_n;++i){
            arr[i]=arr[i-1]*arr[i-1];
            indexs[i]=2*indexs[i-1];
        }
        //正式计算
        double result=1;
        int index=max_n;
        while(number>0){
            while(number < indexs[index])index--;
            result *= arr[index];
            number-=indexs[index];
        }
        if(flag==-1)result=1./result;
        return result;
    }
};
```



**思路3**：快速幂法。

「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ ，我们可以按照：$x \to x^2 \to x^4 \to x^8 \to x^{16} \to x^{32} \to x^{64}$的顺序，从 xx 开始，每次直接把上一次的结果进行平方，计算 66 次就可以得到 $x^{64}$ 的值，而不需要对 x 乘 63 次 x。再举一个例子，如果我们要计算 $x^{77}$，我们可以按照：

$x \to x^2 \to x^4 \to x^9 \to x^{19} \to x^{38} \to x^{77}$的顺序，在 $x \to x^2，x^2 \to x^4，x^{19} \to x^{38}$这些步骤中，我们直接把上一次的结果进行平方，而在 $x^4 \to x^9$，$x^9 \to x^{19}$，$x^{38} \to x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。

直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：

* 当我们要计算 $x^n$ 时，我们可以先递归地计算出 $y = x^{\lfloor n/2 \rfloor}$，其中 $\lfloor a \rfloor$表示对 a 进行下取整；

* 根据递归计算的结果，如果 n 为偶数，那么 $x^n = y^2$；如果 n 为奇数，那么 $x^n = y^2 \times x$；

* 递归的边界为 n = 0，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 $O(\log n)$，算法可以在很快的时间内得到结果。

```c++
class Solution {
public:
    double quickMul(double x, long long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```





由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 x。但我们不妨找一找规律，看看哪些地方额外乘了 x，并且它们对答案产生了什么影响。我们还是以 $x^{77}$ 作为例子：

$x \to x^2 \to x^4 \to^+ x^9 \to^+ x^{19} \to x^{38} \to^+ x^{77}$
并且把需要额外乘 x 的步骤打上了 + 标记。可以发现：

* $x^{38} \to^+ x^{77}$  中额外乘的 x 在 $x^{77}$中贡献了 x；

* $x^9 \to^+ x^{19}$中额外乘的 x 在之后被平方了 2 次，因此在 $x^{77}$中贡献了 $x^{2^2} = x^4$；

* $x^4 \to^+ x^9$ 中额外乘的 xx 在之后被平方了 3 次，因此在 $x^{77}$中贡献了 $x^{2^3} = x^8$；

* 最初的 x 在之后被平方了 6 次，因此在 $x^{77}$中贡献了 $x^{2^6} = x^{64}$。

我们把这些贡献相乘，$x \times x^4 \times x^8 \times x^{64}$  恰好等于 $x^{77}$。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 x 在之后都会被平方若干次。**而这些指数 1，4，8 和 64，恰好就对应了 77 的二进制表示 $(1001101)_2$中的每个 1！**

因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 n 的二进制拆分为$n = 2^{i_0} + 2^{i_1} + \cdots + 2^{i_k}$, 那么$x^n = x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}$
这样以来，我们从 x 开始不断地进行平方，得到 $x^2, x^4, x^8, x^{16}, \cdots$,如果 n 的第 k 个（从右往左，从 0 开始计数）二进制位为 1，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。

```C++
class Solution {
public:
    double quickMul(double x, long long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```



### L400. 同J44

[题目](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

### J44. 数字序列中某一位的数字

**[题目](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)**：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

 ```
示例 1：
输入：n = 3
输出：3

示例 2：
输入：n = 11
输出：0
 ```


限制：

0 <= n < 2^31



**思路1**：找规律。

根据题目，可知：

```
//0-9 长度 10
//0-99 长度10 + 2*90 =190
//0-999 长度 190 + 3*900 = 2890

因此：
arr[0]=10;
for(int i=1;i<N;++i) 
	arr[i]=arr[i-1]+ (i+1)*(9*std::pow(10,i));
```

因此，可以跟判断输入数字n属于的数字number是几位数的，比如对于n=200，可知对应的number的范围在100-999之间，因此n有3位数。

对于数字n，对应的数字为number，number的位数为digits。首先将n减去比n小一个级别的长度，比如对于n=200，大于0-99对应的190，则有res = n-190 =10。

number的计算：number = res/digits

n在number的第几位的计算： idx = res % digits

代码如下：

```C++
int findNthDigit(int n) {
    if(n<=9) return n;//0-9特殊处理
    int index=0;
    int start=10;
    for(int i=1;i<9;++i){//判断n是属于几次方的，比如n=200，大于0-99对应的190，此时得index=1
        long long count = start + (i+1LL)*(9LL*std::pow(10,i));
        if(n<count){
            index=i;
            break;
        }
        start=count;
    }
    int res = n - start;//比如对于n=200, 减去190后，得res=10
    int digits = index+1;//表示几位数，对于n=200，其对应的数字number的位数为3
    int number = res/digits+std::pow(10,index);//number表示n对应的数字
    int idx=res%(digits);//idx表示n对应于num第几位数
    return std::to_string(number)[idx]-'0';
}
```



**思路2**：官方的实现。

已知 `x` 位数共有 $9 \times 10^{x - 1}$ 个，所有 `x` 位数的位数之和是 $x \times 9 \times 10^{x - 1}$。使用 `d` 和 `count` 分别表示当前遍历到的位数和当前位数下的所有整数的位数之和，初始时 `d = 1`，`count=9`。每次将 `n` 减去 $d×count$，然后将 `d` 加 1，将 `count` 乘以 10，直到 $n \le d \times \textit{count}$，此时的 `d` 是目标数字所在整数的位数，`n` 是所有 `d` 位数中从第一位到目标数字的位数。

为了方便计算目标数字，使用目标数字在所有 d 位数中的下标进行计算，下标从 0 开始计数。令 `index=n−1`，则 `index` 即为目标数字在所有 d 位数中的下标，`index` 的最小可能取值是 0。

得到下标 `index` 之后，即可使用方法一的做法得到无限整数序列中的第 `n` 位数字。

```C++
int findNthDigit(int n) {
    int d = 1, count = 9;
    while (n > (long) d * count) {//计算位数d和当下位数所有整数的位数和count
        n -= d * count;
        d++;
        count *= 10;
    }
    int index = n - 1;//为目标数字在所有 d 位数中的下标
    int start = (int) pow(10, d - 1);//d位数的首数字
    int num = start + index / d;//n对应的数字num
    int digitIndex = index % d;//n在num中的索引
    int digit = (num / (int) (pow(10, d - digitIndex - 1))) % 10;//获得数字
    return digit;
}
```





**思路3**：二分查找。





### L263. 丑数

**[题目](https://leetcode-cn.com/problems/ugly-number/)**：给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

 ```
示例 1：
输入：n = 6
输出：true
解释：6 = 2 × 3

示例 2：
输入：n = 8
输出：true
解释：8 = 2 × 2 × 2

示例 3：
输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。

示例 4：
输入：n = 1
输出：true
解释：1 通常被视为丑数。
 ```


提示：

-2^31 <= n <= 2^31 - 1



**分析**：

根据丑数的定义，0 和负整数一定不是丑数。

当 n>0 时，若 n 是丑数，则 n 可以写成 $n = 2^a \times 3^b \times 5^c$ 的形式，其中 a,b,c 都是非负整数。特别地，当 a,b,c 都是 0 时，n=1。

为判断 n 是否满足上述形式，可以对 n 反复除以 2,3,5 , 直到 n 不再包含质因数2,3,5。若剩下的数等于 1，则说明 n 不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。



**思路1**：递归。

```C++
bool isUgly(int n) {
    if(n==1) 
        return true;
    else if(n%2!=0 && n%3!=0 && n%5!=0)
        return false;
    else if(n<1)
        return false;
    bool a=false,b=false,c=false;
    if(n%2==0 && isUgly(n/2)) return true;
    if(n%3==0 && isUgly(n/3)) return true;
    if(n%5==0 && isUgly(n/5)) return true;
    return false;
}
```



**思路2**：迭代。

```C++
bool isUgly(int n) {
    if (n <= 0) 
        return false;
    vector<int> factors = {2, 3, 5};
    for (int factor : factors) {
        while (n % factor == 0)
            n /= factor;
    }
    return n == 1;
}
```

时间复杂度：O(logn)。时间复杂度取决于对 n 除以 2,3,5 的次数，由于每次至少将 n 除以 2，因此除法运算的次数不会超过 O(logn)。

空间复杂度：O(1) 。



### L264. 丑数 II

**[题目](https://leetcode-cn.com/problems/ugly-number-ii/)**：同 J49。

### J49. 丑数

**[题目](https://leetcode-cn.com/problems/chou-shu-lcof/)**：我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

 ```
示例:
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
 ```


说明:  

1 是丑数。
n 不超过1690。



**分析**：本题的关键在于找到丑数递推的公式。

**思路1**：最小堆。

要得到从小到大的第 n 个丑数，可以使用最小堆实现。

初始时堆为空。首先将最小的丑数 1 加入堆。

每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x, 3x, 5x 也是丑数，因此将 2x, 3x, 5x 加入堆。

上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。

在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。

**时间复杂度**：O(nlogn)。得到第 n 个丑数需要进行 n 次循环，每次循环都要从最小堆中取出 1 个元素以及向最小堆中加入最多 3 个元素，因此每次循环的时间复杂度是 O(logn)，总时间复杂度是 O(nlogn)。

**空间复杂度**：O(n)。空间复杂度主要取决于最小堆和哈希集合的大小，最小堆和哈希集合的大小都不会超过 3n。

```C++
int nthUglyNumber(int n) {
    std::priority_queue<int64_t, std::vector<int64_t>, std::greater<int64_t>> small_heap;//最小堆
    std::unordered_set<int64_t> hash_set;
    small_heap.push(1);
    hash_set.insert(1);
    for(int i=1;i<n;++i){
        int64_t min = small_heap.top();//取出堆中的最小值
        small_heap.pop();
        if(int64_t tmp=min*2;hash_set.count(tmp)==0) {
            small_heap.push(tmp);
            hash_set.insert(tmp);
        }
        if(int64_t tmp=min*3;hash_set.count(tmp)==0) {
            small_heap.push(tmp);
            hash_set.insert(tmp);
        }
        if(int64_t tmp=min*5;hash_set.count(tmp)==0) {
            small_heap.push(tmp);
            hash_set.insert(tmp);
        }
    }
    return small_heap.top();
}
```



**思路2**：动态规划。

丑数的递推性质： 丑数只包含因子 2, 3, 5 ，因此有 “**丑数 == 某较小丑数 × 某因子**” （例如：10=5×2）。

设已知长度为 n 的丑数序列 $x_1, x_2, \cdots , x_n$，求第 n+1 个丑数 $x_{n+1}$ 。根根据递推性质，丑数 $x_{n+1}$  只可能是以下三种情况其中之一（索引 a, b, c为未知数）：

$$
x_{n+1} = \begin{cases} x_{a} \times 2 & ,a \in [1, n] \\ x_{b} \times 3 & ,b \in [1, n] \\ x_{c} \times 5 & ,c \in [1, n] \end{cases}
$$

​	丑数递推公式： 若索引 a,b,c 满足以上条件，则下个丑数 $x_{n+1}$  为以下三种情况中的 最小值 ；

$$
x_{n+1} = \min(x_{a} \times 2, x_{b} \times 3, x_{c} \times 5)
$$
​	由于 $x_{n+1}$ 是 最接近 $x_n$  的丑数，因此索引 a, b, c 需满足以下条件：

$$
\begin{cases} 
x_{a} \times 2 > x_n \geq x_{a-1} \times 2 & ，即 x_a 为首个乘以 2 后大于x_n 的丑数 \\ 
x_{b} \times 3 > x_n \geq x_{b-1} \times 3 & ，即 x_b 为首个乘以 3 后大于 x_n 的丑数 \\ 
x_{c} \times 5 > x_n \geq x_{c-1} \times 5 & ，即 x_c 为首个乘以 5 后大于 x_n 的丑数 \\ 
\end{cases}
$$

​	因此，可设置指针 a,b,c 指向首个丑数（即 1 ），循环根据递推公式得到下个丑数，并每轮将对应指针执行 +1 即可。

**动态规划解析**：

* 状态定义： 设动态规划列表 dp ，dp[i] 代表第 i+1 个丑数；
* 转移方程：
  * 当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；
  * 每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 ,dp[c]×5 的大小关系，若相等则将对应索引 a , b , c 加 1 ；

$$
\begin{cases} dp[a] \times 2 > dp[i-1] \geq dp[a-1] \times 2 \\ 
dp[b] \times 3 > dp[i-1] \geq dp[b-1] \times 3 \\ 
dp[c] \times 5 > dp[i-1] \geq dp[c-1] \times 5 \\ 
\end{cases}
$$

* 初始状态： dp[0] = 1 ，即第一个丑数为 1 ；
* 返回值： dp[n−1] ，即返回第 n 个丑数；



时间复杂度 O(N)： 其中 N = n ，动态规划需遍历计算 dp 列表。
空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N) 的额外空间。

```C++
int nthUglyNumber(int n) {
    int a = 0, b = 0, c = 0;
    int dp[n];
    dp[0] = 1;
    for(int i = 1; i < n; i++) {
        int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
        dp[i] = min(min(n2, n3), n5);
        if(dp[i] == n2) a++;
        if(dp[i] == n3) b++;
        if(dp[i] == n5) c++;
    }
    return dp[n - 1];
}
```









## 位运算

### J15. 二进制中1的个数

**[题目](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)**: 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。

 提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

```
示例 1：
输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：
输入：n = 128 (控制台输入 00000000000000000000000010000000)
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```


提示：

输入必须是长度为 32 的 二进制串 。



**思路1**：通过&运算统计1的位数。

```C++
int hammingWeight(uint32_t n) {
    int ret = 0;
    for (int i = 0; i < 32; i++) 
    	if (n & (1 << i)) 
    		ret++;
    return ret;
}
```



**思路2**：位运算优化。

观察这个运算：n&(n - 1)，其预算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。

如：$6\&(6-1) = 4$,  $6 = (110)_2, 4 = (100)_2$ ，运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 n 与 n - 1 做与运算，直到 n 变为 0 即可。因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。

```C++
int hammingWeight(uint32_t n) {
	int ret = 0;
	while (n) {
		n &= n - 1;
		ret++;
	}
	return ret;
}
```





### L191. 位1的个数

**[题目](https://leetcode-cn.com/problems/number-of-1-bits/)**：编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

 提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

**思路**：同上题J15

```C++
int hammingWeight(uint32_t n) {
    int number=0;
    for(int i=0;i<32;++i){
        if(n & (1<<i))number++;
    }
    return number;
}
```





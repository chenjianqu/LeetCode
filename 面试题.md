## 美团2021校招笔试-编程题(通用编程试题,第9场)

### 买蛋糕

小团的蛋糕铺长期霸占着美团APP中“蛋糕奶茶”栏目的首位，因此总会吸引各路食客前来探店。

小团一天最多可以烤n个蛋糕，每个蛋糕有一个正整数的重量。

早上，糕点铺已经做好了m个蛋糕。

现在，有一个顾客要来买两个蛋糕，他希望买这一天糕点铺烤好的最重的和最轻的蛋糕，并且希望这两个蛋糕的重量恰好为a和b。剩余的n-m个蛋糕可以现烤，请问小团能否满足他的要求？

数据范围：![img](https://www.nowcoder.com/equation?tex=1%20%5Cle%20m%20%5Cle%20n%20%5Cle%201000%5C)，![img](https://www.nowcoder.com/equation?tex=1%5Cle%20a%2Cb%20%5Cle%201000%5C)

进阶：时间复杂度![img](https://www.nowcoder.com/equation?tex=O(m)%5C),空间复杂度![img](https://www.nowcoder.com/equation?tex=O(m)%5C)



输入描述:

```
输入包含多组数据，每组数据两行。每组数据的第一行包含4个整数，n,m,a,b，空格隔开。这里不保证a和b的大小关系。接下来一行m个数，空格隔开，代表烤好的蛋糕重量
```



**输出描述:**

```
对于每一组数据，如果可以办到顾客的要求，输出YES，否则输出NO
```



**输入例子1:**

```
4 2 2 4
3 3
4 2 2 4
1 1
4 2 2 4
5 5
4 2 4 2
2 4
2 2 2 4
3 3
3 2 2 4
3 3
3 2 2 4
3 3
```



**输出例子1:**

```
YES
NO
NO
YES
NO
NO
NO
```





**解答**

```C++
#include<iostream>
#include<vector>

using namespace std;

int main()
{
    ///输入输出
    while(true){
        int n,m,a,b;
        if(! (cin>>n)){
            break;
        }
        cin>>m;
        cin>>a;
        cin>>b;

        vector<int> exist_data(m);
        for(int i=0;i<m;++i){
            cin>>exist_data[i];
        }
        ///判断
        if(a>b)
            std::swap(a,b);

        bool exist_a=false,exist_b=false,success=true;
        for(int i=0;i<m;++i){
            if(exist_data[i]<a || exist_data[i]>b){
                success=false;
                break;
            }
            else if(exist_data[i]==a){
                exist_a=true;
            }
            else if(exist_data[i]==b){
                exist_b=true;
            }
        }

        if(!success){
            cout<<"NO"<<endl;
        }
        else{
            if(!exist_a && !exist_b && n-m<2){
                cout<<"NO"<<endl;
            }
            else if((!exist_a || !exist_b) && n-m<1){
                cout<<"NO"<<endl;
            }
            else{
                cout<<"YES"<<endl;
            }
        }
    }
    
    return 0;
}
```





### 综艺晋级人数

小团是某综艺节目的策划，他为某个游戏环节设计了一种晋级规则，已知在这个游戏环节中每个人最后都会得到一个分数score_i，显而易见的是，游戏很有可能出现同分的情况，小团计划该环节晋级人数为x人，则将所有人的分数从高到低排序，所有分数大于等于第x个人的分数且得分不为0的人都可以晋级。

请你求出本环节的实际晋级人数。显然这个数字可能是0，如果所有人的得分都是0，则没有人满足晋级条件。

**输入描述:**

```
输入第一行包含两个正整数n和x，分别表示参加本环节的人数，和小团指定的x。输入第二行包含n个整数，每个整数表示一位选手的得分。
```

**输出描述:**

```
输出仅包含一个整数，表示实际晋级人数。
```

**输入例子1:**

```
5 4 
0 0 2 3 4
```

**输出例子1:**

```
3
```



代码：

（只过1）

```C++
#include<string>
#include<vector>
#include<iostream>
#include<algorithm>

using namespace std;

int main()
{
    //while(true){
        //输入第一行包含两个正整数n和x，分别表示参加本环节的人数，和小团指定的x。
        //输入第二行包含n个整数，每个整数表示一位选手的得分。
        int n,x;
        //if(!( cin>>n)) break;
        cin>>n;
        cin>>x;
        if(x>n || x<0 || n<0)
            return 0;
        vector<int> data(n);
        for(int i=0;i<n;++i){
            cin>>data[i];
        }

        //排序
        std::sort(data.begin(),data.end(),[](int a,int b){return a>b;});
        //for(int i=0;i<n;++i) cout<<data[i]<<" ";
        x--;
        if(data[x]==0){
            while(x>=0 && data[x]==0)
                x--;
        }
        else if(x<n-1 && data[x]==data[x+1]){
            int tmp = data[x];
            while(x<n && data[x]==tmp)
                x++;
        }
        
        cout<<x+1<<endl;
        
    //}
    return 0;
}
```





### 循环连续子数组和

小美请小团吃回转寿司。转盘上有N盘寿司围成一圈，第1盘与第2盘相邻，第2盘与第3盘相邻，…，第N-1盘与第N盘相邻，第N盘与第1盘相邻。小团认为第i盘寿司的美味值为A[i]（可能是负值，如果小团讨厌这盘寿司）。现在，小团要在转盘上选出连续的若干盘寿司，使得这些寿司的美味值之和最大（允许不选任何寿司，此时美味值总和为0）。



**输入描述:**

```
第一行输入一个整数T（1<=T<=10），表示数据组数。每组数据占两行，第一行输入一个整数N（1<=N<=10^5）；第二行输入N个由空格隔开的整数，表示A[1]到A[N]（-10^4<=A[i]<=10^4）。
```



**输出描述:**

```
每组数据输出占一行，输出一个整数，表示连续若干盘寿司的美味值之和的最大值。
```



**输入例子1:**

```
1
4
3 -2 4 -1
```



**输出例子1:**

```
6
```



**例子说明1:**

```
美味值之和最大连续若干盘寿司为第3盘、第4盘和第1盘。 
```



代码：

(错误答案)

```C++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>

using namespace std;

int main()
{
    //第一行输入一个整数T（1<=T<=10），表示数据组数。
    //每组数据占两行，第一行输入一个整数N（1<=N<=10^5）；
    //第二行输入N个由空格隔开的整数，表示A[1]到A[N]（-10^4<=A[i]<=10^4）。
    int num_group;
    cin>>num_group;
    vector<vector<int>> data(num_group);
    for(int i=0;i<num_group;++i){
        int size;
        cin>> size;
        data[i].resize(size);
        for(int j=0;j<size;++j){
            cin>>data[i][j];
        }
    }
    //开始处理，贪心算法
    for(int k=0;k<num_group;++k){
        int n = data[k].size();
        int last_start=0;
        vector<int> dp(n);//dp[i]表示到第i个位置的最大数组和
        dp[0] = std::max(data[k][0],0);
        for(int i=1;i<n;++i){
            dp[i] = std::max(dp[i-1]+data[k][i],data[k][i]);
            if(dp[i]==data[k][i]){
                last_start = i;
            }
        }
        //重新计算dp
        cout<<last_start<<endl;
        if(last_start!=0){
            int end_index= last_start-1;
            for(int i=0;i<n;++i)
                dp[i]=0;
            for(int i=last_start;i!=last_start;++i){
                i%=data[k].size();
                dp[i] = std::max(dp[i-1]+data[k][i],data[k][i]);
            }
        }
        
        int max_e = *std::max_element(dp.begin(),dp.end());
        cout<<max_e<<endl;
    }
    
    return 0;
}
```



## 美团笔试 2022-03-12 16:00 

4道编程题、4道多选题



编程题：只记得前两题。

### 判断幸运数

较简单。



### 乘积为1的连续子序列数量

给定一个长度为n、包含1和-1的数组nums，求 乘积大于0的连续子序列 的数量。

如给定n=4，数组为1,1,-1,-1，则合法的子序列为：

```
1
1 
1 1
-1 -1
1 -1 -1
1 1 -1 -1
```



**思路1**：动态规划。

分析：

dp[i]表示以nums[i]结尾的“乘积大于0的连续子序列”的数量.

递推公式：

​	当nums[i]为1时，dp[i] = dp[i-1] + 1，其中+1是因为元素nums[i]是新的单独子序列。

   当nums[i]为-1时，前面已有偶数个-1时，dp[i]=0；当前面有奇数个-1时，则dp[i]等于上一个-1位置处的dp的数量再+1。

初始化：

​	dp[0]根据nums[0]进行初始化



1,1,1,-1,1,-1



对于动态规划的数组，当nums[i]为1，






































# 数组

## 常见算法

### 双指针



## 题目



### J03. 数组中重复的数字

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)**:找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 



```

限制：

2 <= n <= 100000



**思路1**：暴力法。先排序，后遍历。

简单粗暴，时间复杂度为O(nlogn)。

```c++
int findRepeatNumber(vector<int>& nums) {
    std::sort(nums.begin(),nums.end());
    for(int i=0;i<nums.size()-1;++i)
	    if(nums[i]==nums[i+1])
	    	return nums[i];
    return nums[0];
}
```



**思路2**：原地交换。

题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。
因此，可遍历数组并通过交换操作，使**元素的 索引 与 值 一一对应**（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。

遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x] = x，此时即可得到一组重复数字。

```C++
int findRepeatNumber(vector<int>& nums) {
    for(int i=0;i<nums.size();++i){
        int n=nums[i];
        if(i!=n && nums[n]==n) 
            return n;
        else
            std::swap(nums[i],nums[n]);
    }
    return nums[0];
}
```







### L2022. 将一维数组转变成二维数组

**题目**:
给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有
元素创建一个 m 行 n 列的二维数组。  
original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都
包含 ）的元素构成二维数组的第二行，依此类推。
请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。

**代码：**
```C++
    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
        if(original.size() != m*n)
            return vector<vector<int>>();
        vector<vector<int>> arr(m);
        for(int i=0;i<original.size();i+=n ){
                vector<int> row(n);
            for(int j=0;j<n;++j){
                row[j] = original[i+j];
            }
            arr[static_cast<int>(i/n)]=row;
        }
        return arr;
    }
```



### J04. 二维数组中的查找

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)**: 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 ```
示例:
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
 ```

限制：

0 <= n <= 1000

0 <= m <= 1000



**思路1**：暴力法。

遍历二维数组，时间复杂度O(n*m)



**思路2**：线性查找法。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。

若数组为空，返回 false
初始化行下标为 0，列下标为二维数组的列数减 1
重复下列步骤，直到行下标或列下标超出边界
获得当前下标位置的元素 num
如果 num 和 target 相等，返回 true
如果 num 大于 target，列下标减 1
如果 num 小于 target，行下标加 1
循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false

```C++
bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
    if(matrix.empty()) return false;
    for(int i=0,j=matrix[0].size()-1;i<matrix.size() && j>=0;){
        if(matrix[i][j]==target)
            return true;
        else if(matrix[i][j]<target)
            ++i;
        else if(matrix[i][j]>target)
            --j;
    }
    return false;
}
```





### L136. 只出现一次的数字

**题目**:题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。  
说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**思路1**：使用哈希表对数组元素进行计数，最后遍历哈希表，找到计数为1的数。
```C++
int singleNumber(vector<int>& nums) {
    std::unordered_map<int,int> d;
    for(int i=0;i<nums.size();++i){
        if(d.find(nums[i])==d.end())
            d.insert({nums[i],1});
        else
            d[nums[i]]++;
    }
    for(auto [num,count] : d) if(count==1) return num;
    return 0;
}
```

**思路2**：使用异或运算。
  如何才能做到线性时间复杂度和常数空间复杂度呢？答案是使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。  
任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。   
任何数和其自身做异或运算，结果是 0，即 a⊕a=0。   
异或运算满足交换律和结合律，即 a⊕b⊕a = b⊕a⊕a = b⊕(a⊕a) = b⊕0=b。  
 因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。  
```C++
int singleNumber1(vector<int>& nums) {
        int result =0;
        for(int i=0;i<nums.size();++i)
            result ^= nums[i];
        return result;
}
```

### L169. 多数元素
**题目**：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。  
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**思路1**：采用哈希表（简单粗暴）
```C++
int majorityElement(vector<int>& nums) {
std::unordered_map<int,int> d;
for(int i=0;i<nums.size();++i){
    if(d.find(nums[i])==d.end())
	d.insert({nums[i],1});
    else
	d[nums[i]]++;
}
for(auto [num,count]:d){
    if(count>std::floor(nums.size()/2))
	return num;
}
return 0;
}
```
**思路2**：先排序，排序后数组的中间值肯定是众数。

**思路3**：分治算法。
如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。  
我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l / 2 + r / 2 次，
其中 l 和 r 分别是左半部分和右半部分的长度。由于 l / 2 + r / 2 <= (l + r) / 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。  
这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。  

**思路4**：Boyer-Moore 投票算法
Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：  
我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；  
我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：  
如果 x 与 candidate 相等，那么计数器 count 的值增加 1；  
如果 x 与 candidate 不等，那么计数器 count 的值减少 1。  
在遍历完成后，candidate 即为整个数组的众数。
```
int majorityElement(vector<int>& nums) {
int candidate = -1;
int count = 0;
for (int num : nums) {
    if (num == candidate)
	++count;
    else if (--count < 0) {
	candidate = num;
	count = 1;
    }
}
return candidate;
}
```





### L349. 两个数组的交集

**题目**: 给定两个数组，编写一个函数来计算它们的交集。 

说明：

- 输出结果中的每个元素一定是唯一的。
- 我们可以不考虑输出结果的顺序。

**思路1**：使用两个哈希集合，第一个哈希集合存放第一个数组的元素，第二个哈希集合存放 交集元素。最后再把第二个哈希集合转移到输出数组中。

```C++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    std::unordered_set<int> hash_set,out_set;
    std::vector<int> arr;
    for(int i=0;i<nums1.size();++i)
        hash_set.insert(nums1[i]);
    for(int i=0;i<nums2.size();++i)
        if(hash_set.count(nums2[i])>0)
            out_set.insert(nums2[i]);
    for(auto e:out_set) arr.push_back(e);
    return arr;
}
```

**思路2**： 排序+双指针。首先对两个数组进行排序，然后分别对两个数组设置一个指针，用于指向正在比较的数组的元素。对于每个指针，还需要判断去掉重复的元素。

```C++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    std::sort(nums1.begin(),nums1.end());
    std::sort(nums2.begin(),nums2.end());
    vector<int> arr;
    for(int i=0,j=0;i<nums1.size()&&j<nums2.size();){
        if(i>0 && nums1[i]==nums1[i-1]){
            ++i;
            continue;
        }
        if(j>0 && nums2[j]==nums2[j-1]){
            ++j;
            continue;
        }
        if(nums1[i]==nums2[j]){
            arr.push_back(nums1[i]);
            ++i;
            ++j;
        }
        else if(nums1[i]<nums2[j]){
            ++i;
        }
        else{
            ++j;
        }
    }
    return arr;
}
```





### L1. 两数之和
**题目**：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，
并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。  

**思路1**：遍历。  
```C++
vector<int> twoSum(vector<int>& nums, int target) {
    for(int i=0;i<nums.size();++i)
        for(int j=i+1;j<nums.size();++j)
            if(nums[i]+nums[j]==target)
                return vector<int>{i,j};
    return vector<int>{0,1};
}
```
**思路2**:哈希表。记录遍历过的值到哈希表。
```C++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int,int> d;
    for(int i=0;i<nums.size();++i){
        if(d.find(target-nums[i])!=d.end())
            return vector<int>{i,d[target-nums[i]]};
        if(d.find(nums[i])==d.end())
            d.insert({nums[i],i});
    }
    return vector<int>{0,1};
}
```



### L167. 两数之和 II - 输入有序数组

**题目**：给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

**思路1**：由于给定的是一个排序好的数组，则直接双指针。

```C++
vector<int> twoSum(vector<int>& numbers, int target) {
    for(int i=0,j=numbers.size()-1;i<j;){
        while(i<j && numbers[i]+numbers[j]>target)
            --j;
        if(numbers[i]+numbers[j] == target)
            return vector<int>{i+1,j+1};
        while(i<j && numbers[i]+numbers[j]<target)
            ++i;
    }
    return vector<int>();
}
```



**思路2**：二分查找。对于遍历每个元素numbers[i]，使用二分查找target - numbers[i]即可。时间复杂度为nlogn。





### L15. 三数之和

**题目**：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？
请你找出所有和为 0 且不重复的三元组。  
注意：答案中不可以包含重复的三元组。  

**思路1**:遍历法，双重循环，外层单指针，内双指针。时间复杂度O(n^2)  
```C++
int Partition(vector<int> &arr,int low,int high){
    int key=arr[low];
    while(low<high){
        while(low<high && arr[high]>=key)
            high--;
        arr[low]=arr[high];
        while(low<high && arr[low]<=key)
            low++;
        arr[high]=arr[low];
    }
    arr[low]=key;
    return low;
}
void QSort(vector<int> &arr,int low,int high){
    if(low < high){
        int parting = Partition(arr,low,high);
        QSort(arr,low,parting-1);
        QSort(arr,parting+1,high);
    }
}

vector<vector<int>> threeSum(vector<int>& nums) {
    const int n = nums.size();
    vector<vector<int>> output;
    //先排序
    QSort(nums,0,nums.size()-1);
    //外层单指针，内层双指针
    for (int first = 0; first < n; ++first) {
        if (first > 0 && nums[first] == nums[first - 1])  // 需要和上一次枚举的数不相同
            continue;
        int third = n - 1;// c 对应的指针初始指向数组的最右端
        int target = -nums[first];
        for (int second = first + 1; second < n; ++second) {
            if (second > first + 1 && nums[second] == nums[second - 1]) // 需要和上一次枚举的数不相同
                continue;
            while (second < third && nums[second] + nums[third] > target)  // 需要保证 b 的指针在 c 的指针的左侧
                --third;
            if (second == third)
                break;
            if (nums[second] + nums[third] == target)
                output.push_back({nums[first], nums[second], nums[third]});
        }
    }
    return output;
}
```


### L16. 最接近的三数之和
**题目**：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，
使它们的和与 target 最接近。 返回这三个数的和。  
假定每组输入只存在恰好一个解。

**思路1**: 直接暴力解法的时间复杂度时O(n^3)。同上一题一样，内层循环可以用双指针降低复杂度。  
为了使用双指针，需要首先对数组进行排序，复杂度为O(nlogn)。与上一题不同的是，不需要考虑重复的3元组。
```C++
int threeSumClosest(vector<int>& nums, int target) {
    std::sort(nums.begin(),nums.end());
    int closest_sum=0;
    int delta = INT_MAX;
    for(int i=0;i<nums.size();++i){
        int j=i+1,k=nums.size()-1;
        while(j<k){
            int sum = nums[i]+nums[j]+nums[k];
            if(std::abs(target-sum)<delta){
                delta = std::abs(target-sum);
                closest_sum = sum;
                if(delta==0)break;
            }
            if(sum<=target)
                j++;
            else if(sum>target)
                k--;
        }
    }
    return closest_sum;
}
```





### L18. 四数之和

**题目**：
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] 
（若两个四元组元素一一对应，则认为两个四元组重复）：  
* 0 <= a, b, c, d < n
* a、b、c 和 d 互不相同
* nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。

**思路1**: 与L16差不多，外层是两个暴力双循环，内层是一个双指针。为了去掉重复的4元组，这里通过
集合set来保存结果。注意，本题还要考虑数据范围的问题。

```C++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> arr;
    if(nums.size()<4)
        return arr;
    std::set<vector<int>> num_set;
    //排序
    std::sort(nums.begin(),nums.end());
    //内外层双指针
    int n = nums.size();
    for(int i=0;i<n;++i){
        for(int j=i+1;j<n;++j){
            int k=j+1,l= n-1;
            while(k<l){
                int64_t sum = static_cast<int64_t>(nums[i])+static_cast<int64_t>(nums[j])+
                        static_cast<int64_t>(nums[k])+static_cast<int64_t>(nums[l]);
                if(sum==target){
                    num_set.insert({nums[i],nums[j],nums[k],nums[l]});
                    k++;
                }
                else if(sum>target) l--;
                else k++;
            }
        }
    }

    for(auto &v : num_set)
        arr.push_back(v);
    return arr;
}

```





### L724. 寻找数组的中心下标

**题目**：给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

**思路1**：暴力解法。从左到右遍历每一个可能的中心下标，计算左右两边的和，并判断两边是否相等。

```C++
int pivotIndex(vector<int>& nums) {
    int left_sum=0;
    int right_sum=0;
    for(int j=1;j<nums.size();++j) right_sum+=nums[j];//算法中心下标在0处的情况
    if(right_sum==0) return 0;

    for(int i=0;i<nums.size()-1;++i){
        left_sum+=nums[i];
        right_sum=0;
        for(int j=i+2;j<nums.size();++j) right_sum+=nums[j];
        if(left_sum==right_sum)
            return i+1;
    }
    return -1;
}
```

**思路2**：单层循环。只需要遍历一边中心下标即可，每次迭代时，更新左边的和，右边的和。

```C++
int pivotIndex(vector<int>& nums) {
    int left_sum=0;
    int right_sum=std::accumulate(nums.begin()+1,nums.end(),0);
    for(int i=0;i<nums.size();++i){
        if(left_sum == right_sum) return i;
        if(i==nums.size()-1) break;
        left_sum+=nums[i];
        right_sum -=nums[i+1];
    }
    return -1;
}
```



## 数组的合并和拆分



### L56. 合并区间

**题目**：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**思路1**：暴力法，双重循环比较两个之间是否重叠。该方法会“超出时间限制”。

**思路2**：（这道题第9次提交才对）首先对输入的区间数组进行排序，则重叠的区间肯定相邻。遍历一遍，对相邻重叠区间进行合并。当第i个区间与i+1个区间不相邻时，将第i个区间添加到输出数组。

```C++
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    int n=intervals.size();
    if(n==1)
        return vector<vector<int>>{intervals[0]};
    std::sort(intervals.begin(),intervals.end());
    vector<vector<int>> output;
    for(int i=0;i<intervals.size()-1;++i){
        if(intervals[i][1]>=intervals[i+1][0]){//i和i+1重叠
            intervals[i+1][0] = intervals[i][0];
            intervals[i+1][1] = std::max(intervals[i][1],intervals[i+1][1]);
        }else{
            output.push_back(intervals[i]);
        }
    }
    if(intervals[n-2][1]>=intervals[n-1][0]){//n-1和n-2重叠
        intervals[n-1][0] = intervals[n-2][0];
        intervals[n-1][1] = std::max(intervals[n-2][1],intervals[n-1][1]);
    }
    output.push_back(intervals[n-1]);
    return output;
}
```









### L561. 数组拆分I

给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。

返回该 最大总和 。

```
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```



**思路1**：首先进行排序，得到升序数组，0-1,2-3, 4-5 ...划分为一组。因此结果为第0个、第2个、第4个...元素的和。

```C++
int arrayPairSum(vector<int>& nums) {
    std::sort(nums.begin(),nums.end());
    int sum=0;
    for(int i=0;i<nums.size();i+=2)
        sum+=nums[i];
    return sum;
}
```





## 矩阵的搜索



### J12. 矩阵中的路径

**[题目](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)**：给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

```
示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

示例 2：
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

提示：

    1 <= board.length <= 200
    1 <= board[i].length <= 200
    board 和 word 仅由大小写英文字母组成



**思路1**：深度优先搜索。









# 字符串

## 常见算法

### KMP算法

[文章](https://zhuanlan.zhihu.com/p/105629613)

Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(m+n)。

**构造Next数组**：next[i] 对应的下标，为 P[0...i - 1] 的最长*公共前缀后缀*的长度，令 P[0] = -1。 具体解释如下：

例如对于字符串 abcba：

前缀：它的前缀包括：a, ab, abc, abcb，不包括本身；
后缀：它的后缀包括：bcba, cba, ba, a，不包括本身；
最长公共前缀后缀：abcba 的前缀和后缀中只有 a 是公共部分，字符串 a 的长度为 1。
所以，我们将 P[0...i - 1] 的最长公共前后缀的长度作为 next[i] 的下标，就得到了 next 数组。



```C++
int strStr(string haystack, string needle) {
    int n = haystack.size(), m = needle.size();
    if (m == 0)  return 0;
    vector<int> pi(m);///构造Next数组
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && needle[i] != needle[j]) j = pi[j - 1];
        if (needle[i] == needle[j])  j++;
        pi[i] = j;
    }
    for (int i = 0, j = 0; i < n; i++) {
        while (j > 0 && haystack[i] != needle[j])
            j = pi[j - 1];
        if (haystack[i] == needle[j])
            j++;
        if (j == m) 
            return i - m + 1;
    }
    return -1;
}

```





## 题目

### L344. 反转字符串

**题目**：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**思路**：遍历法，使用双指针。

```C++
void reverseString(vector<char>& s) {
	for(int i=0;i<s.size()/2;++i) 
        std::swap(s[i],s[s.size()-i-1]);
}
```





### L14. 最长公共前缀

**题目**：编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

 ```C++
示例 1：
输入：strs = ["flower","flow","flight"]
输出："fl"
 ```

**思路1**：纵向扫描。双重循环，外层循环从左往右遍历字符，内层循环从左往右遍历字符串，比较每个字符串在相同位置上是否拥有相同的元素。

```C++
string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty())
            return "";
        string output;
        for(int i=0;i<strs[0].size();++i){
            bool flag=true;
            char c = strs[0][i];
            for(int j=1;j<strs.size();++j){
                if(strs[j][i]!=c){
                    flag=false;
                    break;
                }
            }
            if(flag) output.push_back(c);
            else break;
        }
        return output;
    }
```



**思路2**：横向扫描。 依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。 

```
string longestCommonPrefix(vector<string>& strs) {
	if (!strs.size()) return "";
	string prefix = strs[0];
	int count = strs.size();
    for (int i = 1; i < count; ++i) {
        prefix = longestCommonPrefix(prefix, strs[i]);
        if (!prefix.size()) break;
    }
    return prefix;
}

string longestCommonPrefix(const string& str1, const string& str2) {
    int length = min(str1.size(), str2.size());
    int index = 0;
    while (index < length && str1[index] == str2[index])
	    ++index;
    return str1.substr(0, index);
}

```

**思路3**：分治法。

注意到  $\textit{LCP}$ 的计算满足结合律，有以下结论：

$$
\textit{LCP}(S_1 \ldots S_n) 
\\ = \textit{LCP}(\textit{LCP}(S_1 \ldots S_k), \textit{LCP} (S_{k+1} \ldots S_n))
$$
其中 ${LCP}(S_1 \ldots S_n)$ 是字符串$S_1 \ldots S_n$的最长公共前缀。基于上述结论，可以使用分治法得到字符串数组中的最长公共前缀。对于问题 ${LCP}(S_i \ldots S_j)$，可以分解成两个子问题 ${LCP}(S_i \ldots S_{mid})$和${LCP}(S_{mid+1} \ldots S_j)$，其中 $mid=\frac{i+1}{2}$。

**思路4**：二分查找。

显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。用minLength 表示字符串数组中的最短字符串的长度，则可以在 [0,minLength] 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值mid，判断每个字符串的长度为mid 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 mid，如果不相同则最长公共前缀的长度一定小于mid，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。







### L205. 同构字符串

**题目**：给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

```
输入：s = "egg", t = "add"
输出：true

输入：s = "foo", t = "bar"
输出：false

输入：s = "paper", t = "title"
输出：true
```

**思路1**：用哈希表。由于要求“不同字符不能映射到同一个字符上”，因此需要两个哈希表，一个用来将s映射到t，另一个用来将t映射到s。

```C++
bool isIsomorphic(string s, string t) {
    if(s.size()!=t.size())
        return false;
    std::unordered_map<char,char> hash_map;
    std::unordered_map<char,char> value_map;
    for(int i=0;i<s.size();++i){
        bool find_s = hash_map.find(s[i])!=hash_map.end();
        if(!find_s){
            if(value_map.find(t[i])!=value_map.end())//题目要求不同字符不能映射到同一个字符
                return false;
            hash_map.insert({s[i],t[i]});
            value_map.insert({t[i],s[i]});
        }
        else if(hash_map[s[i]]!=t[i])
                return false;
    }
    return true;
}
```



### L151. 翻转字符串里的单词

**题目**：给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。

```C++
输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
```

**思路1**：单层遍历法。这种方法需要额外的字符串。空间复杂度为(n)。从后往前遍历输入字符串，当遇到空格时，将刚刚经过的字符串添加到输出字符串。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    //翻转单词
    int n=s.size();
    string out,tmp;
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' ' && s[i]==s[i+1] ){//去除重复的字符串
            continue;
        }
        if(s[i]==' '){
            out += s.substr(i+1,len);
            out+=" ";//补上空格
            len=0;
            continue;
        }
        else if(i==0){
            out += s.substr(i,len+1);//由于最后一次结束没到' '，因此len需要补上1
        }
        len++;
    }
    return out;
}
```



**思路2**：先翻转整个字符串，再逐个翻转单词。时间复杂度O(n)，空间复杂度O(1)。



**思路3**：使用队列，队列具有先进先出的特性，在遍历字符串时从后往前，将每个单词入到队列中。最后将队列中的单词串联成输出字符串。时间复杂度:O(n)，空间复杂度O(n)。

```C++
string reverseWords(string s) {
    //去除前后空格
    if( !s.empty() ){
        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    }
    int n=s.size();
    std::queue<string> q;
    //从后往前遍历字符串，将单词放入队列中。
    for(int i=n-1,len=0;i>=0;--i){
        if(s[i]==' '){
            if(s[i]==s[i+1])//去除连续空格
                continue;
            else
                q.push(s.substr(i+1,len));
            len=0;
            continue;
        }
        else if(i==0){
            q.push(s.substr(0,len+1));
        }
        len++;
    }
    //将队列中的单词串联成输出字符串。
    int qsize=q.size();;
    string out;
    for(int i=0;i<qsize;++i){
        out += q.front();
        if(i!=qsize-1)out+=" ";
        q.pop();
    }
    return out;
}
```





### L151. 实现strStr()

**题目**：给实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。



**思路1**：这是一道典型的KMP问题。

```C++
 int strStr(string haystack, string needle) {
        if(needle.empty())
            return 0;
        if(haystack.size()<needle.size() )
            return -1;
        vector<int> arr(needle.size());
        for(int i=1,j=0;i<needle.size();++i){
            while(j>0 && needle[i]!=needle[j])
                j = arr[j-1];//回溯
            if(needle[i]==needle[j])
                j++;
            arr[i]=j;
        }
        for(int i=0,j=0;i<haystack.size();++i){
            while(j>0 && haystack[i]!=needle[j])
                j=arr[j-1];
            if(haystack[i]==needle[j])
                j++;
            if(j==needle.size())
                return i-needle.size()+1;
        }
        
        return -1;
    }
```

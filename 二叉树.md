# 二叉树



## 基础知识



### 二叉树的种类

常用的二叉树：**满⼆叉树**和**完全⼆叉树**。

满⼆叉树：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层上，则这棵⼆叉树为满⼆叉树。

完全⼆叉树的定义如下：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h 层，则该层包含 1~ 2^h -1个节点。



**二叉搜索树**：⼆叉搜索树是⼀个有序树。

若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值； 

若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值； 

它的左、右⼦树也分别为⼆叉排序树



**平衡⼆叉搜索树**：⼜被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。



C++中map、set、multimap，multiset的底层实现都是平衡⼆叉搜索树（红黑树），所以map、set的增删操作时间时间复杂度是logn，unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。



⼆叉树可以链式存储，也可以顺序存储。

⼆叉树节点的深度：指从根节点到该节点的最⻓简单路径边的条数。 

⼆叉树节点的⾼度：指从该节点到叶⼦节点的最⻓简单路径边的条数。



### 二叉树的相关计算

#### 完全二叉树

当$0 \leq i < h$时，第$i$层包含$2^i$个节点。

最底层包含的节点数至少为1，最多为$2^h$次方个节点。

当最底层包含1个节点时，完全二叉树的节点个数为：$\sum_{i=0}^{h-1} 2^{i} + 1 = 2^h $

当最底层包含$2^h$个节点时，完全二叉树的节点个数是：$\sum_{i=0}^{h} 2^{i} = 2^{h-1} -1$





### 二叉树的遍历方式

⼆叉树主要有两种遍历⽅式：
1. 深度优先遍历：先往深⾛，遇到叶⼦节点再往回⾛。
2. ⼴度优先遍历：⼀层⼀层的去遍历。



那么从深度优先遍历和⼴度优先遍历进⼀步拓展，才有如下遍历⽅式：
**深度优先遍历**：
前序遍历（递归法，迭代法）
中序遍历（递归法，迭代法）
后序遍历（递归法，迭代法）
**⼴度优先遍历**：
层次遍历（迭代法）



**递归**

递归的三步：

1. 确定递归函数的参数和返回值：
确定哪些参数是递归的过程中需要处理的，那么就在递归函数⾥加上这个参数， 并且还要明确每次递归的返回值是什么进⽽确定递归函数的返回类型。

2. 确定终⽌条件：
写完了递归算法, 运⾏的时候，经常会遇到栈溢出的错误，就是没写终⽌条件或者终⽌条件写的不对，操作系统也是⽤⼀个栈的结构来保存每⼀层递归的信息，如果递归没有终⽌，操作系统的内存栈必然就会溢出。
3. 确定单层递归的逻辑：
确定每⼀层递归需要处理的信息。在这⾥也就会᯿复调⽤⾃⼰来实现递归的过程。



### 前序遍历

**递归方式**：

```C++
 void traversal(TreeNode* cur, vector<int>& vec) {
     if (cur == NULL) return;
     vec.push_back(cur->val); // 中
     traversal(cur->left, vec); // 左
     traversal(cur->right, vec); // 右
 }
 vector<int> preorderTraversal(TreeNode* root) {
     vector<int> result;
     traversal(root, result);
     return result;
 }
```



**迭代方式**：

```C++
vector<int> preorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> result;
    if (!root) return result;
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top(); // 中
        st.pop();
        result.push_back(node->val);
        if (node->right) st.push(node->right); // 右（空节点不⼊栈）
        if (node->left) st.push(node->left); // 左（空节点不⼊栈）
    }
    return result;
 }
```

或

```C++
vector<int> preorderTraversal(TreeNode* root) {
    if(root==nullptr) return vector<int>();
    stack<TreeNode*> s;
    vector<int> output;
    auto node=root;
    while(node || !s.empty()){
        while(node){
            output.push_back(node->val);
            s.push(node);
            node = node->left;
        }
        if(!s.empty()){
            node = s.top();
            s.pop();
            node=node->right;
        }
    }
    return output;
}
```





### 中序遍历

**递归方式**：

```C++
void traversal(TreeNode* cur, vector<int>& vec) {
     if (cur == NULL) return;
     traversal(cur->left, vec); // 左
     vec.push_back(cur->val); // 中
     traversal(cur->right, vec); // 右 
}
```

**迭代方式**：

```C++
 vector<int> inorderTraversal(TreeNode* root) {
     vector<int> result;
     stack<TreeNode*> st;
     TreeNode* cur = root;
     while (cur || !st.empty()) {
         if (cur) { // 指针来访问节点，访问到最底层
         	st.push(cur); // 将访问的节点放进栈
         	cur = cur->left; // 左
         } 
         else {
         	cur = st.top(); // 从栈⾥弹出的数据，就是要处理的数据（放进result数组⾥的数据）
	        st.pop();
         	result.push_back(cur->val); // 中
         	cur = cur->right; // 右
         }
     }
     return result;
 }
```

另一种方式：

```C++
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode *> s;
    TreeNode *node = root;
    while (node || !s.empty()){
        while (node){
            s.push(node);//保存一路走过的根节点
            node = node->left;
        }
        if (!s.empty()){
            node = s.top();
            res.push_back(node->val);
            s.pop();
            node = node->right;
        }
    }
    return res;
}
```





### 后序遍历

**递归方式**：

```C++
void traversal(TreeNode* cur, vector<int>& vec) {
     if (cur == NULL) return;
     traversal(cur->left, vec); // 左
     traversal(cur->right, vec); // 右
     vec.push_back(cur->val); // 中 
}
```



**迭代方式**：

```C++
 vector<int> postorderTraversal(TreeNode* root) {
     stack<TreeNode*> st;
     vector<int> result;
     if (root == NULL) return result;
     st.push(root);
     while (!st.empty()) {
         TreeNode* node = st.top();
         st.pop();
         result.push_back(node->val);
         if (node->left) 
             st.push(node->left); // 相对于前序遍历，这更改⼀下⼊栈顺序 （空节点不⼊栈）
         if (node->right) 
             st.push(node->right); // 空节点不⼊栈
     }
     reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
     return result;
 }
```

或

```C++
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> output;
    if(!root)return output;
    stack<TreeNode*> stk;
    auto node = root;
    TreeNode *prev=nullptr;//记录上过访问的节点
    while(node || !stk.empty()){
        while(node){
            stk.emplace(node);
            node = node->left;
        }
        node = stk.top();
        stk.pop();
        if(!node->right || node->right == prev){
            output.push_back(node->val);
            prev = node;
            node = nullptr;
        }
        else{
            stk.push(node);
            node = node->right;
        }
    }
    return output;
}
```





### 层次遍历

​	层序遍历⼀个⼆叉树。就是从左到右⼀层⼀层的去遍历⼆叉树。需要借⽤⼀个辅助数据结构即队列来实现，队列先进先出，符合⼀层⼀层遍历的逻辑，⽽是⽤栈先进后出适合模拟深度优先遍历也就是递归的逻辑。⽽这种层序遍历⽅式就是图论中的⼴度优先遍历，只不过我们应⽤在⼆叉树上。

```C++
vector<vector<int>> levelOrder(TreeNode* root) {
    if(!root)
        return vector<vector<int>>();
    queue<TreeNode*> q;
    q.push(root);
    vector<vector<int>> arr;
    while(!q.empty()){
        int num = q.size();
        vector<int> level_vector;
        for(int i=0;i<num;++i){
            auto node = q.front();
            q.pop();
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
            level_vector.push_back(node->val);
        }
        arr.push_back(level_vector);
    }
    return arr;
}
```





## 基础遍历的题目



### L144. 二叉树的前序遍历

**题目**：给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**思路**：迭代法和递归法

解答：

```
vector<int> preorderTraversal(TreeNode* root) {
    if(root==nullptr) return vector<int>();
    stack<TreeNode*> s;
    vector<int> output;
    auto node=root;
    while(node || !s.empty()){
        while(node!=nullptr){
            output.push_back(node->val);
            s.push(node);
            node = node->left;
        }
        if(!s.empty()){
            node = s.top();
            s.pop();
            node=node->right;
        }
    }
    return output;
}
```





### L94. 二叉树的中序遍历

**题目**：给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**思路**：迭代法和递归法

解答：

```
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode *> s;
    TreeNode *node = root;
    while (node != nullptr || !s.empty()){
        while (node != nullptr){
            s.push(node);//保存一路走过的根节点
            node = node->left;
        }
        if (!s.empty()){
            node = s.top();
            res.push_back(node->val);
            s.pop();
            node = node->right;
        }
    }
    return res;
}
```

### L145. 二叉树的后序遍历

**题目**：给定一个二叉树，返回它的 *后序* 遍历。

**思路**：迭代法和递归法

解答：

```
void traversal(vector<int>& arr,TreeNode* node){
    if(!node){ 
        return;
    }
    else{
        traversal(arr,node->left);
        traversal(arr,node->right);
        arr.push_back(node->val);
    }
}

vector<int> postorderTraversal(TreeNode* root) {
    vector<int> arr;
    traversal(arr,root);
    return arr;
}
```

迭代法：通过定义一个prev指针，来判断当前是否已经递归完成了子树。

```
vector<int> postorderTraversal(TreeNode* root) {
        vector<int> output;
        if(!root)return output;
        stack<TreeNode*> stk;
        auto node = root;
        TreeNode *prev=nullptr;//记录上过访问的节点
        while(node || !stk.empty()){
            while(node){
                stk.emplace(node);
                node = node->left;
            }
            node = stk.top();
            stk.pop();
            if(!node->right || node->right == prev){
                output.push_back(node->val);
                prev = node;
                node = nullptr;
            }
            else{
                stk.push(node);
                node = node->right;
            }
        }
        return output;
    }
```





## 层序遍历的题目



### L102. 二叉树的层序遍历

**题目**：给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**思路1**：使用广度优先搜索，使用迭代法时，将节点和当前深度放入 队列中。这样就可以知道每个节点所在的层次。

**思路2**：使用广度优先搜索，使用迭代法时，同时拓展当前层的所有节点。如下：

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    if(!root)
        return vector<vector<int>>();
    queue<TreeNode*> q;
    q.push(root);
    vector<vector<int>> arr;
    while(!q.empty()){
        int num = q.size();
        vector<int> level_vector;
        for(int i=0;i<num;++i){
            auto node = q.front();
            q.pop();
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
            level_vector.push_back(node->val);
        }
        arr.push_back(level_vector);
    }
    return arr;
}
```



### L107. 二叉树的层序遍历 II

**题目**：给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）



**思路1**：自顶向下的层序遍历，最后再将得到的结果数组进行翻转。

```C++
vector<vector<int>> levelOrderBottom(TreeNode* root) {
    vector<vector<int>> output;
    if(!root) return output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        vector<int> level(size);
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            level[i] = node->val;
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
        }
        output.push_back(level);
    }
    std::reverse(output.begin(),output.end());
    return output;
}
```



### L199. 二叉树的右视图

**题目**：给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**思路1**：使用二叉树的层序遍历，每层只保存 最后一个值，即该层的最右边的节点。

**代码**：

```C++
vector<int> rightSideView(TreeNode* root) {
    vector<int> output;
    if(!root) return output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        for(int i =0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
            if(i==size-1){
                output.push_back(node->val);
            }
        }
    }
    return output;
}
```



**思路2**：深度优先搜索

我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。

```C++
vector<int> rightSideView(TreeNode* root) {
    unordered_map<int, int> rightmostValueAtDepth;
    int max_depth = -1;

    stack<TreeNode*> nodeStack;
    stack<int> depthStack;
    nodeStack.push(root);
    depthStack.push(0);

    while (!nodeStack.empty()) {
        TreeNode* node = nodeStack.top();nodeStack.pop();
        int depth = depthStack.top();depthStack.pop();
        if (node) {
            // 维护二叉树的最大深度
            max_depth = max(max_depth, depth);
            // 如果不存在对应深度的节点我们才插入
            if (rightmostValueAtDepth.find(depth) == rightmostValueAtDepth.end()) {
                rightmostValueAtDepth[depth] =  node -> val;
            }
            nodeStack.push(node -> left);
            nodeStack.push(node -> right);
            depthStack.push(depth + 1);
            depthStack.push(depth + 1);
        }
    }

    vector<int> rightView;
    for (int depth = 0; depth <= max_depth; ++depth) {
        rightView.push_back(rightmostValueAtDepth[depth]);
    }

    return rightView;
}

```





### L637. 二叉树的层平均值

**题目**：给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。



**思路1**：层序遍历。

代码：

```C++
vector<double> averageOfLevels(TreeNode* root) {
    vector<double> output;
    if(!root) return output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        double avg=0;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            avg+=node->val;
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
        }
        avg /= size;
        output.push_back(avg);
    }
    return output;
}
```



**思路2**：深度优先搜索。



### L429. N叉树的层次遍历

**题目**：给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。



**思路1**：层序遍历。

```C++
vector<vector<int>> levelOrder(Node* root) {
    vector<vector<int>> output;
    if(!root)return output;
    std::queue<Node*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        vector<int> level(size);
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            for(auto p:node->children) if(p) q.push(p);
            level[i] = node->val;
        }
        output.push_back(level);
    }
    return output;
}
```





### L515. 在每个树行中找最大值

**题目**：给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。



**思路1**：层序遍历。

```C++
vector<int> largestValues(TreeNode* root) {
    vector<int> output;
    if(!root) return output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        int level_max = INT_MIN;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(node->val > level_max) level_max = node->val;
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
        output.push_back(level_max);
    }
    return output;
}
```





### L116. 填充每个节点的下一个右侧节点

**题目**：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```C++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

​	填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。



**思路1**：层序遍历。时间复杂度O(n)，空间复杂度O(n)。

在遍历每一层时，设置一个last节点，使用该节点将上一个节点连接到下一个节点。将该层的最后一个节点置为NULL。

```C++
Node* connect(Node* root) {
    if(!root) return root;
    std::queue<Node*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        Node* level_last=nullptr;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(level_last)
                level_last->next = node;
            level_last = node;
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
        }
        level_last->next = NULL;
    }    
    return root;
}
```



**思路2**：使用已存在的next指针。

一棵树中，存在两种类型的 next 指针。

第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。

 第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。 第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。可以通过 next 指针访问同一层的所有节点，因此可以使用第 N 层的 next 指针，为第 N+1 层节点建立 next 指针。

算法：

```C++
Node* connect(Node* root) {
    if (root == nullptr) return root;
    Node* leftmost = root;// 从根节点开始
    while (leftmost->left != nullptr) {
        // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针
        Node* head = leftmost;
        while (head != nullptr) {
            head->left->next = head->right;// CONNECTION 1
            if (head->next != nullptr) // CONNECTION 2
                head->right->next = head->next->left;
            head = head->next;// 指针向后移动
        }
        leftmost = leftmost->left;// 去下一层的最左的节点
    }
    return root;
}

```











### L117. 填充每个节点的下一个右侧节点

**题目**：

给定一个二叉树

```C++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

​	填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**思路1**：同L116，层序遍历。



### L513. 找树左下角的值

**题目**：给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。

假设二叉树中至少有一个节点。



**思路1**：使用层序遍历，记录每层中第一个（最左边）的值，到最后一层时即为最底层、最左边的值。

```C++
int findBottomLeftValue(TreeNode* root) {
    if(!root) return 0;
    std::queue<TreeNode*> q;
    q.push(root);
    int bottom_left = 0;
    while(!q.empty()){
        int size = q.size();
        bottom_left = q.front()->val;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return bottom_left;
}
```



**思路2**：递归法。



## 二叉树的对称和翻转




### L226. 翻转二叉树

**题目**：给定一个二叉树，翻转一棵二叉树。

**思路1**：使用深度优先搜索。  对于每个节点，交换其左右孩子。

**递归**：

后序遍历。

```C++
TreeNode* invertTree(TreeNode* root) {
    if(!root)
        return root;
    invertTree(root->left);
    invertTree(root->right);
    std::swap(root->left,root->right);
    return root; 
}
```

**迭代**：

前序遍历

```C++
TreeNode* invertTree(TreeNode* root) {
     if (root == NULL) return root;
     stack<TreeNode*> st;
     st.push(root);
     while(!st.empty()) {
         TreeNode* node = st.top(); // 中
         st.pop();
         swap(node->left, node->right);
         if(node->right) st.push(node->right); // 右
         if(node->left) st.push(node->left); // 左
     }
     return root;
 }
```





**思路2**：使用广度优先搜索，迭代  
	对于每个从queue中取出的节点，交换其左右两节点。

```C++
TreeNode* invertTree1(TreeNode* root) {
    if(!root)
        return root;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        auto node = q.front();
        q.pop();
        auto tmp = node->left;
        node->left = node->right;
        node->right = tmp;
        if(node->left)q.push(node->left);
        if(node->right)q.push(node->right);
    }
    return root;
}
```





### L100. 相同的树

**题目**：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**思路1**：采用任意一种遍历方式，比较两棵树的相同节点即可。如前序遍历：

```C++
bool isSameTree(TreeNode* p, TreeNode* q) {
    while(true){
        if((p && !q) || (!p && q))
            return false;
        else if(!p && !q)
            return true;
        else if(p->val != q->val)
            return false;
        else{
            bool b = isSameTree(p->left,q->left);
            if(!b) return false;
            return isSameTree(p->right,q->right);
        }
    }
}
```







### L101. 对称二叉树

**题目**：给定一个二叉树，检查它是否是镜像对称的。

**思路1**：先层次遍历，再比较每层的数组是否对称。(比较麻烦)



**思路2**：广度优先搜索。

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值
- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。  

​	首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```
bool check(TreeNode *u, TreeNode *v) {
	queue <TreeNode*> q;
	q.push(u); 
	q.push(v);
	while (!q.empty()) {
		u = q.front(); q.pop();
		v = q.front(); q.pop();
		if (!u && !v) continue;
		if ((!u || !v) || (u->val != v->val)) 
			return false;
		q.push(u->left); 
		q.push(v->right);
		q.push(u->right); 
		q.push(v->left);
	}
	return true;
}

bool isSymmetric(TreeNode* root) {
	return check(root, root);
}
```



**思路3**：后序遍历

1. 确定递归函数的参数和返回值 

因为我们要⽐较的是根节点的两个⼦树是否是相互翻转的，进⽽判断这个树是不是对称树，所以要⽐较 的是两个树，参数⾃然也是左⼦树节点和右⼦树节点。

2. 确定终⽌条件
    要⽐较两个节点数值相不相同，⾸先要把两个节点为空的情况弄清楚！否则后⾯⽐较数值的时候就会操作空指针了。
    节点为空的情况有：（注意我们⽐较的其实不是左孩⼦和右孩⼦，所以如下我称之为左节点右节点）
    左节点为空，右节点不为空，不对称，return false
    左不为空，右为空，不对称 return false
    左右都为空，对称，返回true

  此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：
  左右都不为空，⽐较节点数值，不相同就return false

  注意上⾯最后⼀种情况，我没有使⽤else，⽽是elseif， 因为我们把以上情况都排除之后，剩下的就是
  左右节点都不为空，且数值相同的情况。

3. 确定单层递归的逻辑
    此时才进⼊单层递归的逻辑，单层递归的逻辑就是处理 右节点都不为空，且数值相同的情况。
    ⽐较⼆叉树外侧是否对称：传⼊的是左节点的左孩⼦，右节点的右孩⼦。
    ⽐较内测是否对称，传⼊左节点的右孩⼦，右节点的左孩⼦。
    如果左右都对称就返回true ，有⼀侧不对称就返回false 。

**递归法**：

```C++
 bool compare(TreeNode* left, TreeNode* right) {
     // ⾸先排除空节点的情况
     if (left == NULL && right != NULL) return false;
     else if (left != NULL && right == NULL) return false;
     else if (left == NULL && right == NULL) return true;
     // 排除了空节点，再排除数值不相同的情况
     else if (left->val != right->val) return false;
     // 此时就是：左右节点都不为空，且数值相同的情况
     // 此时才做递归，做下⼀层的判断
     bool outside = compare(left->left, right->right); // 左⼦树：左、 右⼦树：右
     bool inside = compare(left->right, right->left); // 左⼦树：右、 右⼦树：左
     bool isSame = outside && inside; // 左⼦树：中、 右⼦树：中 （逻辑处理）
     return isSame;
 }

 bool isSymmetric(TreeNode* root) {
	if (root == NULL) return true;
 	return compare(root->left, root->right);
 }
```



## 二叉树的深度和高度

### L104. 二叉树的最大深度

**题目**：给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

**思路1**：广度优先搜索或深度优先搜索，在将节点放入stack或queue时，同时放入深度。实现：

```C++
int maxDepth(TreeNode* root) {
        if(!root)
            return 0;
        int max_depth=0;
        stack<pair<TreeNode*,int>> stk;
        stk.push({root,1});
        while(!stk.empty()){
            auto [node,depth] = stk.top();
            stk.pop();
            if(node->left)stk.push({node->left,depth+1});
            if(node->right)stk.push({node->right,depth+1});
            if(depth>max_depth)
                max_depth=depth;
        }
        return max_depth;
    }
```

**思路2**：同L102



**思路3**：递归的方法。

```C++
int getDepth(TreeNode* node) {
     if (node == NULL) return 0;
     int leftDepth = getDepth(node->left); // 左
     int rightDepth = getDepth(node->right); // 右
     int depth = 1 + max(leftDepth, rightDepth); // 中
     return depth;
 }
 int maxDepth(TreeNode* root) {
 	return getDepth(root);
 }
```



### L559. N叉树的最大深度

**题目**：给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。



**思路1**：深度优先搜索，后序遍历。

代码：

```C++
int DFS(int level,Node* root){
    int max=level+1;
    if(root->children.empty())
        return max;
    for(auto e: root->children){
        if(!e)continue;
        int e_max = DFS(level+1,e);
        max = max < e_max?e_max:max;
    }
    return max;
}


int maxDepth(Node* root) {
    if(!root)
        return 0;
    return DFS(0,root);
}
```



**思路2**：层序遍历法。

在遍历每一层时，将层数++；

```C++
int maxDepth(Node* root) {
    if(!root) return 0;
    queue<Node*> q;
    q.push(root);
    int level_num=0;
    while(!q.empty()){
        int size = q.size();
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            for(auto e: node->children)
                if(e)
                    q.push(e);
        }
        level_num++;
    }
    return level_num;
}
```





### L111. 二叉树的最小深度

**题目**：给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

**思路1**：层序遍历法（或广度优先搜索）。

遇到的第一个无孩子的子节点时的深度，即为二叉树的最小深度。

```C++
int minDepth(TreeNode* root) {
    if(!root)return 0;
    std::queue<TreeNode*> q;
    q.push(root);
    int level_num =0;
    while(!q.empty()){
        int size = q.size();
        level_num ++ ;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(!node->left && !node->right)
                return level_num;
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return 0;
}
```



**思路2**：递归法（深度优先搜索）。

每个子树均返回其最小深度。

```C++
int minDepth(TreeNode *root) {
    if (root == nullptr)
        return 0;
    if (root->left == nullptr && root->right == nullptr) 
        return 1;
    int min_depth = INT_MAX;
    if (root->left != nullptr) 
        min_depth = min(minDepth(root->left), min_depth);
    if (root->right != nullptr) 
        min_depth = min(minDepth(root->right), min_depth);
    return min_depth + 1;
}
```



### L110. 平衡二叉树

**题目**：给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。



**分析**：

⼆叉树节点的深度：指从根节点到该节点的最⻓简单路径边的条数。 

⼆叉树节点的⾼度：指从该节点到叶⼦节点的最⻓简单路径边的条数。

LeetCode中根节点深度是1。

因为求深度可以从上到下去查 所以需要前序遍历（中左右），⽽⾼度只能从下到上去查，所以只能后序遍历（左右中）

**思路1**：递归。自底向上返回子树的高度，在每次递归时，当左右两个子树的高度差大于1时，则表明这不是一个平衡二叉树。

```C++
int GetDepth(TreeNode* root){
    if(!root) return 0;
    int left_height = GetDepth(root->left);
    int right_height = GetDepth(root->right);
    if(left_height==-1 || right_height==-1 || std::abs(left_height - right_height) > 1)
        return -1;
    else
        return std::max(left_height,right_height)+1;
}

bool isBalanced(TreeNode* root) {
    if(GetDepth(root)==-1)
        return false;
    else
        return true;
}
```



**思路2**：迭代





## 节点个数

### L222. 完全二叉树的节点个数

**题目**：给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h 个节点。

**思路1**：广度优先搜索

```C++
int countNodes(TreeNode* root) {
    int cnt = 0;
    if(!root) return cnt;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        auto node = q.front();
        q.pop();
        cnt++;
        if(node->left) q.push(node->left);
        if(node->right) q.push(node->right);
    }
    return cnt;
}
```



**思路2**：深度优先搜索。

```C++
int countNodes(TreeNode* root) {
    if(!root)
        return 0;
    if(!root->left && !root->right)
        return 1;
    int num=1;
    if(root->left)
        num += countNodes(root->left);
    if(root->right)
        num+=countNodes(root->right);
    return num;
}
```



**思路3**：







### L404. 左叶子之和

**题目**： 计算给定二叉树的所有左叶子之和。 



**思路1**：递归。递归到某个节点的左孩子为叶结点时，将该叶结点的值增加到总和中。

```C++
int sumOfLeftLeaves(TreeNode* root) {
    if(!root)
        return 0;
    int sum=0;
    if(root->left && !root->left->left && !root->left->right)
        sum+= root->left->val;
    sum += sumOfLeftLeaves(root->left);
    sum += sumOfLeftLeaves(root->right);
    return sum;
}
```



**思路2**：迭代法。前序、中序、后序遍历都可以。这里是中序遍历。

```C++
int sumOfLeftLeaves(TreeNode* root) {
    int sum=0;
    if(!root)
        return sum;
    stack<TreeNode*> stk;
    auto node = root;
    while(node || !stk.empty()){
        while(node){
            stk.push(node);
            node = node->left;
        }
        if(!stk.empty()){
            node = stk.top();
            stk.pop();
            if(node->left && !node->left->left &&!node->left->right)
                sum += node->left->val;
            node = node->right;

        }
    }
    return sum;
}
```









## 路径和



### L112. 路径总和

**题目**：给定一个二叉树，检查它是否是镜像对称的。给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，
这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。  
叶子节点 是指没有子节点的节点。

**思路1**：迭代  
使用 深度优先搜索 或 广度优先搜索。在queue或stack中，同时保存到当前节点的路径和。如stack<tuple<TreeNode*,int>>
```C++
bool hasPathSum1(TreeNode* root, int targetSum) {
    if(!root)
        return false;
    stack<tuple<TreeNode*,int>> stk;//int表示路径和
    stk.push({root,root->val});
    while(!stk.empty()){
        auto [node,ps] = stk.top();
        stk.pop();
        if(!node->left && !node->right && ps==targetSum)
            return true;
        if(node->right)stk.push({node->right,node->right->val + ps});
        if(node->left)stk.push({node->left,node->left->val + ps});
    }
    return false;
}
```

**思路2**：递归  
假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。
不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路
 径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。   

```C++
bool hasPathSum(TreeNode *root, int sum) {
    if (root == nullptr) {
        return false;
    }
    if (root->left == nullptr && root->right == nullptr) {
        return sum == root->val;
    }
    return hasPathSum(root->left, sum - root->val) ||
           hasPathSum(root->right, sum - root->val);
}
```





### L113. 路径总和 II

**题目**：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。



**思路1**：采用深度优先搜索的后序遍历。当遇到叶结点 且 路径和满足时，将stack内的所有节点的值保存到输出。

迭代法。

```C++
//获取栈内的元素值
vector<int> getStackElement(stack<TreeNode*> &stk){
    stack<TreeNode*> tmp;
    int size = stk.size();
    vector<int> v(size);
    for(int i=0;i<size;++i){
        tmp.push(stk.top());
        stk.pop();
    }
    for(int i=0;i<size;++i){
        v[i] = tmp.top()->val;
        stk.push(tmp.top());
        tmp.pop();
    }
    return v;
}

vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
    vector<vector<int>> output;
    //用深度优先搜索,后序遍历
    if(!root) return output;
    stack<TreeNode*> stk;
    auto node = root;
    TreeNode* prev = nullptr;
    int sum=0;
    while(node || !stk.empty()){
        while(node){
            sum += node->val;
            stk.push(node);
            node = node->left;
        }
        node = stk.top();
        stk.pop();
        sum -= node->val;
        if(!node->right || prev==node->right){
            if(!node->left && !node->right && node->val + sum == targetSum){
                vector<int> v = getStackElement(stk);
                v.push_back(node->val);
                output.push_back(v);
            }
            prev = node;
            node =nullptr;
        }
        else{
            sum += node->val;
            stk.push(node);
            node = node->right;
        }
    }
    return output;
}
```



**思路2**：递归法。

```C++
vector<vector<int>> ret;
vector<int> path;

void dfs(TreeNode* root, int targetSum) {
    if (root == nullptr) return;
    path.emplace_back(root->val);
    targetSum -= root->val;
    if (!root->left && !root->right && targetSum == 0) 
        ret.emplace_back(path);
    dfs(root->left, targetSum);
    dfs(root->right, targetSum);
    path.pop_back();
}

vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
    dfs(root, targetSum);
    return ret;
}
```







## 构造二叉树



### L106. 从中序和后序遍历序列构造二叉树

**题目**：根据一棵树的中序遍历与后序遍历构造二叉树。

注意:你可以假设树中没有重复的元素。

例如，给出

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```



**思路1**：已知后序遍历数组中的最后一个元素时该树的根节点，且中序遍历数组中根节点的左边是左子树，右边是右子树。则构造思路是：

* 第⼀步：如果数组⼤⼩为零的话，说明是空节点了。 

* 第⼆步：如果不为空，那么取后序数组最后⼀个元素作为根节点元素。 

* 第三步：找到后序数组最后⼀个元素在中序数组的位置，作为切割点 

* 第四步：切割中序数组，切成 中序左数组 和 中序右数组
* 第五步：切割后序数组，切成 后序左数组 和 后序右数组 

* 第六步：递归处理左区间和右区间

代码的思路是使用递归函数：

```C++
/**
inorder 中序左数组
inorder_begin 该子树的中序左数组
inorder_end 该子树的中序右数组
postorder后序左数组
postorder_begin 该子树的后序左数组
postorder_end 该子树的后序右数组
*/
TreeNode* traversal(vector<int>& inorder,int inorder_begin,int inorder_end,vector<int>& postorder,int postorder_begin,int postorder_end){
    //如果子数组为空，则返回
    if(postorder_begin == postorder_end)
        return nullptr;
    //取后序左数组的最后一个元素为该子树的根节点元素。
    int root_value = postorder[postorder_end-1];
    TreeNode *root=new TreeNode(root_value);
    //如果该子树是叶子节点
    if(postorder_end-postorder_begin==1)
        return root;
    //在该子树的中序数组中寻找根节点，作为分割点
    int delimiter; 
    for(delimiter=inorder_begin;delimiter<inorder_end;++delimiter){
        if(inorder[delimiter]==root_value)
            break;
    }
    //切割中序数组(左闭右开)
    int left_inorder_begin = inorder_begin;
    int left_inorder_end = delimiter;
    int right_inorder_begin = delimiter+1;
    int right_inorder_end = inorder_end;
    //切割后序数组
    int left_postorder_begin = postorder_begin;
    //(delimiter - inorder_begin)表示中序左子树的长度
    int left_postorder_end = postorder_begin + (delimiter - inorder_begin);
    int right_postorder_begin = postorder_begin + (delimiter -inorder_begin );
    int right_postorder_end = postorder_end -1;//由于最后一个元素被用掉了，因此这里要-1
    //递归
    root->left = traversal(inorder,left_inorder_begin,left_inorder_end,postorder,left_postorder_begin,left_postorder_end);
    root->right = traversal(inorder,right_inorder_begin,right_inorder_end,postorder,right_postorder_begin,right_postorder_end);
    return root;
}

TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    if(inorder.empty() || postorder.empty())
        return nullptr;
    return traversal(inorder,0,inorder.size(),postorder,0,postorder.size());

}
```





### L105. 从前序和中序遍历序列构造二叉树

**题目**：给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。

例子：

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```



**思路1**：已知前序遍历数组的第一个元素是该二叉树的根节点，则以该节点划分后序遍历的两个子树。递归。

* 第⼀步：如果数组⼤⼩为零的话，说明是空节点了。 

* 第⼆步：如果不为空，那么取前序数组第⼀个元素作为根节点元素。 

* 第三步：找到前序数组最后⼀个元素在 中序数组 的位置，作为切割点 

* 第四步：切割中序数组，切成 中序左数组 和 中序右数组
* 第五步：切割前序数组，切成 前序左数组 和 前序右数组 

* 第六步：递归处理左区间和右区间

```C++
TreeNode* traversal(vector<int>& preorder, int pre_start,int pre_end,
                    vector<int>& inorder, int in_start,int in_end){
    if(pre_start == pre_end){
        return nullptr;
    }
    int root_value = preorder[pre_start];
    //cout<<root_value<<endl;
    TreeNode* root = new TreeNode(root_value);
    if(pre_start-pre_end==1){
        return root;
    }
    int delimeter;
    for(int i=in_start;i<in_end;++i)if(inorder[i]==root_value)delimeter=i;
    int left_in_start = in_start;
    int left_in_end = delimeter;
    int right_in_start = delimeter+1;//这是因为delimeter这个元素已经作为根节点了
    int right_in_end = in_end;
    int left_pre_start = pre_start + 1;//这是因为前序数组的pre_start这个元素已经作为根节点了
    int left_pre_end = left_pre_start +  left_in_end-left_in_start;
    int right_pre_start = left_pre_end;
    int right_pre_end = right_pre_start+right_in_end-right_in_start;

    root->left = traversal(preorder,left_pre_start,left_pre_end,
                           inorder,left_in_start,left_in_end);
    root->right = traversal(preorder,right_pre_start,right_pre_end,
                            inorder,right_in_start,right_in_end);
    return root;
}


TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    if(preorder.empty() || inorder.empty()){
        return nullptr;
    }
    return traversal(preorder,0,preorder.size(),inorder,0,inorder.size());
}
```





### L654. 最大二叉树

**题目**：给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：

1.二叉树的根是数组 nums 中的最大元素。
2.左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
3.右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
返回有给定数组 nums 构建的 最大二叉树 。



**思路1**：递归。

在每轮递归中传入在数组中的起点和终点（开边界），在这个范围内寻找一个最大值作为该子树的根节点。

```C++
TreeNode* traversal(vector<int> &nums,int start,int end){
    if(start == end)
        return nullptr;
    if(end-start==1)
        return new TreeNode(nums[start]);
    int delimiter=start;
    int max=nums[start];
    for(int i=start;i<end;++i){
        if(nums[i]>max){
            max = nums[i];
            delimiter = i;
        }
    }
    auto root = new TreeNode(max);
    root->left = traversal(nums,start,delimiter);
    root->right = traversal(nums,delimiter+1,end);
    return root;
}

TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
    if(nums.empty()) return nullptr;
    return traversal(nums,0,nums.size());
}
```





### L617. 合并二叉树

**题目**：给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

注意: 合并必须从两个树的根节点开始。



**思路1**：递归。

递归参数为子树tree0和子树tree1。

当tree0和tree1均不存在时，返回nullptr。

当tree0不存在 且 tree1存在时，返回tree1。

当tree0存在 且 tree1不存在时，返回tree0。

当tree0存在 且 tree1存在时，进行左右子树的递归。

```C++
TreeNode* traversal(TreeNode* tree0,TreeNode* tree1){
    if(!tree0 && !tree1)
        return nullptr;
    else if(!tree0 && tree1) 
        return tree1;
    else if(tree0 && !tree1) 
        return tree0;
    else{
        tree0->val += tree1->val;
        tree0->left = traversal(tree0->left,tree1->left);
        tree0->right = traversal(tree0->right,tree1->right);
        return tree0;
    }
}

TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    return traversal(root1,root2);
}
```



**思路2**：迭代。

```C++
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
     if (!t1) return t2;
     if (!t2) return t1;
     queue<TreeNode*> que;
     que.push(t1);
     que.push(t2);
     while(!que.empty()) {
         TreeNode* node1 = que.front(); que.pop();
         TreeNode* node2 = que.front(); que.pop();
         node1->val += node2->val;// 此时两个节点⼀定不为空，val相加
         // 如果两棵树左节点都不为空，加⼊队列
         if (node1->left && node2->left) {
             que.push(node1->left);
             que.push(node2->left);
         }
         // 如果两棵树右节点都不为空，加⼊队列
         if (node1->right && node2->right ) {
             que.push(node1->right);
             que.push(node2->right);
         }
         // 当t1的左节点 为空 t2左节点不为空，就赋值过去
         if (!node1->left && node2->left ) 
         	node1->left = node2->left;
         // 当t1的右节点 为空 t2右节点不为空，就赋值过去
         if (!node1->right && node2->right) 
	         node1->right = node2->right;
     }
     return t1;
 }
```





## 二叉搜索树



### L700. 二叉搜索树中的搜索

**题目**：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。



**思路1**：迭代。

```C++
TreeNode* searchBST(TreeNode* root, int val) {
    auto node = root;
    while(node){
        if(node->val == val)
            return node;
        else if(val < node->val )
            node = node->left;
        else
            node = node->right;
    }
    return node;
}
```

**思路2**：递归。

```C++
TreeNode* searchBST(TreeNode* root, int val) {
     if (root == NULL || root->val == val) 
         return root;
     if (root->val > val) 
         return searchBST(root->left, val);
     if (root->val < val) 
         return searchBST(root->right, val);
     return NULL;
 }
```






### L701. 二叉搜索树中的插入操作

**题目**：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。  
注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。  

**思路1**：递归  



**思路2**: 迭代  
将val与每个节点的val进行比较，若val<node->val，则进入左节点，否则进入右节点。  当节点为空时，插入新的节点。

```C++
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        //迭代法
        TreeNode* node = new TreeNode(val);
        if(!root){
            root = node;
            return root;
        }

        auto p = root;
        while(p){
            if(val < p->val){
                if(!p->left){
                    p->left = node;
                    break;
                }
                p = p->left;
            }
            if(val > p->val){
                if(!p->right){
                    p->right = node;
                    break;
                }
                p = p->right;
            }
        }
        return root;
    }
```



### L98. 验证二叉搜索树

**题目**：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。  
有效二叉搜索树定义如下：  
节点的左子树只包含 小于 当前节点的数。  
节点的右子树只包含 大于 当前节点的数。  
所有左子树和右子树自身必须也是二叉搜索树。  
	
**思路1**：根据二叉搜索树的定义可知，其中序遍历是一个升序，因此可以通过比较当前节点和上一节点的值来判断是否时二叉搜索树。

```C++
bool isValidBST(TreeNode* root) {
    //采用中序遍历
    stack<TreeNode*> stk;
    auto p = root;
    TreeNode* prev=nullptr;
    while(p || !stk.empty()){
        while(p){
            stk.push(p);
            p=p->left;
        }
        if(!stk.empty()){
            p = stk.top();
            stk.pop();
            if(prev && prev->val >= p->val ){
                return false;
            }
            prev = p;
            p = p->right;
        }
    }
    return true;
}
```

**思路2**：用递归法，对于每次递归传入当前节点的范围，若不满足范围则不是二叉搜索树。





### L530. 二叉搜索树的最小绝对差

**题目**：给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。

差值是一个正数，其数值等于两值之差的绝对值。



**思路1**：先遍历整个二叉搜索树，将每个节点值放到数组中，然后对数组进行排序。最后遍历排序后的数组，得到最小绝对差。对二叉搜索树采用中序遍历时，得到的是一个有序数组，因此无需进行排序。

```C++
int getMinimumDifference(TreeNode* root) {
    if(!root) return 0;
    vector<int> nums;
    std::stack<TreeNode*> stk;
    auto node = root;
    while(node || !stk.empty()){
        while(node){
            stk.push(node);
            node = node->left;
        }
        if(!stk.empty()){
            node = stk.top();
            stk.pop();
            nums.push_back(node->val);
            node = node->right;
        }
    }
    int difference = INT_MAX;
    for(int i=1;i<nums.size();++i){
        if(int d = std::abs(nums[i]-nums[i-1]); d < difference)
            difference = d;
    }
    return difference;
}
```





### L501. 二叉搜索树中的众数

**题目**：给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树
例如：
给定 BST [1,null,2,2],



**思路1**：遍历整个二叉树，使用哈希表保存每个值的出现次数。遍历完成后，将哈希表的值转换到数组，并根据节点值的出现次数进行排序，选择前几个出现次数最高节点值作为输出值。

这种方法对所有的二叉树都有效。

```C++
vector<int> findMode(TreeNode* root) {
    vector<int> output;
    if(!root)return output;
    auto node = root;
    std::stack<TreeNode*> stk;
    std::unordered_map<int,int> d;
    while(node || !stk.empty()){
        while(node){
            stk.push(node);
            node = node->left;
        }
        if(!stk.empty()){
            node = stk.top();
            stk.pop();
            if(d.find(node->val)==d.end())
                d.insert({node->val,1});
            else
                d[node->val]++;
            node = node->right;
        }
    }
    vector<pair<int,int>> arr(d.begin(),d.end());
    std::sort(arr.begin(),arr.end(),[](pair<int,int> a,pair<int,int> b){
        return a.second > b.second;
    });
    output.push_back(arr[0].first);
    int max_cnt = arr[0].second;
    for(int i=1;i<arr.size();++i){
        if(arr[i].second == max_cnt)
            output.push_back(arr[i].first);
        else
            break;
    }
    return output;
}
```



**思路2**：利用中序遍历的有序性，只遍历一次二叉树。

既然是搜索树，它中序遍历就是有序的。遍历二叉树中元素出现频率，从头遍历，那么⼀定是相邻两个元素作⽐较，然后就把出现频率最⾼的元素输出就可以了。

弄⼀个指针指向前⼀个节点，这样每次cur（当前节点）才能和pre（前⼀个节点）作⽐较。
⽽且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是⽐较的第⼀个元素。

一种思路是先遍历⼀遍二叉树，找出最⼤频率（maxCount），然后再新遍历⼀遍数组把出现频率为maxCount的元素放进集合。（因为众数有多个）这种⽅式遍历了两遍数组。

如果 频率count 等于 maxCount（最⼤频率），当然要把这个元素加⼊到结果集中。频率count ⼤于 maxCount的时候，不仅要更新maxCount，⽽且要清空结果集，因为结果集之前的元素都失效了。

代码：

```C++
int maxCount; // 最⼤频率
int count; // 统计频率
TreeNode* pre;
vector<int> result;

void searchBST(TreeNode* cur) {
    if (!cur) return ;
    searchBST(cur->left); // 左
    // 中
    if (pre == NULL) // 第⼀个节点
        count = 1;
    else if (pre->val == cur->val)// 与前⼀个节点数值相同
        count++;
    else // 与前⼀个节点数值不同
        count = 1;
    pre = cur; // 更新上⼀个节点
    if (count == maxCount) // 如果和最⼤值相同，放进result中
        result.push_back(cur->val);
    if (count > maxCount) { // 如果计数⼤于最⼤值频率
        maxCount = count; // 更新最⼤频率
        result.clear(); // 清空result，之前result⾥的元素都失效了
        result.push_back(cur->val);
    }
    searchBST(cur->right); // 右
    return ;
}

vector<int> findMode(TreeNode* root) {
    count = 0;
    maxCount = 0;
    TreeNode* pre = NULL; // 记录前⼀个节点
    result.clear();
    searchBST(root);
    return result;
}
```









### L653. 两数之和 IV - 输入 BST

**题目**： 给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。  

**思路1**:采用中序遍历，将BST转换为升序数组。然后双指针遍历数组，判断是否存在两个值=k。

```C++
bool findTarget(TreeNode* root, int k) {
    //首先根据中序遍历，将BST转换为升序数组，然后从两边开始遍历
    if(!root)
        return false;
    vector<int> arr;
    stack<TreeNode*> stk;
    auto p = root;
    while(p || !stk.empty()){
        while(p){
            stk.push(p);
            p=p->left;
        }
        if(!stk.empty()){
            p = stk.top();
            stk.pop();
            arr.push_back(p->val);
            p = p->right;
        }
    }

    int n = arr.size();
    for(int i=0;i<n;++i){
        for(int j=n-1;j>i;--j){
            int v = arr[i]+arr[j];
            if(v == k)
                return true;
            if(v<k)
                break;
        }
    }

    return false;
}
```

**思路2**:遍历二叉树，将最简单的方法就是遍历整棵树，找出所有可能的组合，判断是否存在和为 k 的一对节点。现在在此基础上做一些改进。
如果存在两个元素之和为 k，即 x+y=k，并且已知 x 是树上一个节点的值，则只需判断树上是否存在一个值为 y 的节点，使得 y=k-x。  
 基于这种思想，在树的每个节点上遍历它的两棵子树（左子树和右子树），寻找另外一个匹配的数。在遍历过程中，将每个节点的值都放到一个 set 中。
对于每个值为 p 的节点，在 set中检查是否存在 k-p。如果存在，那么可以在该树上找到两个节点的和为 k；否则，将 p 放入到 set 中。
如果遍历完整棵树都没有找到一对节点和为 k，那么该树上不存在两个和为 k 的节点。  
	
	
	
### L235. 二叉搜索树的最近公共祖先

**题目**： 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。  
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”  
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

**思路1**:根据BST的性质，当(node->val >= p->val && node->val <= q->val) || (node->val <= p->val && node->val >= q->val)时，node是最近公共祖先。
```C++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    auto node = root;
    while(node){
        if((node->val >= p->val && node->val <= q->val) ||
           (node->val <= p->val && node->val >= q->val) )
            return node;
        else if(p->val < node->val && q->val < node->val)
            node = node->left;
        else
            node = node->right;
    }
    return node;
}
```



## 其它



### L236. 二叉树的最近公共祖先

**题目**：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”














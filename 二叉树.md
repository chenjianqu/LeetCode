# 二叉树



### L144. 二叉树的前序遍历

**题目**：给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**思路**：迭代法和递归法

解答：

```
    vector<int> preorderTraversal(TreeNode* root) {
        if(root==nullptr)
            return vector<int>();
        stack<TreeNode*> s;
        vector<int> output;
        auto node=root;
        while(node || !s.empty()){
            while(node!=nullptr){
                output.push_back(node->val);
                s.push(node);
                node = node->left;
            }
            if(!s.empty()){
                node = s.top();
                s.pop();
                node=node->right;
            }
        }

        return output;
    }
```





### L94. 二叉树的中序遍历

**题目**：给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**思路**：迭代法和递归法

解答：

```
   vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> s;
		TreeNode *node = root;
		while (node != nullptr || !s.empty())
		{
			while (node != nullptr)
			{
				s.push(node);//保存一路走过的根节点
				node = node->left;
			}
			if (!s.empty())
			{
				node = s.top();
				res.push_back(node->val);
				s.pop();
				node = node->right;
			}
		}
    return res;
    }
```

### L145. 二叉树的后序遍历

**题目**：给定一个二叉树，返回它的 *后序* 遍历。

**思路**：迭代法和递归法

解答：

```
    void traversal(vector<int>& arr,TreeNode* node){
        if(!node){
            return;
        }
        else{
            traversal(arr,node->left);
            traversal(arr,node->right);
            arr.push_back(node->val);
        }
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> arr;
        traversal(arr,root);
        return arr;
    }
```

迭代法：通过定义一个prev指针，来判断当前是否已经递归完成了子树。

```
vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }

        stack<TreeNode *> stk;
        TreeNode *prev = nullptr;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.emplace(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            if (root->right == nullptr || root->right == prev) {
                res.emplace_back(root->val);
                prev = root;
                root = nullptr;
            } else {
                stk.emplace(root);
                root = root->right;
            }
        }
        return res;
    }
```





### L102. 二叉树的层序遍历

**题目**：给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**思路1**：使用广度优先搜索，使用迭代法时，将节点和当前深度放入 队列中。这样就可以知道每个节点所在的层次。

**思路2**：使用广度优先搜索，使用迭代法时，同时拓展当前层的所有节点。如下：

```c++
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(!root)
            return vector<vector<int>>();
        queue<TreeNode*> q;
        q.push(root);
        vector<vector<int>> arr;
        while(!q.empty()){
            int num = q.size();
            vector<int> level_vector;
            for(int i=0;i<num;++i){
                auto node = q.front();
                q.pop();
                if(node->left)q.push(node->left);
                if(node->right)q.push(node->right);
                level_vector.push_back(node->val);
            }
            arr.push_back(level_vector);
        }
        return arr;
    }
```





### L104. 二叉树的最大深度

**题目**：给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

**思路1**：广度优先搜索或深度优先搜索，在将节点放入stack或queue时，同时放入深度。实现：

```C++
int maxDepth(TreeNode* root) {
        if(!root)
            return 0;
        int max_depth=0;
        stack<pair<TreeNode*,int>> stk;
        stk.push({root,1});
        while(!stk.empty()){
            auto [node,depth] = stk.top();
            stk.pop();
            if(node->left)stk.push({node->left,depth+1});
            if(node->right)stk.push({node->right,depth+1});
            if(depth>max_depth)
                max_depth=depth;
        }
        return max_depth;
    }
```

**思路2**：同L102





### L101. 对称二叉树

**题目**：给定一个二叉树，检查它是否是镜像对称的。

**思路1**：先层次遍历，再比较每层的数组是否对称。(比较麻烦)



**思路2**：如果一个树的左子树与右子树镜像对称，那么这个树是对称的。如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值
- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，ppp 指针和 qqq 指针一开始都指向这棵树的根，随后 ppp 右移时，qqq 左移，ppp 左移时，qqq 右移。每次检查当前 ppp 和 qqq 节点的值是否相等，如果相等再判断左右子树是否对称。  

首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```
    bool check(TreeNode *u, TreeNode *v) {
        queue <TreeNode*> q;
        q.push(u); q.push(v);
        while (!q.empty()) {
            u = q.front(); q.pop();
            v = q.front(); q.pop();
            if (!u && !v) continue;
            if ((!u || !v) || (u->val != v->val)) return false;

            q.push(u->left); 
            q.push(v->right);

            q.push(u->right); 
            q.push(v->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};
```




### L226. 翻转二叉树

**题目**：给定一个二叉树，翻转一棵二叉树。

**思路1**：递归。  
 在后序时，交换其左右节点
```C++
TreeNode* invertTree(TreeNode* root) {
    if(!root)
        return root;
    invertTree(root->left);
    invertTree(root->right);
    auto tmp = root->left;
    root->left = root->right;
    root->right = tmp;
    return root;
}
```


**思路2**：迭代  
使用广度优先搜索，对于每个从queue中取出的节点，交换其左右两节点。
```C++
TreeNode* invertTree1(TreeNode* root) {
    if(!root)
        return root;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        auto node = q.front();
        q.pop();
        auto tmp = node->left;
        node->left = node->right;
        node->right = tmp;
        if(node->left)q.push(node->left);
        if(node->right)q.push(node->right);
    }
    return root;
}
```




### L112. 路径总和

**题目**：给定一个二叉树，检查它是否是镜像对称的。给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，
这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。  
叶子节点 是指没有子节点的节点。

**思路1**：迭代  
使用 深度优先搜索 或 广度优先搜索。在queue或stack中，同时保存到当前节点的路径和。如stack<tuple<TreeNode*,int>>
```C++
bool hasPathSum1(TreeNode* root, int targetSum) {
    if(!root)
        return false;
    stack<tuple<TreeNode*,int>> stk;//int表示路径和
    stk.push({root,root->val});
    while(!stk.empty()){
        auto [node,ps] = stk.top();
        stk.pop();
        if(!node->left && !node->right && ps==targetSum)
            return true;
        if(node->right)stk.push({node->right,node->right->val + ps});
        if(node->left)stk.push({node->left,node->left->val + ps});
    }
    return false;
}
```

**思路2**：递归  
假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。
不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路
 径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。   
```C++
bool hasPathSum(TreeNode *root, int sum) {
    if (root == nullptr) {
        return false;
    }
    if (root->left == nullptr && root->right == nullptr) {
        return sum == root->val;
    }
    return hasPathSum(root->left, sum - root->val) ||
           hasPathSum(root->right, sum - root->val);
}
```




### L701. 二叉搜索树中的插入操作

**题目**：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。  
注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。  

**思路1**：递归  



**思路2**: 迭代  
将val与每个节点的val进行比较，若val<node->val，则进入左节点，否则进入右节点。  当节点为空时，插入新的节点。
```C++
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        //迭代法
        TreeNode* node = new TreeNode(val);
        if(!root){
            root = node;
            return root;
        }

        auto p = root;
        while(p){
            if(val < p->val){
                if(!p->left){
                    p->left = node;
                    break;
                }
                p = p->left;
            }
            if(val > p->val){
                if(!p->right){
                    p->right = node;
                    break;
                }
                p = p->right;
            }
        }
        return root;
    }
```



### L98. 验证二叉搜索树

**题目**：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。  
有效二叉搜索树定义如下：  
节点的左子树只包含 小于 当前节点的数。  
节点的右子树只包含 大于 当前节点的数。  
所有左子树和右子树自身必须也是二叉搜索树。  
	
**思路1**：根据二叉搜索树的定义可知，其中序遍历是一个升序，因此可以通过比较当前节点和上一节点的值来判断是否时二叉搜索树。
```C++
bool isValidBST(TreeNode* root) {
    //采用中序遍历
    stack<TreeNode*> stk;
    auto p = root;
    TreeNode* prev=nullptr;
    while(p || !stk.empty()){
        while(p){
            stk.push(p);
            p=p->left;
        }
        if(!stk.empty()){
            p = stk.top();
            stk.pop();
            if(prev && prev->val >= p->val ){
                return false;
            }
            prev = p;
            p = p->right;
        }
    }
    return true;
}
```

**思路2**：用递归法，对于每次递归传入当前节点的范围，若不满足范围则不是二叉搜索树。


​	
### L653. 两数之和 IV - 输入 BST

**题目**： 给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。  

**思路1**:采用中序遍历，将BST转换为升序数组。然后双指针遍历数组，判断是否存在两个值=k。
```C++
bool findTarget(TreeNode* root, int k) {
    //首先根据中序遍历，将BST转换为升序数组，然后从两边开始遍历
    if(!root)
        return false;
    vector<int> arr;
    stack<TreeNode*> stk;
    auto p = root;
    while(p || !stk.empty()){
        while(p){
            stk.push(p);
            p=p->left;
        }
        if(!stk.empty()){
            p = stk.top();
            stk.pop();
            arr.push_back(p->val);
            p = p->right;
        }
    }

    int n = arr.size();
    for(int i=0;i<n;++i){
        for(int j=n-1;j>i;--j){
            int v = arr[i]+arr[j];
            if(v == k)
                return true;
            if(v<k)
                break;
        }
    }

    return false;
}
```

**思路2**:遍历二叉树，将最简单的方法就是遍历整棵树，找出所有可能的组合，判断是否存在和为 k 的一对节点。现在在此基础上做一些改进。
如果存在两个元素之和为 k，即 x+y=k，并且已知 x 是树上一个节点的值，则只需判断树上是否存在一个值为 y 的节点，使得 y=k-x。  
 基于这种思想，在树的每个节点上遍历它的两棵子树（左子树和右子树），寻找另外一个匹配的数。在遍历过程中，将每个节点的值都放到一个 set 中。
对于每个值为 p 的节点，在 set中检查是否存在 k-p。如果存在，那么可以在该树上找到两个节点的和为 k；否则，将 p 放入到 set 中。
如果遍历完整棵树都没有找到一对节点和为 k，那么该树上不存在两个和为 k 的节点。  
	
	
	
### L235. 二叉搜索树的最近公共祖先

**题目**： 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。  
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”  
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

**思路1**:根据BST的性质，当(node->val >= p->val && node->val <= q->val) || (node->val <= p->val && node->val >= q->val)时，node是最近公共祖先。
```C++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    auto node = root;
    while(node){
        if((node->val >= p->val && node->val <= q->val) ||
           (node->val <= p->val && node->val >= q->val)
                ){
            return node;
        }
        else if(p->val < node->val && q->val < node->val){
            node = node->left;
        }
        else{
            node = node->right;
        }
    }
    return node;
}
```
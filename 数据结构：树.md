# 二叉树



## 基础知识



### 二叉树的种类

#### **满二叉树**和**完全二叉树**。

满二叉树：如果⼀棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层上，则这棵二叉树为满二叉树。

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h 层，则该层包含 1~ 2^h -1个节点。



#### **二叉搜索树**

二叉搜索树是⼀个有序树。

若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 

若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 

它的左、右子树也分别为二叉排序树



#### **平衡二叉搜索树**

⼜被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是⼀棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是⼀棵平衡二叉树。



### STL的实现

C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树（红黑树），所以map、set的增删操作时间时间复杂度是logn，unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。



二叉树可以链式存储，也可以顺序存储。

二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。 

二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。



### 二叉树的相关计算

#### 完全二叉树

当$0 \leq i < h$时，第$i$层包含$2^i$个节点。

最底层包含的节点数至少为1，最多为$2^h$次方个节点。

当最底层包含1个节点时，完全二叉树的节点个数为：$\sum_{i=0}^{h-1} 2^{i} + 1 = 2^h $

当最底层包含$2^h$个节点时，完全二叉树的节点个数是：$\sum_{i=0}^{h} 2^{i} = 2^{h-1} -1$





### 二叉树的遍历方式

二叉树主要有两种遍历⽅式：
1. 深度优先遍历：先往深⾛，遇到叶子节点再往回⾛。
2. 广度优先遍历：⼀层⼀层的去遍历。



那么从深度优先遍历和广度优先遍历进⼀步拓展，才有如下遍历⽅式：
**深度优先遍历**：
前序遍历（递归法，迭代法）
中序遍历（递归法，迭代法）
后序遍历（递归法，迭代法）
**广度优先遍历**：
层次遍历（迭代法）



**递归**

递归的三步：

1. 确定递归函数的参数和返回值：
确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

2. 确定终止条件：
写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用⼀个栈的结构来保存每⼀层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. 确定单层递归的逻辑：
确定每⼀层递归需要处理的信息。在这里也就会反复调用自己来实现递归的过程。



### 前序遍历

**递归方式**：

```C++
 void traversal(TreeNode* cur, vector<int>& vec) {
     if (cur == NULL) return;
     vec.push_back(cur->val); // 中
     traversal(cur->left, vec); // 左
     traversal(cur->right, vec); // 右
 }
 vector<int> preorderTraversal(TreeNode* root) {
     vector<int> result;
     traversal(root, result);
     return result;
 }
```



**迭代方式**：

```C++
vector<int> preorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> result;
    if (!root) return result;
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top(); // 中
        st.pop();
        result.push_back(node->val);
        if (node->right) st.push(node->right); // 右（空节点不入栈）
        if (node->left) st.push(node->left); // 左（空节点不入栈）
    }
    return result;
 }
```

或

```C++
vector<int> preorderTraversal(TreeNode* root) {
    if(root==nullptr) 
        return vector<int>();
    stack<TreeNode*> s;
    vector<int> output;
    auto node=root;
    while(node || !s.empty()){
        while(node){
            output.push_back(node->val);
            s.push(node);
            node = node->left;
        }
        if(!s.empty()){
            node = s.top();
            s.pop();
            node=node->right;
        }
    }
    return output;
}
```





### 中序遍历

**递归方式**：

```C++
void traversal(TreeNode* cur, vector<int>& vec) {
     if (cur == NULL) return;
     traversal(cur->left, vec); // 左
     vec.push_back(cur->val); // 中
     traversal(cur->right, vec); // 右 
}
```

**迭代方式**：

```C++
 vector<int> inorderTraversal(TreeNode* root) {
     vector<int> result;
     stack<TreeNode*> st;
     TreeNode* cur = root;
     while (cur || !st.empty()) {
         if (cur) { // 指针来访问节点，访问到最底层
         	st.push(cur); // 将访问的节点放进栈
         	cur = cur->left; // 左
         } 
         else {
         	cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
	        st.pop();
         	result.push_back(cur->val); // 中
         	cur = cur->right; // 右
         }
     }
     return result;
 }
```

另一种方式：

```C++
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode *> s;
    TreeNode *node = root;
    while (node || !s.empty()){
        while (node){
            s.push(node);//保存一路走过的根节点
            node = node->left;
        }
        if (!s.empty()){
            node = s.top();
            res.push_back(node->val);
            s.pop();
            node = node->right;
        }
    }
    return res;
}
```





### 后序遍历

**递归方式**：

```C++
void traversal(TreeNode* cur, vector<int>& vec) {
     if (cur == NULL) return;
     traversal(cur->left, vec); // 左
     traversal(cur->right, vec); // 右
     vec.push_back(cur->val); // 中 
}
```



**迭代方式**：

```C++
 vector<int> postorderTraversal(TreeNode* root) {
     stack<TreeNode*> st;
     vector<int> result;
     if (root == NULL) return result;
     st.push(root);
     while (!st.empty()) {
         TreeNode* node = st.top();
         st.pop();
         result.push_back(node->val);
         if (node->left) 
             st.push(node->left); // 相对于前序遍历，这更改⼀下入栈顺序 （空节点不入栈）
         if (node->right) 
             st.push(node->right); // 空节点不入栈
     }
     reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
     return result;
 }
```

或

```C++
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> output;
    if(!root)return output;
    stack<TreeNode*> stk;
    auto node = root;
    TreeNode *prev=nullptr;//记录上过访问的节点
    while(node || !stk.empty()){
        while(node){
            stk.emplace(node);
            node = node->left;
        }
        node = stk.top();
        stk.pop();
        if(!node->right || node->right == prev){
            output.push_back(node->val);
            prev = node;
            node = nullptr;
        }
        else{
            stk.push(node);
            node = node->right;
        }
    }
    return output;
}
```





### 层次遍历

​	层序遍历⼀个二叉树。就是从左到右⼀层⼀层的去遍历二叉树。需要借用⼀个辅助数据结构即队列来实现，队列先进先出，符合⼀层⼀层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历⽅式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

```C++
vector<vector<int>> levelOrder(TreeNode* root) {
    if(!root)
        return vector<vector<int>>();
    queue<TreeNode*> q;
    q.push(root);
    vector<vector<int>> arr;
    while(!q.empty()){
        int num = q.size();
        vector<int> level_vector;
        for(int i=0;i<num;++i){
            auto node = q.front();
            q.pop();
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
            level_vector.push_back(node->val);
        }
        arr.push_back(level_vector);
    }
    return arr;
}
```





## 基础遍历的题目



### L144. 二叉树的前序遍历

**题目**：给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**思路**：迭代法和递归法

解答：

```
vector<int> preorderTraversal(TreeNode* root) {
    if(root==nullptr) return vector<int>();
    stack<TreeNode*> s;
    vector<int> output;
    auto node=root;
    while(node || !s.empty()){
        while(node!=nullptr){
            output.push_back(node->val);
            s.push(node);
            node = node->left;
        }
        if(!s.empty()){
            node = s.top();
            s.pop();
            node=node->right;
        }
    }
    return output;
}
```





### L94. 二叉树的中序遍历

**题目**：给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**思路**：迭代法和递归法

解答：

```
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode *> s;
    TreeNode *node = root;
    while (node != nullptr || !s.empty()){
        while (node != nullptr){
            s.push(node);//保存一路走过的根节点
            node = node->left;
        }
        if (!s.empty()){
            node = s.top();
            res.push_back(node->val);
            s.pop();
            node = node->right;
        }
    }
    return res;
}
```

### L145. 二叉树的后序遍历

**题目**：给定一个二叉树，返回它的 *后序* 遍历。

**思路**：迭代法和递归法

解答：

```
void traversal(vector<int>& arr,TreeNode* node){
    if(!node){ 
        return;
    }
    else{
        traversal(arr,node->left);
        traversal(arr,node->right);
        arr.push_back(node->val);
    }
}

vector<int> postorderTraversal(TreeNode* root) {
    vector<int> arr;
    traversal(arr,root);
    return arr;
}
```

迭代法：通过定义一个prev指针，来判断当前是否已经递归完成了子树。

```C++
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> output;
    if(!root)return output;
    stack<TreeNode*> stk;
    auto node = root;
    TreeNode *prev=nullptr;//记录上过访问的节点
    while(node || !stk.empty()){
        while(node){
            stk.emplace(node);
            node = node->left;
        }
        node = stk.top();
        stk.pop();
        if(!node->right || node->right == prev){
            output.push_back(node->val);
            prev = node;
            node = nullptr;
        }
        else{
            stk.push(node);
            node = node->right;
        }
    }
    return output;
}
```



### L965. 单值二叉树

**[题目](https://leetcode-cn.com/problems/univalued-binary-tree/)**: 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。

只有给定的树是单值二叉树时，才返回 true；否则返回 false。

 ```
示例 1：
输入：[1,1,1,1,1,null,1]
输出：true

示例 2：
输入：[2,2,2,5,2]
输出：false
 ```


提示：

给定树的节点数范围是 [1, 100]。
每个节点的值都是整数，范围为 [0, 99] 。



**思路1**：深度优先搜索。

```C++
bool isUnivalTree(TreeNode* root) {
    if(!root)return true;
    if(root->left && root->left->val!=root->val) return false;
    if(root->right && root->right->val!=root->val) return false;
    return isUnivalTree(root->left) && isUnivalTree(root->right);
}
```



**思路2**：广度优先搜索。





### J32-I. 从上到下打印二叉树

**[题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)**：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
```
例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回：

[3,9,20,15,7]
```
提示：
节点总数 <= 1000



**思路1**：广度优先搜索。

```C++
vector<int> levelOrder(TreeNode* root) {
    if(!root) return {};
    vector<int> output;
    std::queue<TreeNode*> que;
    que.push(root);
    while(!que.empty()){
        auto node= que.front();
        que.pop();
        output.push_back(node->val);
        if(node->left) que.push(node->left);
        if(node->right) que.push(node->right);
    }
    return output;
}
```





### L257. 二叉树的所有路径

[题目](https://leetcode-cn.com/problems/binary-tree-paths/)：给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

 **提示：**

- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`



**思路1**：深度优先搜索。

最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。

如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。
如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。
如此，当遍历完整棵二叉树以后我们就得到了所有从根节点到叶子节点的路径。

```C++
class Solution {
private:
    vector<string> ans;
    string path;
    void dfs(TreeNode* root){
        if(!root)
            return;
        if(!(root->left) && !(root->right)){
            ans.push_back(path + to_string(root->val));
            return;
        }
        string tmp=path;
        path += to_string(root->val) + "->";
        dfs(root->left);
        dfs(root->right);
        path=tmp;
    }
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        dfs(root);
        return ans;
    }
};
```



思路2：**广度优先搜索**

我们也可以用广度优先搜索来实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是叶子节点，则将它对应的路径加入到答案中。如果它不是叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时广度优先搜索结束，我们即能得到答案。

```C++
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> paths;
        if (root == nullptr) {
            return paths;
        }
        queue<TreeNode*> node_queue;
        queue<string> path_queue;

        node_queue.push(root);
        path_queue.push(to_string(root->val));

        while (!node_queue.empty()) {
            TreeNode* node = node_queue.front(); 
            string path = path_queue.front();
            node_queue.pop();
            path_queue.pop();

            if (node->left == nullptr && node->right == nullptr) {
                paths.push_back(path);
            } else {
                if (node->left != nullptr) {
                    node_queue.push(node->left);
                    path_queue.push(path + "->" + to_string(node->left->val));
                }

                if (node->right != nullptr) {
                    node_queue.push(node->right);
                    path_queue.push(path + "->" + to_string(node->right->val));
                }
            }
        }
        return paths;
    }
};
```







## 层序遍历的题目



### L102. 二叉树的层序遍历

**题目**：给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**思路1**：使用广度优先搜索，使用迭代法时，将节点和当前深度放入 队列中。这样就可以知道每个节点所在的层次。

**思路2**：使用广度优先搜索，使用迭代法时，同时拓展当前层的所有节点。如下：

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    if(!root) return {};
    queue<TreeNode*> q;
    q.push(root);
    vector<vector<int>> arr;
    while(!q.empty()){
        int num = q.size();
        vector<int> level;
        for(int i=0;i<num;++i){
            auto node = q.front();
            q.pop();
            level.push_back(node->val);
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
        }
        arr.push_back(level);
    }
    return arr;
}
```





### L107. 二叉树的层序遍历 II

**题目**：给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）



**思路1**：自顶向下的层序遍历，最后再将得到的结果数组进行翻转。

```C++
vector<vector<int>> levelOrderBottom(TreeNode* root) {
    vector<vector<int>> output;
    if(!root) return output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        vector<int> level(size);
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            level[i] = node->val;
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
        }
        output.push_back(level);
    }
    std::reverse(output.begin(),output.end());
    return output;
}
```





### J32-II. 从上到下打印二叉树 II

**[题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)**:  同L102





### J32-III. 从上到下打印二叉树 III

**[题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)**:  请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

```
例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [20,9],
  [15,7]
]
```
提示：
节点总数 <= 1000



**思路1**：层序遍历+倒序。

```C++
vector<vector<int>> levelOrder(TreeNode* root) {
    if(!root) return {};
    vector<vector<int>> output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size=q.size();
        vector<int> level(size);
        bool reverse= (output.size()%2)==1; //根据Output的层数，判断该层是否进行翻转
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(reverse)
                level[size-i-1]=node->val;
            else
                level[i]=node->val;
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
        output.push_back(level);
    }
    return output;
}
```



**思路2**：层序遍历+双端队列。

双端队列，即可以从头部或尾部插入元素的队列，这里使用C++中的deque。

```C++
vector<vector<int>> levelOrder(TreeNode* root) {
    if(!root) return {};
    vector<vector<int>> output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size=q.size();
        std::deque<int> level;
        bool reverse= (output.size()%2)==1; //根据Output的层数，判断该层是否进行翻转
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(reverse)
                level.push_front(node->val);
            else
                level.push_back(node->val);
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
        std::vector<int> level_vector(level.begin(),level.end());
        output.push_back(level_vector);
    }
    return output;
}
```






### L199. 二叉树的右视图

**题目**：给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**思路1**：使用二叉树的层序遍历，每层只保存 最后一个值，即该层的最右边的节点。

**代码**：

```C++
vector<int> rightSideView(TreeNode* root) {
    vector<int> output;
    if(!root) return output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        for(int i =0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
            if(i==size-1){
                output.push_back(node->val);
            }
        }
    }
    return output;
}
```



**思路2**：深度优先搜索

我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。

```C++
vector<int> rightSideView(TreeNode* root) {
    unordered_map<int, int> rightmostValueAtDepth;
    int max_depth = -1;

    stack<TreeNode*> nodeStack;
    stack<int> depthStack;
    nodeStack.push(root);
    depthStack.push(0);

    while (!nodeStack.empty()) {
        TreeNode* node = nodeStack.top();nodeStack.pop();
        int depth = depthStack.top();depthStack.pop();
        if (node) {
            // 维护二叉树的最大深度
            max_depth = max(max_depth, depth);
            // 如果不存在对应深度的节点我们才插入
            if (rightmostValueAtDepth.find(depth) == rightmostValueAtDepth.end()) {
                rightmostValueAtDepth[depth] =  node -> val;
            }
            nodeStack.push(node -> left);
            nodeStack.push(node -> right);
            depthStack.push(depth + 1);
            depthStack.push(depth + 1);
        }
    }

    vector<int> rightView;
    for (int depth = 0; depth <= max_depth; ++depth) {
        rightView.push_back(rightmostValueAtDepth[depth]);
    }

    return rightView;
}

```





### L637. 二叉树的层平均值

**题目**：给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。



**思路1**：层序遍历。

代码：

```C++
vector<double> averageOfLevels(TreeNode* root) {
    vector<double> output;
    if(!root) return output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        double avg=0;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            avg+=node->val;
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
        }
        avg /= size;
        output.push_back(avg);
    }
    return output;
}
```



**思路2**：深度优先搜索。







### L515. 在每个树行中找最大值

**题目**：给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。



**思路1**：层序遍历。

```C++
vector<int> largestValues(TreeNode* root) {
    vector<int> output;
    if(!root) return output;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        int level_max = INT_MIN;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(node->val > level_max) level_max = node->val;
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
        output.push_back(level_max);
    }
    return output;
}
```





### L116. 填充每个节点的下一个右侧节点

**题目**：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```C++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

​	填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。



**思路1**：层序遍历。时间复杂度O(n)，空间复杂度O(n)。

在遍历每一层时，设置一个last节点，使用该节点将上一个节点连接到下一个节点。将该层的最后一个节点置为NULL。

```C++
Node* connect(Node* root) {
    if(!root) return root;
    std::queue<Node*> q;
    q.push(root);
    while(!q.empty()){
        int size = q.size();
        Node* level_last=nullptr;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(level_last)
                level_last->next = node;
            level_last = node;
            if(node->left)q.push(node->left);
            if(node->right)q.push(node->right);
        }
        level_last->next = NULL;
    }    
    return root;
}
```



**思路2**：使用已存在的next指针。

一棵树中，存在两种类型的 next 指针。

第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。

 第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。 第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。可以通过 next 指针访问同一层的所有节点，因此可以使用第 N 层的 next 指针，为第 N+1 层节点建立 next 指针。

算法：

```C++
Node* connect(Node* root) {
    if (root == nullptr) return root;
    Node* leftmost = root;// 从根节点开始
    while (leftmost->left != nullptr) {
        // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针
        Node* head = leftmost;
        while (head != nullptr) {
            head->left->next = head->right;// CONNECTION 1
            if (head->next != nullptr) // CONNECTION 2
                head->right->next = head->next->left;
            head = head->next;// 指针向后移动
        }
        leftmost = leftmost->left;// 去下一层的最左的节点
    }
    return root;
}

```











### L117. 填充每个节点的下一个右侧节点

**题目**：

给定一个二叉树

```C++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

​	填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

**思路1**：同L116，层序遍历。



### L513. 找树左下角的值

**题目**：给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。

假设二叉树中至少有一个节点。



**思路1**：使用层序遍历，记录每层中第一个（最左边）的值，到最后一层时即为最底层、最左边的值。

```C++
int findBottomLeftValue(TreeNode* root) {
    if(!root) return 0;
    std::queue<TreeNode*> q;
    q.push(root);
    int bottom_left = 0;
    while(!q.empty()){
        int size = q.size();
        bottom_left = q.front()->val;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return bottom_left;
}
```



**思路2**：递归法。



## 二叉树的对称和翻转




### L226. 翻转二叉树

**题目**：给定一个二叉树，翻转一棵二叉树。

**思路1**：使用深度优先搜索。  对于每个节点，交换其左右孩子。

**递归**：

后序遍历。

```C++
TreeNode* invertTree(TreeNode* root) {
    if(!root)
        return root;
    invertTree(root->left);
    invertTree(root->right);
    std::swap(root->left,root->right);
    return root; 
}
```

**迭代**：

前序遍历

```C++
TreeNode* invertTree(TreeNode* root) {
     if (root == NULL) return root;
     stack<TreeNode*> st;
     st.push(root);
     while(!st.empty()) {
         TreeNode* node = st.top(); // 中
         st.pop();
         swap(node->left, node->right);
         if(node->right) st.push(node->right); // 右
         if(node->left) st.push(node->left); // 左
     }
     return root;
 }
```





**思路2**：使用广度优先搜索，迭代  
	对于每个从queue中取出的节点，交换其左右两节点。

```C++
TreeNode* invertTree1(TreeNode* root) {
    if(!root)
        return root;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        auto node = q.front();
        q.pop();
        auto tmp = node->left;
        node->left = node->right;
        node->right = tmp;
        if(node->left)q.push(node->left);
        if(node->right)q.push(node->right);
    }
    return root;
}
```



### J27. 二叉树的镜像

**[题目](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)**：同 L226



### L100. 相同的树

**题目**：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**思路1**：采用任意一种遍历方式，比较两棵树的相同节点即可。如前序遍历：

```C++
bool isSameTree(TreeNode* p, TreeNode* q) {
    while(true){
        if((p && !q) || (!p && q))
            return false;
        else if(!p && !q)
            return true;
        else if(p->val != q->val)
            return false;
        else{
            bool b = isSameTree(p->left,q->left);
            if(!b) return false;
            return isSameTree(p->right,q->right);
        }
    }
}
```





### L101. 对称二叉树 & J28. 对称的二叉树

**题目**：给定一个二叉树，检查它是否是镜像对称的。



**思路1**：先层次遍历，再比较每层的数组是否对称。(比较麻烦)



**思路2**：广度优先搜索。

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值
- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。  

​	首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```c++
bool check(TreeNode *u, TreeNode *v) {
	queue <TreeNode*> q;
	q.push(u); 
	q.push(v);
	while (!q.empty()) {
		u = q.front(); q.pop();
		v = q.front(); q.pop();
		if (!u && !v)
            continue;
		if ((!u || !v) || (u->val != v->val)) 
			return false;
		q.push(u->left); 
		q.push(v->right);
		q.push(u->right); 
		q.push(v->left);
	}
	return true;
}

bool isSymmetric(TreeNode* root) {
	return check(root, root);
}
```



**思路3**：后序遍历

1. 确定递归函数的参数和返回值 

因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较 的是两个树，参数自然也是左子树节点和右子树节点。

2. 确定终止条件
    要比较两个节点数值相不相同，⾸先要把两个节点为空的情况弄清楚！否则后⾯比较数值的时候就会操作空指针了。
    节点为空的情况有：（注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点）
    左节点为空，右节点不为空，不对称，return false
    左不为空，右为空，不对称 return false
    左右都为空，对称，返回true

  此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：
  左右都不为空，比较节点数值，不相同就return false

  注意上⾯最后⼀种情况，我没有使用else，而是elseif， 因为我们把以上情况都排除之后，剩下的就是
  左右节点都不为空，且数值相同的情况。

3. 确定单层递归的逻辑
    此时才进入单层递归的逻辑，单层递归的逻辑就是处理 右节点都不为空，且数值相同的情况。
    比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
    比较内测是否对称，传入左节点的右孩子，右节点的左孩子。
    如果左右都对称就返回true ，有⼀侧不对称就返回false 。

**递归法**：

```C++
 bool compare(TreeNode* left, TreeNode* right) {
     // ⾸先排除空节点的情况
     if (left == NULL && right != NULL) return false;
     else if (left != NULL && right == NULL) return false;
     else if (left == NULL && right == NULL) return true;
     // 排除了空节点，再排除数值不相同的情况
     else if (left->val != right->val) return false;
     // 此时就是：左右节点都不为空，且数值相同的情况
     // 此时才做递归，做下⼀层的判断
     bool outside = compare(left->left, right->right); // 左子树：左、 右子树：右
     bool inside = compare(left->right, right->left); // 左子树：右、 右子树：左
     bool isSame = outside && inside; // 左子树：中、 右子树：中 （逻辑处理）
     return isSame;
 }

 bool isSymmetric(TreeNode* root) {
	if (root == NULL) return true;
 	return compare(root->left, root->right);
 }
```





### J26. 树的子结构

**[题目](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)**：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

```
例如:
给定的树 A:
	 3
    / \
   4   5
  / \
 1   2
给定的树 B：

   4 
  /
 1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
```
```
示例 1：
输入：A = [1,2,3], B = [3,1]
输出：false

示例 2：
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

限制：

0 <= 节点个数 <= 10000



**思路1**：递归。

首先编写一个递归函数`traversalOneTree()`来遍历树A。在每次遍历中，将 A树的当前节点 和  B树的根节点 输入到另一个遍历函数`traveralTwoTree()`中，该函数用于同时遍历两棵树，以比较两棵树是否相等。

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
private:
    bool traveralTwoTree(TreeNode* A, TreeNode* B){
        if(!A && !B)return true;
        else if(A && !B) return true;
        else if(!A && B)return false;
        else if(A->val!=B->val) return false;
        else{
            return traveralTwoTree(A->left,B->left) && 
                traveralTwoTree(A->right,B->right);
        }
    }
    bool traversalOneTree(TreeNode* A, TreeNode* B){
        if(!A)return false;
        bool left = traversalOneTree(A->left,B);
        bool right = traversalOneTree(A->right,B);
        bool curr = traveralTwoTree(A,B);
        return left || right || curr;
    }

public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(!B || !A) return false;//约定空树不是任意一个树的子结构
        return traversalOneTree(A,B);
    }
};
```



第二种实现：

```C++
//判断如果A,B根节点相同，B是不是A的子结构
bool hasSubStructure(TreeNode *A, TreeNode *B)
{
    if (!B) return true; //A的一个节点B的对应位置没有,可以认为是子结构
    if (!A || A->val != B->val)return false;//B的一个节点A的对应位置没有 / A,B对应位置节点值不同，此时必然不可能是子结构
    return hasSubStructure(A->left, B->left) && hasSubStructure(A->right, B->right); 
}

bool isSubStructure(TreeNode *A, TreeNode *B)
{
    if (!A || !B)return false;   //特殊判断
    // 根节点相同的话直接进入比较，根节点不相同看B是不是A的左/右子树的子结构
    return hasSubStructure(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
}
```



### L572. 另一棵树的子树

**[题目](https://leetcode-cn.com/problems/subtree-of-another-tree/)**: 给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。

二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。

 ```
示例 1：
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true

示例 2：
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
 ```


提示：

```
root 树上的节点数量范围是 [1, 2000]
subRoot 树上的节点数量范围是 [1, 1000]
-10^4 <= root.val <= 10^4
-10^4 <= subRoot.val <= 10^4
```



**思路1**：递归。

本题和J26略有区别： 二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。 如下面的例子：

```
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
```



![](https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg)

​	因此，` bool traversalTwoTree(TreeNode* root, TreeNode* sub)`的返回值略有不同。

代码：

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    bool traversalTwoTree(TreeNode* root, TreeNode* sub){
        if(!sub && !root) return true;
        else if(!root || !sub) return false;
        else if(root->val != sub->val) return false;
        else return traversalTwoTree(root->left,sub->left) 
            && traversalTwoTree(root->right,sub->right);
    }
public:
    //遍历root
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(!root) return false;
        bool left = isSubtree(root->left,subRoot);
        bool right = isSubtree(root->right,subRoot);
        bool sub = traversalTwoTree(root,subRoot);
        return left || right || sub;
    }
};
```





**思路2**：深度优先搜索序列上做串匹配



**思路3**：树哈希。





## 二叉树的深度和高度



### L104. 二叉树的最大深度 & J55. 二叉树的深度 I

**题目**：给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

**思路1**：广度优先搜索或深度优先搜索，在将节点放入stack或queue时，同时放入深度。实现：

```C++
int maxDepth(TreeNode* root) {
        if(!root)
            return 0;
        int max_depth=0;
        stack<pair<TreeNode*,int>> stk;
        stk.push({root,1});
        while(!stk.empty()){
            auto [node,depth] = stk.top();
            stk.pop();
            if(node->left)stk.push({node->left,depth+1});
            if(node->right)stk.push({node->right,depth+1});
            if(depth>max_depth)
                max_depth=depth;
        }
        return max_depth;
    }
```

**思路2**：同L102



**思路3**：递归的方法。

```C++
int getDepth(TreeNode* node) {
     if (node == NULL) return 0;
     int leftDepth = getDepth(node->left); // 左
     int rightDepth = getDepth(node->right); // 右
     int depth = 1 + max(leftDepth, rightDepth); // 中
     return depth;
 }
 int maxDepth(TreeNode* root) {
 	return getDepth(root);
 }
```

或：

```C++
int maxDepth(TreeNode* root) {
    if(!root) return 0;
    return std::max(maxDepth(root->left),maxDepth(root->right))+1;
}
```









### L111. 二叉树的最小深度

**题目**：给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

**思路1**：层序遍历法（或广度优先搜索）。

遇到的第一个无孩子的子节点时的深度，即为二叉树的最小深度。

```C++
int minDepth(TreeNode* root) {
    if(!root)return 0;
    std::queue<TreeNode*> q;
    q.push(root);
    int level_num =0;
    while(!q.empty()){
        int size = q.size();
        level_num ++ ;
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            if(!node->left && !node->right)
                return level_num;
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
    }
    return 0;
}
```



**思路2**：递归法（深度优先搜索）。

每个子树均返回其最小深度。

```C++
int minDepth(TreeNode *root) {
    if (root == nullptr)
        return 0;
    if (root->left == nullptr && root->right == nullptr) 
        return 1;
    int min_depth = INT_MAX;
    if (root->left != nullptr) 
        min_depth = min(minDepth(root->left), min_depth);
    if (root->right != nullptr) 
        min_depth = min(minDepth(root->right), min_depth);
    return min_depth + 1;
}
```





### L110. 平衡二叉树 & J55. 平衡二叉树 II

**题目**：给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。



**分析**：

二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。 

二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

LeetCode中根节点深度是1。

因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）



**思路1**：递归。自底向上返回子树的高度，在每次递归时，当左右两个子树的高度差大于1时，则表明这不是一个平衡二叉树。

```C++
int GetDepth(TreeNode* root){
    if(!root) return 0;
    int left_height = GetDepth(root->left);
    int right_height = GetDepth(root->right);
    if(left_height==-1 || right_height==-1 || std::abs(left_height - right_height) > 1)
        return -1;
    else
        return std::max(left_height,right_height)+1;
}

bool isBalanced(TreeNode* root) {
    if(GetDepth(root)==-1)
        return false;
    else
        return true;
}
```

或

```C++
bool is_balanced{true};
int getMaxDepth(TreeNode* root){
    if(!root) return 0;
    int left = getMaxDepth(root->left);
    int right = getMaxDepth(root->right);
    if(std::abs(left-right)>1) is_balanced=false;
    return std::max(left,right) + 1;
}
bool isBalanced(TreeNode* root) {
    getMaxDepth(root);
    return is_balanced;
}
```





**思路2**：迭代





### L543. 二叉树的直径

**[题目](https://leetcode-cn.com/problems/diameter-of-binary-tree/)**：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

    示例 :
    给定二叉树
          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。



**思路1**：深度优先搜索，后序遍历。

一棵树的直径为两颗子树的最大高度之和。`int traversal(TreeNode* node)`遍历二叉树，并返回以`node`为根节点的子树的最大深度。在遍历过程中，记录左右子树的最大深度之和。

```C++
class Solution {
private:
    int traversal(TreeNode* node){
        if(!node)return 0;
        int left = traversal(node->left);
        int right =traversal(node->right);
        max_len = std::max(max_len,left+right);//左右子树的最大深度之和
        return std::max(left,right)+1;//该子树的最大深度
    }
    int max_len{0};
public:
    int diameterOfBinaryTree(TreeNode* root) {
        traversal(root);
        return max_len;
    }
};
```









## 节点个数

### L222. 完全二叉树的节点个数

**题目**：给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h 个节点。

**思路1**：广度优先搜索

```C++
int countNodes(TreeNode* root) {
    int cnt = 0;
    if(!root) return cnt;
    std::queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        auto node = q.front();
        q.pop();
        cnt++;
        if(node->left) q.push(node->left);
        if(node->right) q.push(node->right);
    }
    return cnt;
}
```



**思路2**：深度优先搜索。

```C++
int countNodes(TreeNode* root) {
    if(!root)
        return 0;
    if(!root->left && !root->right)
        return 1;
    int num=1;
    if(root->left)
        num += countNodes(root->left);
    if(root->right)
        num+=countNodes(root->right);
    return num;
}
```



**思路3**：







### L404. 左叶子之和

**题目**： 计算给定二叉树的所有左叶子之和。 



**思路1**：递归。递归到某个节点的左孩子为叶结点时，将该叶结点的值增加到总和中。

```C++
int sumOfLeftLeaves(TreeNode* root) {
    if(!root)
        return 0;
    int sum=0;
    if(root->left && !root->left->left && !root->left->right)
        sum+= root->left->val;
    sum += sumOfLeftLeaves(root->left);
    sum += sumOfLeftLeaves(root->right);
    return sum;
}
```



**思路2**：迭代法。前序、中序、后序遍历都可以。这里是中序遍历。

```C++
int sumOfLeftLeaves(TreeNode* root) {
    int sum=0;
    if(!root)
        return sum;
    stack<TreeNode*> stk;
    auto node = root;
    while(node || !stk.empty()){
        while(node){
            stk.push(node);
            node = node->left;
        }
        if(!stk.empty()){
            node = stk.top();
            stk.pop();
            if(node->left && !node->left->left &&!node->left->right)
                sum += node->left->val;
            node = node->right;

        }
    }
    return sum;
}
```









## 路径和



### L112. 路径总和

**题目**：给定一个二叉树，检查它是否是镜像对称的。给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，
这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。  
叶子节点 是指没有子节点的节点。

**思路1**：迭代 
使用 深度优先搜索 或 广度优先搜索。在queue或stack中，同时保存到当前节点的路径和。如stack<tuple<TreeNode*,int>>

```C++
bool hasPathSum1(TreeNode* root, int targetSum) {
    if(!root)
        return false;
    stack<tuple<TreeNode*,int>> stk;//int表示路径和
    stk.push({root,root->val});
    while(!stk.empty()){
        auto [node,ps] = stk.top();
        stk.pop();
        if(!node->left && !node->right && ps==targetSum)
            return true;
        if(node->right)stk.push({node->right,node->right->val + ps});
        if(node->left)stk.push({node->left,node->left->val + ps});
    }
    return false;
}
```

**思路2**：递归 

假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。
不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路
 径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。   

```C++
bool hasPathSum(TreeNode *root, int sum) {
    if (root == nullptr) {
        return false;
    }
    if (root->left == nullptr && root->right == nullptr) {
        return sum == root->val;
    }
    return hasPathSum(root->left, sum - root->val) ||
           hasPathSum(root->right, sum - root->val);
}
```





### L113. 路径总和 II  & J34. 二叉树中和为某一值的路径

**[题目](https://leetcode-cn.com/problems/path-sum-ii/)**：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

```
示例 1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

示例 2：
输入：root = [1,2,3], targetSum = 5
输出：[]

示例 3：
输入：root = [1,2], targetSum = 0
输出：[]
```

提示：

树中节点总数在范围 [0, 5000] 内
-1000 <= Node.val <= 1000
-1000 <= targetSum <= 1000



**思路1**：基于迭代的深度优先搜索。

采用深度优先搜索的后序遍历。当遇到叶结点 且 路径和满足时，将stack内的所有节点的值保存到输出。

迭代法。

```C++
//获取栈内的元素值
vector<int> getStackElement(stack<TreeNode*> &stk){
    stack<TreeNode*> tmp;
    int size = stk.size();
    vector<int> v(size);
    for(int i=0;i<size;++i){
        tmp.push(stk.top());
        stk.pop();
    }
    for(int i=0;i<size;++i){
        v[i] = tmp.top()->val;
        stk.push(tmp.top());
        tmp.pop();
    }
    return v;
}

vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
    vector<vector<int>> output;
    //用深度优先搜索,后序遍历
    if(!root) return output;
    stack<TreeNode*> stk;
    auto node = root;
    TreeNode* prev = nullptr;
    int sum=0;
    while(node || !stk.empty()){
        while(node){
            sum += node->val;
            stk.push(node);
            node = node->left;
        }
        node = stk.top();
        stk.pop();
        sum -= node->val;
        if(!node->right || prev==node->right){
            if(!node->left && !node->right && node->val + sum == targetSum){
                vector<int> v = getStackElement(stk);
                v.push_back(node->val);
                output.push_back(v);
            }
            prev = node;
            node =nullptr;
        }
        else{
            sum += node->val;
            stk.push(node);
            node = node->right;
        }
    }
    return output;
}
```



**思路2**：递归法。

我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。

```C++
vector<vector<int>> ret;
vector<int> path;

void dfs(TreeNode* root, int targetSum) {
    if (root == nullptr) return;
    path.emplace_back(root->val);
    targetSum -= root->val;
    if (!root->left && !root->right && targetSum == 0) 
        ret.emplace_back(path);
    dfs(root->left, targetSum);
    dfs(root->right, targetSum);
    path.pop_back();
}

vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
    dfs(root, targetSum);
    return ret;
}
```



另一种实现：

```C++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void traversal(TreeNode* node,int target,int curr){
        if(!node ) 
            return ;
        path.push_back(node->val);
        if(!node->left && !node->right && curr+node->val == target){
            result.push_back(vector<int>(path.begin(),path.end()));
        }
        else{
            traversal(node->left,target,curr+node->val);
            traversal(node->right,target,curr+node->val);
        }
        path.pop_back();
    }
public:
    vector<vector<int>> pathSum(TreeNode* root, int target) {
        traversal(root,target,0);
        return result;
    }
};
```





### L437. 路径总和 III  &  JII50. 向下的路径节点之和

[题目](https://leetcode-cn.com/problems/path-sum-iii/)：给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img" style="zoom: 67%;" />

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

**示例 2：**

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

 **提示:**

- 二叉树的节点个数的范围是 `[0,1000]`
- `-10^9 <= Node.val <= 10^9` 
- `-1000 <= targetSum <= 1000` 



**思路1**：两重递归。

第一重递归遍历每个节点，第二重递归以每个节点作为起点，判断是否存在以该节点为起点的向下的路径和为k。

```C++
class Solution {
private:
    int cnt=0;
	//第二重节点
    void dfs(TreeNode* root,int targetSum){
        if(!root) 
            return;
        //cout<<root->val<<" "<<targetSum<<endl;
        if(root->val == targetSum){
            cnt++;
        }
        dfs(root->left,targetSum - root->val);
        dfs(root->right,targetSum - root->val);
    }
	//第一重节点
    void dfs_read(TreeNode* root,int targetSum){
        if(!root) 
            return;
        dfs(root,targetSum);
        dfs_read(root->left,targetSum);
        dfs_read(root->right,targetSum);
    }
public:
    int pathSum(TreeNode* root, int targetSum) {
        dfs_read(root,targetSum);
        return cnt;
    }
};
```



官方解答：

方法一：深度优先搜索

我们首先想到的解法是穷举所有的可能，我们访问每一个节点 node，检测以 node 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。

我们首先定义 rootSum(p,val) 表示以节点 p 为起点向下且满足路径总和为 val 的路径数目。我们对二叉树上每个节点 p 求出 rootSum(p,targetSum)，然后对这些路径数目求和即为返回结果。

我们对节点 p 求 rootSum(p,targetSum) 时，以当前节点 p 为目标路径的起点递归向下进行搜索。假设当前的节点 p 的值为 val，我们对左子树和右子树进行递归搜索，对节点 p 的左孩子节点 $p_{l}$  求出 $\textit{rootSum}(p_{l},\textit{targetSum}-\textit{val})$ ，以及对右孩子节点 $p_{r}$ 求出 $\textit{rootSum}(p_{r},\textit{targetSum}-\textit{val})$  。节点 p 的 rootSum(p,targetSum) 即等于 $\textit{rootSum}(p_{l},\textit{targetSum}-\textit{val})$  与 $\textit{rootSum}(p_{r},\textit{targetSum}-\textit{val})$   之和，同时我们还需要判断一下当前节点 p 的值是否刚好等于 $\textit{targetSum}$ 。

我们采用递归遍历二叉树的每个节点 p，对节点 p 求 rootSum(p,val)，然后将每个节点所有求的值进行相加求和返回。

```C++
class Solution {
public:
    int rootSum(TreeNode* root, int targetSum) {
        if (!root) {
            return 0;
        }
        int ret = 0;
        if (root->val == targetSum) {
            ret++;
        } 
        ret += rootSum(root->left, targetSum - root->val);
        ret += rootSum(root->right, targetSum - root->val);
        return ret;
    }
    
    int pathSum(TreeNode* root, int targetSum) {
        if (!root) 
            return 0;
        int ret = rootSum(root, targetSum);
        ret += pathSum(root->left, targetSum);
        ret += pathSum(root->right, targetSum);
        return ret;
    }
};
```

时间复杂度：O(N^2)，其中 N 为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 O(N)，我们会对每个节点都求一次以该节点为起点的路径数目，因此时间复杂度为 $O(N^{2})$

空间复杂度：O(N)，考虑到递归需要在栈上开辟空间。



**方法二: 前缀和** 

​	我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点root 到当前节点 p 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 curr 减去targetSum。

* 对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 0。

* 假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为 $\textit{root} \rightarrow p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_k \rightarrow \textit{node}$ ，此时我们可以已经保存了节点 $p_1, p_2, p_3, \ldots, p_k$ 的前缀和，并且计算出了节点 node 的前缀和。

* 假设当前从根节点 root 到节点 node 的前缀和为 curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 curr−targetSum。假设从根节点 root 到节点 node 的路径中存在节点 $p_i$ 到根节点 root 的前缀和为 curr−targetSum，则节点 $p_{i+1}$  到 node 的路径上所有节点的和一定为 targetSum。

* 我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。

```C++
class Solution {
public:
    unordered_map<long long, int> prefix;
	//从根节点 root 到节点 node 的前缀和为 curr
    int dfs(TreeNode *root, long long curr, int targetSum) {
        if (!root) {
            return 0;
        }
    
        int ret = 0;
        curr += root->val;
        //假设从根节点 root 到节点 node 的路径中存在节点 p_i 到根节点 root 的前缀和为 curr−targetSum，则节点 p_{i+1}  到 node 的路径上所有节点的和一定为 targetSum。
        if (prefix.count(curr - targetSum)) {
            ret = prefix[curr - targetSum];
        }
    
        prefix[curr]++;
        ret += dfs(root->left, curr, targetSum);
        ret += dfs(root->right, curr, targetSum);
        prefix[curr]--;
    
        return ret;
    }
    
    int pathSum(TreeNode* root, int targetSum) {
        prefix[0] = 1;
        return dfs(root, 0, targetSum);
    }

};
```

时间复杂度：O(N)，其中 N 为二叉树中节点的个数。利用前缀和只需遍历一次二叉树即可。

空间复杂度：O(N)。



**前缀和**：

前缀和怎么应用呢？

在同一个路径之下（可以理解成二叉树从root节点出发，到叶子节点的某一条路径），如果两个数的前缀总和是相同的，那么这些节点之间的元素总和为零。进一步扩展相同的想法，如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target。

因为本题中的路径是一棵树，从根往任一节点的路径上(不走回头路)，有且仅有一条路径，因为不存在环。(如果存在环，前缀和就不能用了，需要改造算法)

抵达当前节点(即B节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和currSum-target的节点(即A节点)，存在即表示从A到B有一条路径之和满足条件的情况。结果加上满足前缀和currSum-target的节点的数量。然后递归进入左右子树。

左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。





## 构造二叉树



### L106. 从中序和后序遍历序列构造二叉树

**题目**：根据一棵树的中序遍历与后序遍历构造二叉树。

注意:你可以假设树中没有重复的元素。

例如，给出

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```



**思路1**：已知后序遍历数组中的最后一个元素时该树的根节点，且中序遍历数组中根节点的左边是左子树，右边是右子树。则构造思路是：

* 第⼀步：如果数组大小为零的话，说明是空节点了。 

* 第二步：如果不为空，那么取后序数组最后⼀个元素作为根节点元素。 

* 第三步：找到后序数组最后⼀个元素在中序数组的位置，作为切割点 

* 第四步：切割中序数组，切成 中序左数组 和 中序右数组
* 第五步：切割后序数组，切成 后序左数组 和 后序右数组 

* 第六步：递归处理左区间和右区间

代码的思路是使用递归函数：

```C++
/**
inorder 中序左数组
inorder_begin 该子树的中序左数组
inorder_end 该子树的中序右数组
postorder后序左数组
postorder_begin 该子树的后序左数组
postorder_end 该子树的后序右数组
*/
TreeNode* traversal(vector<int>& inorder,int inorder_begin,int inorder_end,vector<int>& postorder,int postorder_begin,int postorder_end){
    //如果子数组为空，则返回
    if(postorder_begin == postorder_end)
        return nullptr;
    //取后序左数组的最后一个元素为该子树的根节点元素。
    int root_value = postorder[postorder_end-1];
    TreeNode *root=new TreeNode(root_value);
    //如果该子树是叶子节点
    if(postorder_end-postorder_begin==1)
        return root;
    //在该子树的中序数组中寻找根节点，作为分割点
    int delimiter; 
    for(delimiter=inorder_begin;delimiter<inorder_end;++delimiter){
        if(inorder[delimiter]==root_value)
            break;
    }
    //切割中序数组(左闭右开)
    int left_inorder_begin = inorder_begin;
    int left_inorder_end = delimiter;
    int right_inorder_begin = delimiter+1;
    int right_inorder_end = inorder_end;
    //切割后序数组
    int left_postorder_begin = postorder_begin;
    //(delimiter - inorder_begin)表示中序左子树的长度
    int left_postorder_end = postorder_begin + (delimiter - inorder_begin);
    int right_postorder_begin = postorder_begin + (delimiter -inorder_begin );
    int right_postorder_end = postorder_end -1;//由于最后一个元素被用掉了，因此这里要-1
    //递归
    root->left = traversal(inorder,left_inorder_begin,left_inorder_end,postorder,left_postorder_begin,left_postorder_end);
    root->right = traversal(inorder,right_inorder_begin,right_inorder_end,postorder,right_postorder_begin,right_postorder_end);
    return root;
}

TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    if(inorder.empty() || postorder.empty())
        return nullptr;
    return traversal(inorder,0,inorder.size(),postorder,0,postorder.size());

}
```





### L105. 从前序和中序遍历序列构造二叉树

**题目**：给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。

例子：

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```



**思路1**：已知前序遍历数组的第一个元素是该二叉树的根节点，则以该节点划分后序遍历的两个子树。递归。

* 第⼀步：如果数组大小为零的话，说明是空节点了。 

* 第二步：如果不为空，那么取前序数组第⼀个元素作为根节点元素。 

* 第三步：找到前序数组最后⼀个元素在 中序数组 的位置，作为切割点 

* 第四步：切割中序数组，切成 中序左数组 和 中序右数组
* 第五步：切割前序数组，切成 前序左数组 和 前序右数组 

* 第六步：递归处理左区间和右区间

```C++
TreeNode* traversal(vector<int>& preorder, int pre_start,int pre_end,
                    vector<int>& inorder, int in_start,int in_end){
    if(pre_start == pre_end){
        return nullptr;
    }
    int root_value = preorder[pre_start];
    //cout<<root_value<<endl;
    TreeNode* root = new TreeNode(root_value);
    if(pre_start-pre_end==1){
        return root;
    }
    int delimeter;
    for(int i=in_start;i<in_end;++i)if(inorder[i]==root_value)delimeter=i;
    int left_in_start = in_start;
    int left_in_end = delimeter;
    int right_in_start = delimeter+1;//这是因为delimeter这个元素已经作为根节点了
    int right_in_end = in_end;
    int left_pre_start = pre_start + 1;//这是因为前序数组的pre_start这个元素已经作为根节点了
    int left_pre_end = left_pre_start +  left_in_end-left_in_start;
    int right_pre_start = left_pre_end;
    int right_pre_end = right_pre_start+right_in_end-right_in_start;

    root->left = traversal(preorder,left_pre_start,left_pre_end,
                           inorder,left_in_start,left_in_end);
    root->right = traversal(preorder,right_pre_start,right_pre_end,
                            inorder,right_in_start,right_in_end);
    return root;
}


TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    if(preorder.empty() || inorder.empty()){
        return nullptr;
    }
    return traversal(preorder,0,preorder.size(),inorder,0,inorder.size());
}
```





### J07. 重建二叉树

**[题目](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)**: 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。



**思路1**：同L105。

根据前序数组的首个元素作为该子树的根节点。根据该元素在中序数组中查找划分节点。中序数组确定的左子树的大小，划分前序数组。迭代。

```C++
TreeNode* build(vector<int>& preorder, vector<int>& inorder,
                int p_start,int p_end,int i_start,int i_end){//注意，下标为左开右闭
    if(p_end==p_start) return NULL;
    TreeNode* node=new TreeNode(preorder[p_start]);//以前序数组的首元素作为根节点
    if(p_end-p_start==1) return node;
    //寻找中序数组的划分节点
    int delimiter;
    for(int i=i_start;i<i_end;++i){
        if(inorder[i]==preorder[p_start]){
            delimiter=i;
            break;
        }
    }
    //递归左右子树
    int left_len = delimiter-i_start;
    node->left = build(preorder,inorder,p_start+1,p_start+1+left_len,i_start,delimiter);
    node->right = build(preorder,inorder,p_start+1+left_len, p_end,delimiter+1,i_end);
    return node;
}

TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    return build(preorder,inorder,0,preorder.size(),0,inorder.size());
}
```







### L654. 最大二叉树

**题目**：给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：

1.二叉树的根是数组 nums 中的最大元素。
2.左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
3.右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
返回有给定数组 nums 构建的 最大二叉树 。



**思路1**：递归。

在每轮递归中传入在数组中的起点和终点（开边界），在这个范围内寻找一个最大值作为该子树的根节点。

```C++
TreeNode* traversal(vector<int> &nums,int start,int end){
    if(start == end)
        return nullptr;
    if(end-start==1)
        return new TreeNode(nums[start]);
    int delimiter=start;
    int max=nums[start];
    for(int i=start;i<end;++i){
        if(nums[i]>max){
            max = nums[i];
            delimiter = i;
        }
    }
    auto root = new TreeNode(max);
    root->left = traversal(nums,start,delimiter);
    root->right = traversal(nums,delimiter+1,end);
    return root;
}

TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
    if(nums.empty()) return nullptr;
    return traversal(nums,0,nums.size());
}
```





### L617. 合并二叉树

**题目**：给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

注意: 合并必须从两个树的根节点开始。



**思路1**：递归。

递归参数为子树tree0和子树tree1。

当tree0和tree1均不存在时，返回nullptr。

当tree0不存在 且 tree1存在时，返回tree1。

当tree0存在 且 tree1不存在时，返回tree0。

当tree0存在 且 tree1存在时，进行左右子树的递归。

```C++
TreeNode* traversal(TreeNode* tree0,TreeNode* tree1){
    if(!tree0 && !tree1)
        return nullptr;
    else if(!tree0 && tree1) 
        return tree1;
    else if(tree0 && !tree1) 
        return tree0;
    else{
        tree0->val += tree1->val;
        tree0->left = traversal(tree0->left,tree1->left);
        tree0->right = traversal(tree0->right,tree1->right);
        return tree0;
    }
}

TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    return traversal(root1,root2);
}
```



**思路2**：迭代。

```C++
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
     if (!t1) return t2;
     if (!t2) return t1;
     queue<TreeNode*> que;
     que.push(t1);
     que.push(t2);
     while(!que.empty()) {
         TreeNode* node1 = que.front(); que.pop();
         TreeNode* node2 = que.front(); que.pop();
         node1->val += node2->val;// 此时两个节点⼀定不为空，val相加
         // 如果两棵树左节点都不为空，加入队列
         if (node1->left && node2->left) {
             que.push(node1->left);
             que.push(node2->left);
         }
         // 如果两棵树右节点都不为空，加入队列
         if (node1->right && node2->right ) {
             que.push(node1->right);
             que.push(node2->right);
         }
         // 当t1的左节点 为空 t2左节点不为空，就赋值过去
         if (!node1->left && node2->left ) 
         	node1->left = node2->left;
         // 当t1的右节点 为空 t2右节点不为空，就赋值过去
         if (!node1->right && node2->right) 
	         node1->right = node2->right;
     }
     return t1;
 }
```





## 序列化

### L297. 二叉树的序列化和反序列化  &  J37. 序列化二叉树

**[题目](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)**：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示**: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

示例1：

![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

 ```
示例 1：
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]

示例 2：
输入：root = []
输出：[]

示例 3：
输入：root = [1]
输出：[1]

示例 4：
输入：root = [1,2]
输出：[1,2]
 ```


提示：

树中结点数在范围 [0, 10^4] 内
-1000 <= Node.val <= 1000



**分析**：

序列化的规范如下：

1. `[]`

   ```
   Empty tree. The root is a reference to NULL (C/C++), null (Java/C#/Javascript), None (Python), or nil (Ruby).
   ```

2. `[1, 2, 3]`

   ```
        1
       / \
      2   3
   ```

3. `[1, null, 2, 3]`

   ```
        1
         \
          2
         /
        3
   ```

4. `[5, 4, 7, 3, null, 2, null, -1, null, 9]`

   ```
         5
        / \
       4   7
      /   /
     3   2
    /   /
   -1  9
   ```





**思路1**：广度优先搜索（迭代）。

序列化：使用广度优先搜索。与普通的广度优先搜索不同，在这里即使节点为null，也需要放到队列中，用于序列化。

对于反序列化：这里使用广度优先搜索来构建二叉树。首先遍历字符串，一旦遇到`','`，则到达一个单词结尾。首先创建该节点的指针`node`，此时首先判断是否是空节点。若不为空节点，则创建内存，并将该节点放入队列中。

使用计数器`count`，若`count==0`，则该节点是头节点。若`count>0 && count%2==1`，则该节点是队列前面节点`q.front()`的左节点；若`count>0 && count%2==0`，则该节点是`q.front()`的右节点，

```C++
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        //广度优先搜索
        string str;
        std::queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            //层序遍历
            int size=q.size();
            for(int i=0;i<size;++i){
                auto node=q.front();
                q.pop();
                if(!node){ 
                    str+="null,";
                }
                else{ 
                    str+=std::to_string(node->val)+",";
                    q.push(node->left);
                    q.push(node->right);
                }
            }
        }
        str.erase(str.end()-1);//去掉最后一个逗号
        str = "["+str+"]";
        return str;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        TreeNode* head=nullptr;
        std::queue<TreeNode*> q;
        int count=0;//构建节点的数量
        for(int i=1,start=1;i<data.size()-1;++i){//去掉头和尾部的方括号
            if(data[i]==',' || i==data.size()-2){
                TreeNode* node=NULL;
                //是数字,构建新节点
                string sub=data.substr(start,i-start);
                if(sub[0] !='n'){
                    node = new TreeNode(std::stoi(sub));
                    q.push(node);
                }
                if(count==0)  
                    head=node;//头节点
                else if(count>0 && count%2==1)//连接左节点
                    q.front()->left=node;
                else if(count>0 && count%2==0)//连接右节点
                    q.front()->right=node;
                if(count>0 && count%2==0)//剔除队列中的节点
                    q.pop();
                start = i+1;
                count++;
            }
        }
        return head;
    }
};
```



**思路2**：深度优先搜索（**中序遍历**）。

![](https://assets.leetcode-cn.com/solution-static/297/12.PNG)

我们从根节点 1 开始，序列化字符串是 1,。然后我们跳到根节点 2 的左子树，序列化字符串变成 1,2,。现在从节点 2 开始，我们访问它的左节点 3 `（1,2,3,None,None,）`和右节点 4 `(1,2,3,None,None,4,None,None)`。`None,None,` 是用来标记缺少左、右子节点，这就是我们在序列化期间保存树结构的方式。最后，我们回到根节点 1 并访问它的右子树，它恰好是叶节点 5。最后，序列化字符串是`1,2,3,None,None,4,None,None,5,None,None,`。

即我们可以先序遍历这颗二叉树，遇到空子树的时候序列化成 None，否则继续递归序列化。那么我们如何反序列化呢？首先我们需要根据 , 把原先的序列分割开来得到先序遍历的元素列表，然后从左向右遍历这个序列：

如果当前的元素为 None，则当前为空树
否则先解析这棵树的左子树，再解析它的右子树

```C++
class Codec {
private:
    void rserialize(TreeNode* root, string& str) {
        if (root == nullptr) {
            str += "None,";
        } else {
            str += to_string(root->val) + ",";
            rserialize(root->left, str);
            rserialize(root->right, str);
        }
    }
    
    TreeNode* rdeserialize(list<string>& dataArray) {
        if (dataArray.front() == "None") {
            dataArray.erase(dataArray.begin());
            return nullptr;
        }
        TreeNode* root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin());
        
        root->left = rdeserialize(dataArray);
        root->right = rdeserialize(dataArray);
        return root;
    }
public:
    string serialize(TreeNode* root) {
        string ret;
        rserialize(root, ret);
        return ret;
    }

    TreeNode* deserialize(string data) {
        //将data划分为list<string>
        list<string> dataArray;
        string str;
        for (auto& ch : data) {
            if (ch == ',') {
                dataArray.push_back(str);
                str.clear();
            } else {
                str.push_back(ch);
            }
        }
        if (!str.empty()) {
            dataArray.push_back(str);
            str.clear();
        }
        //递归
        return rdeserialize(dataArray);
    }
};
```
















# 二叉搜索树



### J54. 二叉搜索树的第k大节点

**[题目](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)**：给定一棵二叉搜索树，请找出其中第 k 大的节点的值。

 ```
示例 1:
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4

示例 2:
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
 ```


限制：

1 ≤ k ≤ 二叉搜索树元素个数



**思路1**：从右往左的中序遍历。

由于是二叉搜索树，因此 右节点>父节点>左节点。因此中序遍历可得到一个升序序列，而从右往左的中序遍历可得到降序序列。

下面的代码中，k或返回值也可用全局变量来表示。

```C++
class Solution {
private:
    int traversal(TreeNode* root, int &k){
        if(!root) return 0;
        int b=traversal(root->right,k);
        --k;
        if(k==0)
            return root->val;
        int a=traversal(root->left,k);
        return a+b;
    }
public:
    int kthLargest(TreeNode* root, int k) {
        return traversal(root,k);
    }
};
```





### L700. 二叉搜索树中的搜索

**题目**：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。



**思路1**：迭代。

```C++
TreeNode* searchBST(TreeNode* root, int val) {
    auto node = root;
    while(node){
        if(node->val == val)
            return node;
        else if(val < node->val )
            node = node->left;
        else
            node = node->right;
    }
    return node;
}
```

**思路2**：递归。

```C++
TreeNode* searchBST(TreeNode* root, int val) {
     if (root == NULL || root->val == val) 
         return root;
     if (root->val > val) 
         return searchBST(root->left, val);
     if (root->val < val) 
         return searchBST(root->right, val);
     return NULL;
 }
```






### L701. 二叉搜索树中的插入操作

**题目**：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。  
注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。  

**思路1**：递归  



**思路2**: 迭代  
将val与每个节点的val进行比较，若val<node->val，则进入左节点，否则进入右节点。  当节点为空时，插入新的节点。

```C++
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        //迭代法
        TreeNode* node = new TreeNode(val);
        if(!root){
            root = node;
            return root;
        }

        auto p = root;
        while(p){
            if(val < p->val){
                if(!p->left){
                    p->left = node;
                    break;
                }
                p = p->left;
            }
            if(val > p->val){
                if(!p->right){
                    p->right = node;
                    break;
                }
                p = p->right;
            }
        }
        return root;
    }
```



### L98. 验证二叉搜索树

**题目**：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。  
有效二叉搜索树定义如下：  
节点的左子树只包含 小于 当前节点的数。  
节点的右子树只包含 大于 当前节点的数。  
所有左子树和右子树自身必须也是二叉搜索树。  
	
**思路1**：根据二叉搜索树的定义可知，其中序遍历是一个升序，因此可以通过比较当前节点和上一节点的值来判断是否时二叉搜索树。

```C++
bool isValidBST(TreeNode* root) {
    //采用中序遍历
    stack<TreeNode*> stk;
    auto p = root;
    TreeNode* prev=nullptr;
    while(p || !stk.empty()){
        while(p){
            stk.push(p);
            p=p->left;
        }
        if(!stk.empty()){
            p = stk.top();
            stk.pop();
            if(prev && prev->val >= p->val ){
                return false;
            }
            prev = p;
            p = p->right;
        }
    }
    return true;
}
```

**思路2**：用递归法，对于每次递归传入当前节点的范围，若不满足范围则不是二叉搜索树。





### J33. 二叉搜索树的后序遍历序列

**[题目](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)**：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。
```
参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3
示例 1：

输入: [1,6,3,2,5]
输出: false
示例 2：

输入: [1,3,2,6,5]
输出: true
```
提示：
数组长度 <= 1000



**思路1**：递归分治。

​	根据二叉搜索树的定义，可以通过递归，判断所有子树的 正确性 （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。

**终止条件**：

 	当 i≥j ，说明此子树节点数量 ≤1 ，无需判别正确性，因此直接返回 true ；

**递推工作**：

​	**划分左右子树**： 遍历后序遍历的 `[i,j]` 区间元素，寻找 第一个大于根节点 的节点，索引记为 right_start 。此时，可划分出左子树区间 `[i,right_start −1]` 、右子树区间 `[right_start ,j−1]` 、根节点索引 j 。
​	**判断是否为二叉搜索树**：
​		左子树区间 `[i,m−1]` 内的所有节点都应 <postorder[j] 。而上面步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。
​		右子树区间 `[m,j−1]` 内的所有节点都应 >postorder[j] 。实现方式为遍历，当遇到≤postorder[j] 的节点则跳出；则可通过p=j 判断是否为二叉搜索树。

**返回值**：

​	 所有子树都需正确才可判定正确，因此使用 与逻辑符 && 连接。



```C++
class Solution {
    //分治算法
    bool divideAndConquer(vector<int>& postorder,int start,int end){
        if(start>=end) 
            return true;
        //开始划分,postorder[end]作为定界符
        int right_start=start;
        while(postorder[right_start]<postorder[end]) 
            right_start++;
        int right_end = right_start;
        while(postorder[right_end]>postorder[end])
            right_end++;
        return right_end==end 
            && divideAndConquer(postorder,start,right_start-1)
            && divideAndConquer(postorder,right_start,end-1);
    }

public:
    bool verifyPostorder(vector<int>& postorder) {
        return divideAndConquer(postorder,0,postorder.size()-1);
    }
};
```



**思路2**：辅助单调栈。

[解析](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/)





### L530. 二叉搜索树的最小绝对差

**题目**：给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。

差值是一个正数，其数值等于两值之差的绝对值。



**思路1**：先遍历整个二叉搜索树，将每个节点值放到数组中，然后对数组进行排序。最后遍历排序后的数组，得到最小绝对差。对二叉搜索树采用中序遍历时，得到的是一个有序数组，因此无需进行排序。

```C++
int getMinimumDifference(TreeNode* root) {
    if(!root) return 0;
    vector<int> nums;
    std::stack<TreeNode*> stk;
    auto node = root;
    while(node || !stk.empty()){
        while(node){
            stk.push(node);
            node = node->left;
        }
        if(!stk.empty()){
            node = stk.top();
            stk.pop();
            nums.push_back(node->val);
            node = node->right;
        }
    }
    int difference = INT_MAX;
    for(int i=1;i<nums.size();++i){
        if(int d = std::abs(nums[i]-nums[i-1]); d < difference)
            difference = d;
    }
    return difference;
}
```





### L501. 二叉搜索树中的众数

**题目**：给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树
例如：
给定 BST [1,null,2,2],



**思路1**：遍历整个二叉树，使用哈希表保存每个值的出现次数。遍历完成后，将哈希表的值转换到数组，并根据节点值的出现次数进行排序，选择前几个出现次数最高节点值作为输出值。

这种方法对所有的二叉树都有效。

```C++
vector<int> findMode(TreeNode* root) {
    vector<int> output;
    if(!root)return output;
    auto node = root;
    std::stack<TreeNode*> stk;
    std::unordered_map<int,int> d;
    while(node || !stk.empty()){
        while(node){
            stk.push(node);
            node = node->left;
        }
        if(!stk.empty()){
            node = stk.top();
            stk.pop();
            if(d.find(node->val)==d.end())
                d.insert({node->val,1});
            else
                d[node->val]++;
            node = node->right;
        }
    }
    vector<pair<int,int>> arr(d.begin(),d.end());
    std::sort(arr.begin(),arr.end(),[](pair<int,int> a,pair<int,int> b){
        return a.second > b.second;
    });
    output.push_back(arr[0].first);
    int max_cnt = arr[0].second;
    for(int i=1;i<arr.size();++i){
        if(arr[i].second == max_cnt)
            output.push_back(arr[i].first);
        else
            break;
    }
    return output;
}
```



**思路2**：利用中序遍历的有序性，只遍历一次二叉树。

既然是搜索树，它中序遍历就是有序的。遍历二叉树中元素出现频率，从头遍历，那么⼀定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。

弄⼀个指针指向前⼀个节点，这样每次cur（当前节点）才能和pre（前⼀个节点）作比较。
而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第⼀个元素。

一种思路是先遍历⼀遍二叉树，找出最大频率（maxCount），然后再新遍历⼀遍数组把出现频率为maxCount的元素放进集合。（因为众数有多个）这种⽅式遍历了两遍数组。

如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中。频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集，因为结果集之前的元素都失效了。

代码：

```C++
int maxCount; // 最大频率
int count; // 统计频率
TreeNode* pre;
vector<int> result;

void searchBST(TreeNode* cur) {
    if (!cur) return ;
    searchBST(cur->left); // 左
    // 中
    if (pre == NULL) // 第⼀个节点
        count = 1;
    else if (pre->val == cur->val)// 与前⼀个节点数值相同
        count++;
    else // 与前⼀个节点数值不同
        count = 1;
    pre = cur; // 更新上⼀个节点
    if (count == maxCount) // 如果和最大值相同，放进result中
        result.push_back(cur->val);
    if (count > maxCount) { // 如果计数大于最大值频率
        maxCount = count; // 更新最大频率
        result.clear(); // 清空result，之前result里的元素都失效了
        result.push_back(cur->val);
    }
    searchBST(cur->right); // 右
    return ;
}

vector<int> findMode(TreeNode* root) {
    count = 0;
    maxCount = 0;
    TreeNode* pre = NULL; // 记录前⼀个节点
    result.clear();
    searchBST(root);
    return result;
}
```









### L653. 两数之和 IV - 输入 BST

**题目**： 给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。  

**思路1**:采用中序遍历，将BST转换为升序数组。然后双指针遍历数组，判断是否存在两个值=k。

```C++
bool findTarget(TreeNode* root, int k) {
    //首先根据中序遍历，将BST转换为升序数组，然后从两边开始遍历
    if(!root)
        return false;
    vector<int> arr;
    stack<TreeNode*> stk;
    auto p = root;
    while(p || !stk.empty()){
        while(p){
            stk.push(p);
            p=p->left;
        }
        if(!stk.empty()){
            p = stk.top();
            stk.pop();
            arr.push_back(p->val);
            p = p->right;
        }
    }

    int n = arr.size();
    for(int i=0;i<n;++i){
        for(int j=n-1;j>i;--j){
            int v = arr[i]+arr[j];
            if(v == k)
                return true;
            if(v<k)
                break;
        }
    }

    return false;
}
```

**思路2**:遍历二叉树，将最简单的方法就是遍历整棵树，找出所有可能的组合，判断是否存在和为 k 的一对节点。现在在此基础上做一些改进。
如果存在两个元素之和为 k，即 x+y=k，并且已知 x 是树上一个节点的值，则只需判断树上是否存在一个值为 y 的节点，使得 y=k-x。  
 基于这种思想，在树的每个节点上遍历它的两棵子树（左子树和右子树），寻找另外一个匹配的数。在遍历过程中，将每个节点的值都放到一个 set 中。
对于每个值为 p 的节点，在 set中检查是否存在 k-p。如果存在，那么可以在该树上找到两个节点的和为 k；否则，将 p 放入到 set 中。
如果遍历完整棵树都没有找到一对节点和为 k，那么该树上不存在两个和为 k 的节点。  
	
	
	
### L235. 二叉搜索树的最近公共祖先

**题目**： 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。  
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”  
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

**思路1**:根据BST的性质，当(node->val >= p->val && node->val <= q->val) || (node->val <= p->val && node->val >= q->val)时，node是最近公共祖先。
```C++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    auto node = root;
    while(node){
        if((node->val >= p->val && node->val <= q->val) ||
           (node->val <= p->val && node->val >= q->val) )
            return node;
        else if(p->val < node->val && q->val < node->val)
            node = node->left;
        else
            node = node->right;
    }
    return node;
}
```





### J36. 二叉搜索树与双向链表

**[题目](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)**: 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。



**思路1**：深度优先搜索-中序遍历。

本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。
将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：

排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。
双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。
循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head 。

```C++
class Solution {
private:
    Node *head{nullptr},*prev{nullptr};
    void traversal(Node* node){
        if(!node) return;
        traversal(node->left);
        if(prev){
            prev->right=node;
            node->left=prev;
        }
        else{
            head=node;
        }
        prev=node;
        traversal(node->right);
    }
public:
    Node* treeToDoublyList(Node* root) {
        if(!root) return nullptr;
        traversal(root);
        head->left = prev;
        prev->right = head;
        return head;
    }
};
```



**思路2**：迭代的中序遍历。



**思路3**：遍历二叉树，将每个节点保存到数组中，最后将数组中的节点构建为双向链表。



### L108. 将有序数组转换为二叉搜索树

**[题目](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)**：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

```
示例 1：
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：

示例 2：
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```


提示：

1 <= nums.length <= 10^4
-10^4 <= nums[i] <= 10^4
nums 按 严格递增 顺序排列



**思路1**：递归。

递归划分数组。对于每一次划分，取 mid=(left+right)/2为头节点，对数组的左边构建二叉树，设置到head->left；数组的右边构建右二叉树。

```C++
class Solution {
    TreeNode* createTree(vector<int>& nums,int left,int right){
        if(left>right){
            return nullptr;
        }
        else if(left==right){
            return new TreeNode(nums[left]);
        }
        int mid = (left+right)/2;//选择中间靠左的数字作为头节点
        TreeNode* head = new TreeNode(nums[mid]);
        head->left = createTree(nums,left,mid-1);
        head->right = createTree(nums,mid+1,right);
        return head;
    }
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* head = createTree(nums,0,nums.size()-1);
        return head;
    }
};
```



**官方解答**：

二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。

给定二叉搜索树的中序遍历，是否可以唯一地确定二叉搜索树？答案是否定的。如果没有要求二叉搜索树的高度平衡，则任何一个数字都可以作为二叉搜索树的根节点，因此可能的二叉搜索树有多个。

![](https://assets.leetcode-cn.com/solution-static/108/108_fig1.png)

如果增加一个限制条件，即要求二叉搜索树的高度平衡，是否可以唯一地确定二叉搜索树？答案仍然是否定的。

![](https://assets.leetcode-cn.com/solution-static/108/108_fig2.png)

直观地看，我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 1，可以使得树保持平衡。如果数组长度是奇数，则根节点的选择是唯一的，如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。

![](https://assets.leetcode-cn.com/solution-static/108/108_fig3.png)

确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。

当然，这只是我们直观的想法，为什么这么建树一定能保证是「平衡」的呢？这里可以参考「1382. 将二叉搜索树变平衡」，这两道题的构造方法完全相同，这种方法是正确的，1382 题解中给出了这个方法的正确性证明：1382 官方题解，感兴趣的同学可以戳进去参考。

递归的基准情形是平衡二叉搜索树不包含任何数字，此时平衡二叉搜索树为空。

在给定中序遍历序列数组的情况下，每一个子树中的数字在数组中一定是连续的，因此可以通过数组下标范围确定子树包含的数字，下标范围记为 [left,right]。对于整个中序遍历序列，下标范围从 left=0 到right=nums.length−1。当 left>right 时，平衡二叉搜索树为空。

以下三种方法中，方法一总是选择中间位置左边的数字作为根节点，方法二总是选择中间位置右边的数字作为根节点，方法三是方法一和方法二的结合，选择任意一个中间位置数字作为根节点。

**方法一：中序遍历，总是选择中间位置左边的数字作为根节点**

选择中间位置左边的数字作为根节点，则根节点的下标为 mid=(left+right)/2，此处的除法为整数除法。

```C++
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }
    public TreeNode helper(int[] nums, int left, int right) {
        if (left > right)
            return null;
        // 总是选择中间位置左边的数字作为根节点
        int mid = (left + right) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums, mid + 1, right);
        return root;
    }

}
```



时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。

空间复杂度：O(logn)，其中 n 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 O(logn)。

**方法二：中序遍历，总是选择中间位置右边的数字作为根节点**

选择中间位置右边的数字作为根节点，则根节点的下标为 mid=(left+right+1)/2，此处的除法为整数除法。

```C++
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    public TreeNode helper(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        // 总是选择中间位置右边的数字作为根节点
        int mid = (left + right + 1) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums, mid + 1, right);
        return root;
    }

}
```

时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。

空间复杂度：O(logn)，其中 n 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 O(logn)。

**方法三：中序遍历，选择任意一个中间位置数字作为根节点**

选择任意一个中间位置数字作为根节点，则根节点的下标为 mid=(left+right)/2 和 mid=(left+right+1)/2 两者中随机选择一个，此处的除法为整数除法。

```C++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(nums, 0, nums.size() - 1);
    }

    TreeNode* helper(vector<int>& nums, int left, int right) {
        if (left > right) {
            return nullptr;
        }

        // 选择任意一个中间位置数字作为根节点
        int mid = (left + right + rand() % 2) / 2;

        TreeNode* root = new TreeNode(nums[mid]);
        root->left = helper(nums, left, mid - 1);
        root->right = helper(nums, mid + 1, right);
        return root;
    }
};
```

时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。

空间复杂度O(logn)，其中 n 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 O(logn)。



### L109.有序链表转换二叉搜索树

[题目](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/) :给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差不超过 1。 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)

```
输入: head = [-10,-3,0,5,9]
输出: [0,-3,9,-10,null,5]
解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。
```

**示例 2:**

```
输入: head = []
输出: []
```

 **提示:**

- `head` 中的节点数在`[0, 2 * 104]` 范围内
- `-105 <= Node.val <= 105`



**思路1**：递归。

整体的思路与 L108 类似，不同的地方在于链表无法直接获得中点。

这里获得链表中点的方法是，设置快慢指针，快指针每次走2步，慢指针一次走1步，当快指针达到终点后，慢指针即为中点。

```C++
class Solution {
private:
    ListNode* getMidNode(ListNode *head){//获得中间靠右的节点，同时将中点的前一个节点断开
        ListNode* one=head,*two=head;
        ListNode* prev=nullptr;
        while(two && two->next){
            prev = one;
            one=one->next;
            two=two->next->next;
        }
        //将中点和前一个节点断开
        if(prev){
            prev->next=nullptr;
        }
        return one;
    }

public:
    TreeNode* sortedListToBST(ListNode* head) {
        if(!head)
            return nullptr;
        ListNode* mid = getMidNode(head);
        TreeNode* tree_head = new TreeNode(mid->val);
        //注意，中点不能是头节点，否则就无限递归了
        if(mid != head)
            tree_head->left = sortedListToBST(head);
        if(mid->next)
            tree_head->right = sortedListToBST(mid->next);
        return tree_head;
    }
};
```



**官方解答**：

将给定的有序链表转换为二叉搜索树的第一步是确定根节点。由于我们需要构造出平衡的二叉树，因此比较直观的想法是让根节点左子树中的节点个数与右子树中的节点个数尽可能接近。这样一来，左右子树的高度也会非常接近，可以达到高度差绝对值不超过 11 的题目要求。

如何找出这样的一个根节点呢？我们可以找出链表元素的中位数作为根节点的值。

这里对于中位数的定义为：如果链表中的元素个数为奇数，那么唯一的中间值为中位数；如果元素个数为偶数，那么唯二的中间值都可以作为中位数，而不是常规定义中二者的平均值。

根据中位数的性质，链表中小于中位数的元素个数与大于中位数的元素个数要么相等，要么相差 11。此时，小于中位数的元素组成了左子树，大于中位数的元素组成了右子树，它们分别对应着有序链表中连续的一段。在这之后，我们使用分治的思想，继续递归地对左右子树进行构造，找出对应的中位数作为根节点，以此类推。

可以证明，这样的构造方法得到的二叉搜索树是平衡的，详见文末的「正确性证明」部分。

**方法一：分治**

我们可以直接模拟「前言」部分的构造方案。

具体地，设当前链表的左端点为 left，右端点 right，包含关系为「左闭右开」，即 left 包含在链表中而 right 不包含在链表中。我们希望快速地找出链表的中位数节点 mid。

为什么要设定「左闭右开」的关系？由于题目中给定的链表为单向链表，访问后继元素十分容易，但无法直接访问前驱元素。因此在找出链表的中位数节点 mid 之后，如果设定「左闭右开」的关系，我们就可以直接用 (left,mid) 以及 (mid.next,right) 来表示左右子树对应的列表了。并且，初始的列表也可以用 (head,null) 方便地进行表示，其中 null 表示空节点。

找出链表中位数节点的方法多种多样，其中较为简单的一种是「快慢指针法」。初始时，快指针 fast 和慢指针 slow 均指向链表的左端点 left。我们将快指针 fast 向右移动两次的同时，将慢指针 slow 向右移动一次，直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。此时，慢指针对应的元素就是中位数。

在找出了中位数节点之后，我们将其作为当前根节点的元素，并递归地构造其左侧部分的链表对应的左子树，以及右侧部分的链表对应的右子树。

```C++
class Solution {
public:
    ListNode* getMedian(ListNode* left, ListNode* right) {
        ListNode* fast = left;
        ListNode* slow = left;
        while (fast != right && fast->next != right) {
            fast = fast->next;
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }

    TreeNode* buildTree(ListNode* left, ListNode* right) {
        if (left == right) {
            return nullptr;
        }
        ListNode* mid = getMedian(left, right);
        TreeNode* root = new TreeNode(mid->val);
        root->left = buildTree(left, mid);
        root->right = buildTree(mid->next, right);
        return root;
    }
    
    TreeNode* sortedListToBST(ListNode* head) {
        return buildTree(head, nullptr);
    }

};
```

时间复杂度：O(nlogn)，其中 n 是链表的长度。

设长度为 n 的链表构造二叉搜索树的时间为 T(n)，递推式为 T(n)=2⋅T(n/2)+O(n)，根据主定理，T(n)=O(nlogn)。

空间复杂度：O(logn)，这里只计算除了返回答案之外的空间。平衡二叉树的高度为 O(logn)，即为递归过程中栈的最大深度，也就是需要的空间。

**方法二：分治 + 中序遍历优化**

方法一的时间复杂度的瓶颈在于寻找中位数节点。由于构造出的二叉搜索树的中序遍历结果就是链表本身，因此我们可以将分治和中序遍历结合起来，减少时间复杂度。

具体地，设当前链表的左端点编号为 left，右端点编号为 right，包含关系为「双闭」，即 left 和 right 均包含在链表中。链表节点的编号为 [0,n)。中序遍历的顺序是「左子树 - 根节点 - 右子树」，那么在分治的过程中，我们不用急着找出链表的中位数节点，而是使用一个占位节点，等到中序遍历到该节点时，再填充它的值。

我们可以通过计算编号范围来进行中序遍历：

中位数节点对应的编号为mid=(left+right+1)/2；

根据方法一中对于中位数的定义，编号为 (left+right)/2 的节点同样也可以是中位数节点。

左右子树对应的编号范围分别为 [left,mid−1] 和 [mid+1,right]。

如果 left>right，那么遍历到的位置对应着一个空节点，否则对应着二叉搜索树中的一个节点。

这样一来，我们其实已经知道了这棵二叉搜索树的结构，并且题目给定了它的中序遍历结果，那么我们只要对其进行中序遍历，就可以还原出整棵二叉搜索树了。

```C++
class Solution {
public:
    int getLength(ListNode* head) {
        int ret = 0;
        for (; head != nullptr; ++ret, head = head->next);
        return ret;
    }

    TreeNode* buildTree(ListNode*& head, int left, int right) {
        if (left > right) {
            return nullptr;
        }
        int mid = (left + right + 1) / 2;
        TreeNode* root = new TreeNode();
        root->left = buildTree(head, left, mid - 1);
        root->val = head->val;
        head = head->next;
        root->right = buildTree(head, mid + 1, right);
        return root;
    }
    
    TreeNode* sortedListToBST(ListNode* head) {
        int length = getLength(head);
        return buildTree(head, 0, length - 1);
    }
};
```

时间复杂度：O(n)，其中 n 是链表的长度。

设长度为 n 的链表构造二叉搜索树的时间为T(n)，递推式为 T(n)=2⋅T(n/2)+O(1)，根据主定理，T(n)=O(n)。

空间复杂度：O(logn)，这里只计算除了返回答案之外的空间。平衡二叉树的高度为 O(logn)，即为递归过程中栈的最大深度，也就是需要的空间。

正确性证明：略







## 其它



### L236. 二叉树的最近公共祖先

**题目**：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”





# N叉树



## 题目

### L429. N叉树的层序遍历

**[题目](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)**：给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

示例 1：

![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
```

示例 2：

![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

```
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
```


提示：

树的高度不会超过 1000
树的节点总数在 [0, 10^4] 之间



**思路1**：与二叉树的层序遍历一致。

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

vector<vector<int>> levelOrder(Node* root) {
    if(!root)
        return {};
    vector<vector<int>> arr;
    std::queue<Node*> q;
    q.push(root);
    while(!q.empty()){
        int size=q.size();
        vector<int> level(size);
        for(int i=0;i<size;++i){
            Node* node=q.front();
            q.pop();
            level[i]=node->val;
            for(Node* child:node->children){
                if(child){
                    q.push(child);
                }
            }
        }
        arr.push_back(level);
    }
    return arr;
}
```









### L559. N 叉树的最大深度

**[题目](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)**：
给定一个 N 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

示例 1：
![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)
输入：root = [1,null,3,2,4,null,5,6]
输出：3

示例 2：
![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：5

提示：
树的深度不会超过 1000 。
树的节点数目位于 [0, 104] 之间。



**思路1**：深度优先搜索。

如果根节点有 N 个子节点，则这 N 个子节点对应 N 个子树。记 N 个子树的最大深度中的最大值为 maxChildDepth，则该 NN 叉树的最大深度为 maxChildDepth+1。

每个子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法计算 N 叉树的最大深度。具体而言，在计算当前 N 叉树的最大深度时，可以先递归计算出其每个子树的最大深度，然后在 O(1) 的时间内计算出当前 N 叉树的最大深度。递归在访问到空节点时退出。

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
private:
    int dfs(Node* root){
        if(!root)
            return 0;
        int max_deep=0;
        for(Node* child : root->children){
            max_deep = std::max(max_deep,dfs(child));
        }
        return max_deep+1;
    }

public:
    int maxDepth(Node* root) {
        return dfs(root);
    }
};
```



**思路2**：广度优先搜索。

我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展。最后我们用一个变量 ans 来维护拓展的次数，该 N 叉树的最大深度即为 ans。

```C++
int maxDepth(Node* root) {
    if (root == nullptr) 
        return 0;
    queue<Node *> qu;
    qu.push(root);
    int ans = 0;
    while (!qu.empty()) {
        int size = qu.size();
        while (size > 0) {
            Node * node = qu.front();
            qu.pop();
            vector<Node *> children = node->children;
            for (auto child : children) {
                qu.push(child);
            }
            size--;
        }
        ans++;
    }
    return ans;
}
```

或

```C++
int maxDepth(Node* root) {
    if(!root) return 0;
    queue<Node*> q;
    q.push(root);
    int level_num=0;
    while(!q.empty()){
        int size = q.size();
        for(int i=0;i<size;++i){
            auto node = q.front();
            q.pop();
            for(auto e: node->children)
                if(e)
                    q.push(e);
        }
        level_num++;
    }
    return level_num;
}
```









### L589. N 叉树的前序遍历

**[题目](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)**：给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。
n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。

示例 1：
![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)
输入：root = [1,null,3,2,4,null,5,6]
输出：[1,3,5,6,2,4]

示例 2：
![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]

提示：

节点总数在范围 [0, 10^4]内
0 <= Node.val <= 10^4
n 叉树的高度小于或等于 1000



**思路1**：深度优先搜索。

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    void dfs(Node* root,vector<int>& vec){
        if(!root)
            return;
        vec.push_back(root->val);
        for(auto e:root->children){
            dfs(e,vec);
        }
    }
    vector<int> preorder(Node* root) {
        vector<int> vec;
        dfs(root,vec);
        return vec;
    }
};
```



**思路2**：迭代。

方法一中利用递归来遍历树，实际的递归中隐式调用了栈，在此我们可以直接模拟递归中栈的调用。在前序遍历中，我们会先遍历节点本身，然后从左向右依次先序遍历该每个以子节点为根的子树。

在这里的栈模拟中比较难处理的在于从当前节点 u 的子节点 $v_1$

  返回时，此时需要处理节点 u 的下一个节点 $v_2$ ，此时需要记录当前已经遍历完成哪些子节点，才能找到下一个需要遍历的节点。在二叉树树中因为只有左右两个子节点，因此比较方便处理，在 N 叉树中由于有多个子节点。

​	这里另外定义一个栈，用来保存当前节点的兄弟节点信息，以及当前节点在children中的索引。

```C++
vector<int> preorder(Node* root) {
    if(!root) return {};
    vector<int> output;
    stack<Node*> stk;
    stack<tuple<vector<Node*>,int>> info;//用于保存stk中对应节点的兄弟信息
    Node* node=root;
    vector<Node*> curr_children(1);//当前兄弟的信息
    int curr_index=0;//当前节点所在的curr_children中的索引
    while(!stk.empty() || node){
        //总是递归访问到node的最左下节点
        while(node){
            output.push_back(node->val);
            //cout<<node->val<<endl;
            stk.push(node);
            info.emplace(curr_children,curr_index);
            curr_children = node->children;
            curr_index=0;
            if(! node->children.empty())
                node=node->children[0];
            else
                node=nullptr;
        }
        if(!stk.empty()){
            //获取当前节点和它的兄弟信息
            node=stk.top();
            stk.pop();
            curr_children = get<0>(info.top());
            curr_index = get<1>(info.top())+1;
            info.pop();
            //达到下一个兄弟节点
            if(curr_index < curr_children.size()){
                node=curr_children[curr_index];
            }
            else{
                node=nullptr;
            }
        }

    }
    return output;
}
```







官方解答：使用哈希表记录当前节点 u 已经访问过哪些子节点。

* 每次入栈时都将当前节点的 u 的第一个子节点压入栈中，直到当前节点为空节点为止。

* 每次查看栈顶元素 p，如果节点 p 的子节点已经全部访问过，则将节点 p 的从栈中弹出，并从哈希表中移除，表示该以该节点的子树已经全部遍历过；如果当前节点 p 的子节点还有未遍历的，则将当前节点的 p 的下一个未访问的节点压入到栈中，重复上述的入栈操作。

```C++
vector<int> preorder(Node* root) {
    vector<int> res;
    if (root == nullptr)
        return res;
    unordered_map<Node *, int> cnt;
    stack<Node *> st;
    Node * node = root;
    while (!st.empty() || node != nullptr) {
        while (node != nullptr) {
            res.emplace_back(node->val);
            st.emplace(node);
            if (node->children.size() > 0) {
                cnt[node] = 0;
                node = node->children[0];
            } 
            else {
                node = nullptr;
            }         
        }
        node = st.top();
        int index = (cnt.count(node) ? cnt[node] : -1) + 1;
        if (index < node->children.size()) {
            cnt[node] = index;
            node = node->children[index];
        } 
        else {
            st.pop();
            cnt.erase(node);
            node = nullptr;
        }
    }
    return res;
}
```









### L590. N 叉树的后序遍历

**[题目](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)**：给定一个 n 叉树的根节点  root ，返回 其节点值的 后序遍历 。
n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。

示例 1：
![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)
输入：root = [1,null,3,2,4,null,5,6]
输出：[5,6,3,2,4,1]

示例 2：
![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]


提示：

节点总数在范围 [0, 10^4]内
0 <= Node.val <= 10^4
n 叉树的高度小于或等于 1000



**思路1**：递归法深度优先。

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    void dfs(Node* root,vector<int>& vec){
        if(!root)
            return;
        for(auto e:root->children){
            dfs(e,vec);
        }
        vec.push_back(root->val);
        return;
    }
    vector<int> postorder(Node* root) {
        vector<int> result;
        dfs(root,result);
        return result;
    }
};
```







# 前缀树

## 基础知识



## 题目



### L208. 实现 Trie (前缀树)

**[题目](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)**：给Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

* Trie() 初始化前缀树对象。
* void insert(String word) 向前缀树中插入字符串 word 。
* boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
* boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

```
示例：

输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```




提示：

1 <= word.length, prefix.length <= 2000
word 和 prefix 仅由小写英文字母组成
insert、search 和 startsWith 调用次数 总计 不超过 3 * 10^4 次




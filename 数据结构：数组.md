




# 1.数组

## 常见算法

### 双指针



## 数组的生成

### J17. 打印从1到最大的n位数

**[题目](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)**：输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

```
示例 1:

输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```


说明：

用返回一个整数列表来代替打印
n 为正整数



**思路1**：简单法：不考虑大数问题。

```C++
vector<int> printNumbers(int n) {
    int max=std::pow(10,n)-1;
    vector<int> arr(max);
    std::iota(arr.begin(),arr.end(),1);
    return arr;
}
```



**思路2**：当n很大时，会超出32位，此时需要考虑大数问题。





### L31. 下一个排列

**[题目](https://leetcode-cn.com/problems/next-permutation/)**：整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

* 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

* 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
* 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
* 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。

给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。

 ```
示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]
 ```


提示：

1 <= nums.length <= 100
0 <= nums[i] <= 100



**分析**：

​	“下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。

以 1,2,3,4,5,6 为例，其排列依次为：

```
123456
123465
123546
...
654321
```

可以看到有这样的关系：123456 < 123465 < 123546 < ... < 654321。



**思路1**：

我们希望下一个数**比当前数大**，这样才满足“下一个排列”的定义。因此只需要**将后面的「大数」与前面的「小数」交换**，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
我们还希望下一个数**增加的幅度尽可能的小**，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：

* 在尽可能**靠右**的低位进行交换，需要从后向前查找

* **将一个 尽可能小的「大数」 与前面的「小数」交换**。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换

* 将「大数」换到前面后，需要将「大数」后面的所有数**重置为升序，升序排列就是最小的排列**。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列

以上就是求“下一个排列”的分析过程。

**算法过程**

标准的“下一个排列”算法可以描述为：

* 1.从后向前查找第一个相邻升序的元素对 `(i,j)`，满足 `A[i] < A[j]`。此时 `[j,end)` 必然是降序

* 2.在 `[j,end)` 从后向前查找第一个满足 `A[i] < A[k]` 的 `k`。`A[i]`、`A[k]` 分别就是上文所说的「小数」、「大数」
* 3.将 `A[i]` 与 `A[k]` 交换

* 4.可以断定这时 `[j,end)` 必然是降序，逆置 `[j,end)`，使其升序

* 5.如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4

该方法支持数据重复，且在 C++ STL 中被采用。

```C++
void nextPermutation(vector<int>& nums) {
    int i=nums.size()-2;
    //从后往前 寻找第一个升序
    while(i>=0 && nums[i+1]<=nums[i])i--;
    if(i>=0){
        //寻找比nums[i]大的最小的数
        int j=nums.size()-1;
        while(nums[j]<=nums[i])j--;
        std::swap(nums[i],nums[j]);
        std::reverse(nums.begin()+i+1,nums.end());//将num[i]后面的降序变为升序
    }
    else{
        std::reverse(nums.begin(),nums.end());
    }
}
```

时间复杂度：O(N)，其中 NN 为给定序列的长度。我们至多只需要扫描两次序列，以及进行一次反转操作。

空间复杂度：O(1)，只需要常数的空间存放若干变量。









## 数组的查找和计算



### J03. 数组中重复的数字

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)**:找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
示例 1：
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3
```

限制：

2 <= n <= 100000



**思路1**：暴力法。先排序，后遍历。

简单粗暴，时间复杂度为O(nlogn)。

```c++
int findRepeatNumber(vector<int>& nums) {
    std::sort(nums.begin(),nums.end());
    for(int i=0;i<nums.size()-1;++i)
	    if(nums[i]==nums[i+1])
	    	return nums[i];
    return nums[0];
}
```



**思路2**：普通的哈希表。



**思路3**：原地交换。

题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。
因此，可遍历数组并通过交换操作，使**元素的 索引 与 值 一一对应**（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。

遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x] = x，此时即可得到一组重复数字。

```C++
int findRepeatNumber(vector<int>& nums) {
    for(int i=0;i<nums.size();++i){
        int n=nums[i];
        if(i!=n && nums[n]==n) 
            return n;
        else
            std::swap(nums[i],nums[n]);
    }
    return nums[0];
}
```



### J03 II. 数组中重复的数字∶不修改数组

**题目**：在一个长度为n+1的数组里的所有数字都在1～n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2， 3，5，4，3，2，6，7}，那么对应的输出是重复的数字2或者3。

**思路1**：哈希表。时间复杂度O(n)，空间复杂度O(n)



**思路2**：二分查找的思路。时间复杂度O(nlogn)，空间复杂度O(1)





### L2022. 将一维数组转变成二维数组

**题目**: 给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有
元素创建一个 m 行 n 列的二维数组。 
original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都
包含 ）的元素构成二维数组的第二行，依此类推。
请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。

**代码：**

```C++
vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
    if(original.size() != m*n)
        return vector<vector<int>>();
    vector<vector<int>> arr(m);
    for(int i=0;i<original.size();i+=n ){
        vector<int> row(n);
        for(int j=0;j<n;++j){
            row[j] = original[i+j];
        }
        arr[static_cast<int>(i/n)]=row;
    }
    return arr;
}
```



### L136. 只出现一次的数字

**题目**:题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 
说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？



**思路1**：使用哈希表对数组元素进行计数，最后遍历哈希表，找到计数为1的数。

```C++
int singleNumber(vector<int>& nums) {
    std::unordered_map<int,int> d;
    for(int i=0;i<nums.size();++i){
        if(d.find(nums[i])==d.end())
            d.insert({nums[i],1});
        else
            d[nums[i]]++;
    }
    for(auto [num,count] : d) if(count==1) return num;
    return 0;
}
```

**思路2**：使用异或运算。
  如何才能做到线性时间复杂度和常数空间复杂度呢？答案是使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。 
任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。 
任何数和其自身做异或运算，结果是 0，即 a⊕a=0。 
异或运算满足交换律和结合律，即 a⊕b⊕a = b⊕a⊕a = b⊕(a⊕a) = b⊕0=b。
 因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。  

```C++
int singleNumber1(vector<int>& nums) {
    int result =0;
    for(int i=0;i<nums.size();++i)
        result ^= nums[i];
    return result;
}
```





### J39. 数组中出现次数超过一半的数字

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)**:  同L169。

### L169. 多数元素

**题目**：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 
你可以假设数组是非空的，并且给定的数组总是存在多数元素。



**思路1**：采用哈希表（简单粗暴）

```C++
int majorityElement(vector<int>& nums) {
std::unordered_map<int,int> d;
for(int i=0;i<nums.size();++i){
    if(d.find(nums[i])==d.end())
	d.insert({nums[i],1});
    else
	d[nums[i]]++;
}
for(auto [num,count]:d){
    if(count>std::floor(nums.size()/2))
	return num;
}
return 0;
}
```



**思路2**：先排序，排序后数组的中间值肯定是众数。



**思路3**：分治算法。
如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。 
我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l / 2 + r / 2 次，
其中 l 和 r 分别是左半部分和右半部分的长度。由于 l / 2 + r / 2 <= (l + r) / 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。  
这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。  



**思路4**：Boyer-Moore 投票算法（重要）
	Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤： 
我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0； 
我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x： 
如果 x 与 candidate 相等，那么计数器 count 的值增加 1；
如果 x 与 candidate 不等，那么计数器 count 的值减少 1。 
在遍历完成后，candidate 即为整个数组的众数。

```C++
int majorityElement(vector<int>& nums) 
{
    int condidate=nums[0];
    int count=0;
    for(int i=1;i<nums.size();++i){
        if(condidate==nums[i])
            count++;
        else
            count--;
        if(count<0){
            condidate=nums[i];
            count=0;
        }
    }
    return condidate;
}
```







### J40. 最小的k个数

**[题目](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)**：输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

 ```
示例 1：
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]

示例 2：
输入：arr = [0,1,2,1], k = 1
输出：[0]
 ```


限制：

0 <= k <= arr.length <= 10000
0 <= arr[i] <= 10000



**思路1**：排序。

先排序，使得数组从小到大递增；再截取前k个数作为输出。

时间复杂度：O(nlogn)，其中 nn 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。

空间复杂度：O(logn)，排序所需额外的空间复杂度为 O(logn)。



```C++
vector<int> getLeastNumbers(vector<int>& arr, int k) {
    if(k>arr.size())return {};
    std::sort(arr.begin(),arr.end());
    return vector<int>(arr.begin(),arr.begin()+k);
}
```



**思路2**：堆。

​	我们用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。

```C++
vector<int> getLeastNumbers(vector<int>& arr, int k) {
    if (k == 0) return {};
    vector<int> vec(k, 0);
    priority_queue<int> Q;
    for (int i = 0; i < k; ++i) //将k个元素插入到堆中
        Q.push(arr[i]);
    for (int i = k; i < (int)arr.size(); ++i) {//将剩余的元素与堆顶进行比较，再插入到堆中
        if (Q.top() > arr[i]) {
            Q.pop();
            Q.push(arr[i]);
        }
    }
    for (int i = 0; i < k; ++i) {//将元素从堆转移到数组中
        vec[i] = Q.top();
        Q.pop();
    }
    return vec;
}
```

时间复杂度：O(nlogk)，其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 O(logk) 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 O(nlogk) 的时间复杂度。

空间复杂度：O(k)，因为大根堆里最多 k 个数。



**思路3**：快排思想。

我们可以借鉴快速排序的思想。我们知道快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。

我们定义函数 `randomized_selected(arr, l, r, k)` 表示划分数组 arr 的 `[l,r]` 部分，使前 k 小的数在数组的左侧，在函数里我们调用快排的划分函数，假设划分函数返回的下标是 pos（表示分界值 pivot 最终在数组中的位置），即 pivot 是数组中第 pos - l + 1 小的数，那么一共会有三种情况：

* 如果 `pos - l + 1 == k`，表示 `pivot` 就是第 k 小的数，直接返回即可；

* 如果 `pos - l + 1 < k`，表示第 k 小的数在 pivot 的右侧，因此递归调用 `randomized_selected(arr, pos + 1, r, k - (pos - l + 1))`；

* 如果 `pos - l + 1 > k`，表示第 k 小的数在 pivot 的左侧，递归调用 `randomized_selected(arr, l, pos - 1, k)`。

函数递归入口为 `randomized_selected(arr, 0, arr.length - 1, k)`。在函数返回后，将前 k 个数放入答案数组返回即可。

  ```C++
class Solution {
    int partition(vector<int>& nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[i + 1], nums[r]);
        return i + 1;
    }

    // 基于随机的划分
    int randomized_partition(vector<int>& nums, int l, int r) {
        int i = rand() % (r - l + 1) + l;
        swap(nums[r], nums[i]);
        return partition(nums, l, r);
    }

    void randomized_selected(vector<int>& arr, int l, int r, int k) {
        if (l >= r) {
            return;
        }
        int pos = randomized_partition(arr, l, r);
        int num = pos - l + 1;
        if (k == num) {
            return;
        } else if (k < num) {
            randomized_selected(arr, l, pos - 1, k);
        } else {
            randomized_selected(arr, pos + 1, r, k - num);
        }
    }

public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        srand((unsigned)time(NULL));
        randomized_selected(arr, 0, (int)arr.size() - 1, k);
        vector<int> vec;
        for (int i = 0; i < k; ++i) {
            vec.push_back(arr[i]);
        }
        return vec;
    }
};
  ```

**时间复杂度**：期望为 O(n) ，由于证明过程很繁琐，所以不在这里展开讲。具体证明可以参考《算法导论》第 9 章第 2 小节。最坏情况下的时间复杂度为 O(n^2)。情况最差时，每次的划分点都是最大值或最小值，一共需要划分n−1 次，而一次划分需要线性的时间复杂度，所以最坏情况下时间复杂度为 O(n^2)

**空间复杂度**：期望为 O(logn)，递归调用的期望深度为 O(logn)，每层需要的空间为 O(1)，只有常数个变量。

最坏情况下的空间复杂度为 O(n)。最坏情况下需要划分 n 次，即 randomized_selected 函数递归调用最深 n−1 层，而每层由于需要 O(1) 的空间，所以一共需要 O(n) 的空间复杂度。





### L1. 两数之和

**题目**：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，
并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。  



**思路1**：遍历。  

```C++
vector<int> twoSum(vector<int>& nums, int target) {
    for(int i=0;i<nums.size();++i)
        for(int j=i+1;j<nums.size();++j)
            if(nums[i]+nums[j]==target)
                return vector<int>{i,j};
    return vector<int>{0,1};
}
```



**思路2**:哈希表。记录遍历过的值到哈希表。

```C++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int,int> d;
    for(int i=0;i<nums.size();++i){
        if(d.find(target-nums[i])!=d.end())
            return vector<int>{i,d[target-nums[i]]};
        if(d.find(nums[i])==d.end())
            d.insert({nums[i],i});
    }
    return vector<int>{0,1};
}
```



### L167. 两数之和 II - 输入有序数组

**题目**：给定一个已按照 非递减顺序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。



**思路1**：由于给定的是一个排序好的数组，则直接双指针。

```C++
vector<int> twoSum(vector<int>& numbers, int target) {
    for(int i=0,j=numbers.size()-1;i<j;){
        while(i<j && numbers[i]+numbers[j]>target)
            --j;
        if(numbers[i]+numbers[j] == target)
            return vector<int>{i+1,j+1};
        while(i<j && numbers[i]+numbers[j]<target)
            ++i;
    }
    return vector<int>();
}
```



**思路2**：二分查找。对于遍历每个元素numbers[i]，使用二分查找target - numbers[i]即可。时间复杂度为nlogn。





### L15. 三数之和

**题目**：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？
请你找出所有和为 0 且不重复的三元组。 
注意：答案中不可以包含重复的三元组。 

 

**思路1**:遍历法，双重循环，外层单指针，内双指针。时间复杂度O(n^2)  

```C++
int Partition(vector<int> &arr,int low,int high){
    int key=arr[low];
    while(low<high){
        while(low<high && arr[high]>=key)
            high--;
        arr[low]=arr[high];
        while(low<high && arr[low]<=key)
            low++;
        arr[high]=arr[low];
    }
    arr[low]=key;
    return low;
}
void QSort(vector<int> &arr,int low,int high){
    if(low < high){
        int parting = Partition(arr,low,high);
        QSort(arr,low,parting-1);
        QSort(arr,parting+1,high);
    }
}

vector<vector<int>> threeSum(vector<int>& nums) {
    const int n = nums.size();
    vector<vector<int>> output;
    //先排序
    QSort(nums,0,nums.size()-1);
    //外层单指针，内层双指针
    for (int first = 0; first < n; ++first) {
        if (first > 0 && nums[first] == nums[first - 1])  // 需要和上一次枚举的数不相同
            continue;
        int third = n - 1;// c 对应的指针初始指向数组的最右端
        int target = -nums[first];
        for (int second = first + 1; second < n; ++second) {
            if (second > first + 1 && nums[second] == nums[second - 1]) // 需要和上一次枚举的数不相同
                continue;
            while (second < third && nums[second] + nums[third] > target)  // 需要保证 b 的指针在 c 的指针的左侧
                --third;
            if (second == third)
                break;
            if (nums[second] + nums[third] == target)
                output.push_back({nums[first], nums[second], nums[third]});
        }
    }
    return output;
}
```



### L16. 最接近的三数之和

**题目**：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，
使它们的和与 target 最接近。 返回这三个数的和。  
假定每组输入只存在恰好一个解。



**思路1**: 直接暴力解法的时间复杂度时O(n^3)。同上一题一样，内层循环可以用双指针降低复杂度。  
为了使用双指针，需要首先对数组进行排序，复杂度为O(nlogn)。与上一题不同的是，不需要考虑重复的3元组。

```C++
int threeSumClosest(vector<int>& nums, int target) {
    std::sort(nums.begin(),nums.end());
    int closest_sum=0;
    int delta = INT_MAX;
    for(int i=0;i<nums.size();++i){
        int j=i+1,k=nums.size()-1;
        while(j<k){
            int sum = nums[i]+nums[j]+nums[k];
            if(std::abs(target-sum)<delta){
                delta = std::abs(target-sum);
                closest_sum = sum;
                if(delta==0)break;
            }
            if(sum<=target)
                j++;
            else if(sum>target)
                k--;
        }
    }
    return closest_sum;
}
```





### L18. 四数之和

**题目**：
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] 
（若两个四元组元素一一对应，则认为两个四元组重复）：  

* 0 <= a, b, c, d < n

* a、b、c 和 d 互不相同

* nums[a] + nums[b] + nums[c] + nums[d] == target
  你可以按 任意顺序 返回答案 。
  
  

**思路1**: 与L16差不多，外层是两个暴力双循环，内层是一个双指针。为了去掉重复的4元组，这里通过
集合set来保存结果。注意，本题还要考虑数据范围的问题。

```C++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> arr;
    if(nums.size()<4)
        return arr;
    std::set<vector<int>> num_set;
    //排序
    std::sort(nums.begin(),nums.end());
    //内外层双指针
    int n = nums.size();
    for(int i=0;i<n;++i){
        for(int j=i+1;j<n;++j){
            int k=j+1,l= n-1;
            while(k<l){
                int64_t sum = static_cast<int64_t>(nums[i])+static_cast<int64_t>(nums[j])+
                        static_cast<int64_t>(nums[k])+static_cast<int64_t>(nums[l]);
                if(sum==target){
                    num_set.insert({nums[i],nums[j],nums[k],nums[l]});
                    k++;
                }
                else if(sum>target) l--;
                else k++;
            }
        }
    }

    for(auto &v : num_set)
        arr.push_back(v);
    return arr;
}

```





### L724. 寻找数组的中心下标

**题目**：给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。



**思路1**：暴力解法。从左到右遍历每一个可能的中心下标，计算左右两边的和，并判断两边是否相等。

```C++
int pivotIndex(vector<int>& nums) {
    int left_sum=0;
    int right_sum=0;
    for(int j=1;j<nums.size();++j) right_sum+=nums[j];//算法中心下标在0处的情况
    if(right_sum==0) return 0;

    for(int i=0;i<nums.size()-1;++i){
        left_sum+=nums[i];
        right_sum=0;
        for(int j=i+2;j<nums.size();++j) right_sum+=nums[j];
        if(left_sum==right_sum)
            return i+1;
    }
    return -1;
}
```



**思路2**：单层循环。只需要遍历一边中心下标即可，每次迭代时，更新左边的和，右边的和。

```C++
int pivotIndex(vector<int>& nums) {
    int left_sum=0;
    int right_sum=std::accumulate(nums.begin()+1,nums.end(),0);
    for(int i=0;i<nums.size();++i){
        if(left_sum == right_sum) return i;
        if(i==nums.size()-1) break;
        left_sum+=nums[i];
        right_sum -=nums[i+1];
    }
    return -1;
}
```



### L217. 存在重复元素

**[题目](https://leetcode-cn.com/problems/contains-duplicate/)**： 给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。 

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：true
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：false
```

**示例 3：**

```
输入：nums = [1,1,1,3,3,4,3,2,4,2]
输出：true
```

 **提示：**

- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`



**思路1**：先排序，后判断。

在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。

直接调用库函数：

```C++
bool containsDuplicate(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    int n = nums.size();
    for (int i = 0; i < n - 1; i++) {
        if (nums[i] == nums[i + 1]) {
            return true;
        }
    }
    return false;
}
```

手写排序函数：(堆排序)

```C++
void adjust(vector<int> &arr,int len,int index){
    //计算左右孩子的下标
    int left = 2*index+1;
    int right = 2*index+2;
    //判断是否需要调整堆
    int parant = index;
    if(left<len && arr[left]>arr[index] ){
        parant = left;
    }
    if(right<len && arr[right] > arr[parant]){
        parant=right;
    }
    //递归的调整堆
    if(parant!=index){
        std::swap(arr[index],arr[parant]);
        adjust(arr,len,parant);
    }
}

//堆排序
void heapSort(vector<int> &arr,int len){
    //构建最大堆
    for(int i= len/2-1;i>=0;--i){
        adjust(arr,len,i);
    }
    //调整堆排序，得到排序序列
    for(int i=len-1;i>=1;--i){
        std::swap(arr[i],arr[0]);
        adjust(arr,i,0);
    }
}


bool containsDuplicate(vector<int>& nums) {
    heapSort(nums,nums.size());
    for(int i=0;i<nums.size()-1;++i){
        if(nums[i]==nums[i+1]){
            return true;
        }
    }
    return false;
}
```



**思路2**：哈希表。

对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。

```C++
bool containsDuplicate(vector<int>& nums) {
    unordered_set<int> s;
    for (int x: nums) {
        if (s.find(x) != s.end()) 
            return true;
        s.insert(x);
    }
    return false;
}
```



### L219. 存在重复元素 II

**[题目](https://leetcode-cn.com/problems/contains-duplicate-ii/)**: 给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [1,2,3,1], k = 3
输出：true
```

**示例 2：**

```
输入：nums = [1,0,1,1], k = 1
输出：true
```

**示例 3：**

```
输入：nums = [1,2,3,1,2,3], k = 2
输出：false
```

**提示：**

- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`
- `0 <= k <= 10^5`



**思路1**：哈希表。

用哈希表记录每个值最近一次的的索引。若再次遍历到该值时，若索引的差小于等于k，则返回true。

```C++
bool containsNearbyDuplicate(vector<int>& nums, int k) {
    //哈希表
    std::unordered_map<int,int> hash_map;
    int N= nums.size();
    for(int i=0;i<N;++i){
        if(hash_map.find(nums[i])!=hash_map.end()){
            if( i - hash_map[nums[i]] <= k){
                return true;
            }
            else{
                hash_map[nums[i]]=i;
            }
        }
        else{
            hash_map.insert({nums[i],i});
        }
    }
    return false;
}
```

时间复杂度：O(n)，其中 n 是数组nums 的长度。需要遍历数组一次，对于每个元素，哈希表的操作时间都是 O(1)。

空间复杂度：O(n)，其中 n 是数组 nums 的长度。需要使用哈希表记录每个元素的最大下标，哈希表中的元素个数不会超过 n。



**思路2**：滑动窗口。

考虑数组 nums 中的每个长度不超过 k+1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 k。如果存在一个滑动窗口，其中有重复元素，则存在两个不同的下标 i 和 j 满足 nums[i]=nums[j] 且 ∣i−j∣≤k。如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可。

如果一个滑动窗口的结束下标是 i，则该滑动窗口的开始下标是 max(0,i−k)。可以使用哈希集合存储滑动窗口中的元素。从左到右遍历数组 nums，当遍历到下标 i 时，具体操作如下：

如果 i>k，则下标 i−k−1 处的元素被移出滑动窗口，因此将 nums[i−k−1] 从哈希集合中删除；

判断 nums[i] 是否在哈希集合中，如果在哈希集合中则在同一个滑动窗口中有重复元素，返回 true，如果不在哈希集合中则将其加入哈希集合。

当遍历结束时，如果所有滑动窗口中都没有重复元素，返回 false。

```C++
bool containsNearbyDuplicate(vector<int>& nums, int k) {
    unordered_set<int> s;
    int length = nums.size();
    for (int i = 0; i < length; i++) {
        if (i > k) {
            s.erase(nums[i - k - 1]);
        }
        if (s.count(nums[i])) {
            return true;
        }
        s.emplace(nums[i]);
    }
    return false;
}
```

时间复杂度：O(n)，其中 n 是数组 nums 的长度。需要遍历数组一次，对于每个元素，哈希集合的操作时间都是 O(1)。

空间复杂度：O(k)，其中 k 是判断重复元素时允许的下标差的绝对值的最大值。需要使用哈希集合存储滑动窗口中的元素，任意时刻滑动窗口中的元素个数最多为 k+1 个。





### L220. 存在重复元素 III

[题目](https://leetcode-cn.com/problems/contains-duplicate-iii/)：给你一个整数数组 `nums` 和两个整数 `k` 和 `t` 。请你判断是否存在 **两个不同下标** `i` 和 `j`，使得 `abs(nums[i] - nums[j]) <= t` ，同时又满足 `abs(i - j) <= k` 。

如果存在则返回 `true`，不存在返回 `false`。

**示例 1：**

```
输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
```

**示例 2：**

```
输入：nums = [1,0,1,1], k = 1, t = 2
输出：true
```

**示例 3：**

```
输入：nums = [1,5,9,1,5,9], k = 2, t = 3
输出：false
```

 **提示：**

- `0 <= nums.length <= 2 * 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `0 <= k <= 10^4`
- `0 <= t <= 2^31 - 1`



**思路1**：







### L523. 连续的子数组和

[题目](https://leetcode-cn.com/problems/continuous-subarray-sum/)：给你一个整数数组 `nums` 和一个整数 `k` ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

- 子数组大小 **至少为 2** ，且
- 子数组元素总和为 `k` 的倍数。

如果存在，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `n` ，令整数 `x` 符合 `x = n * k` ，则称 `x` 是 `k` 的一个倍数。`0` 始终视为 `k` 的一个倍数。

**示例 1：**

```
输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。
```

**示例 2：**

```
输入：nums = [23,2,6,4,7], k = 6
输出：true
解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 
42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。
```

**示例 3：**

```
输入：nums = [23,2,6,4,7], k = 13
输出：false
```

 **提示：**

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 109`
- `0 <= sum(nums[i]) <= 231 - 1`
- `1 <= k <= 231 - 1`



**思路1**：动态规划（超时）。

`dp[i][j]`表示nums[i,j]的数组和。

```C++
bool checkSubarraySum(vector<int>& nums, int k) {
    int N=nums.size();
    //dp[i,j]表示nums[i,j]的数组和
    vector<vector<int>> dp(N,vector<int>(N));
    for(int i=0;i<N;++i){
        for(int j=i;j<N;++j){
            if(i==j){
                dp[i][j]=nums[i];
            }
            else{
                dp[i][j] = dp[i][j-1] + nums[j];
            }
            if(j-i+1 >=2 && (dp[i][j]==0 || dp[i][j] % k==0))
                return true;
        }
    }
    return false;
}
```



**思路2**：哈希表+前缀和

朴素的思路是遍历数组 nums 的每个大小至少为 2 的子数组并计算每个子数组的元素和，判断是否存在一个子数组的元素和为 k 的倍数。当数组 nums 的长度为 m 时，上述思路需要用 O(m^2) 的时间遍历全部子数组，对于每个子数组需要 O(m) 的时间计算元素和，因此时间复杂度是 O(m^3)，会超出时间限制，因此必须优化。

如果事先计算出数组 nums 的前缀和数组，则对于任意一个子数组，都可以在 O(1) 的时间内得到其元素和。用 prefixSums[i] 表示数组 nums 从下标 0 到下标 i 的前缀和，则 nums 从下标 p+1 到下标 q（其中 p<q）的子数组的长度为 q−p，该子数组的元素和为 prefixSums[q]−prefixSums[p]。

如果 prefixSums[q]−prefixSums[p] 为 k 的倍数，且 q−p≥2，则上述子数组即满足大小至少为 2 且元素和为 k 的倍数。

当 prefixSums[q]−prefixSums[p] 为 k 的倍数时，prefixSums[p] 和 prefixSums[q] 除以 k 的余数相同。因此只需要计算每个下标对应的前缀和除以 k 的余数即可，使用哈希表存储每个余数第一次出现的下标。

规定空的前缀的结束下标为 −1，由于空的前缀的元素和为 0，因此在哈希表中存入键值对 (0,−1)。对于 0≤i<m，从小到大依次遍历每个 i，计算每个下标对应的前缀和除以 k 的余数，并维护哈希表：

* 如果当前余数在哈希表中已经存在，则取出该余数在哈希表中对应的下标 prevIndex，nums 从下标 prevIndex+1 到下标 i 的子数组的长度为 i−prevIndex，该子数组的元素和为 k 的倍数，如果 i−prevIndex≥2，则找到了一个大小至少为 2 且元素和为 k 的倍数的子数组，返回 true；

* 如果当前余数在哈希表中不存在，则将当前余数和当前下标 i 的键值对存入哈希表中。

由于哈希表存储的是每个余数第一次出现的下标，因此当遇到重复的余数时，根据当前下标和哈希表中存储的下标计算得到的子数组长度是以当前下标结尾的子数组中满足元素和为 k 的倍数的子数组长度中的最大值。只要最大长度至少为 2，即存在符合要求的子数组。

```C++
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int m = nums.size();
        if (m < 2) {
            return false;
        }
        unordered_map<int, int> mp;
        mp[0] = -1;
        int remainder = 0;
        for (int i = 0; i < m; i++) {
            remainder = (remainder + nums[i]) % k;//前缀和的余数
            if (mp.count(remainder)) {
                int prevIndex = mp[remainder];
                if (i - prevIndex >= 2) {
                    return true;
                }
            } 
            else {
                mp[remainder] = i;
            }
        }
        return false;
    }
};
```

时间复杂度：O(m)，其中 m 是数组 nums 的长度。需要遍历数组一次。

空间复杂度：O(min(m,k))，其中 m 是数组 nums 的长度。空间复杂度主要取决于哈希表，哈希表中存储每个余数第一次出现的下标，最多有 min(m,k) 个余数。





### L560. 和为K的子数组

[题目](https://leetcode-cn.com/problems/subarray-sum-equals-k/)：给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 该数组中和为 `k` 的子数组的个数 。

 **示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

 **提示：**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-107 <= k <= 107`



**思路1**：动态规划（超时）

```C++
int subarraySum(vector<int>& nums, int k) {
    int N=nums.size();
    vector<vector<int>> dp(N,vector<int>(N));
    int cnt=0;
    for(int i=0;i<N;++i){
        for(int j=i;j<N;++j){
            if(i==j){
                dp[i][j] = nums[i];
            }
            else{
                dp[i][j] = dp[i][j-1] + nums[j];
            }
            if(dp[i][j]==k){
                cnt++;
            }
        }
    }
    return cnt;
}
```



**思路2**：滑动窗口。







## 数组的元素删除

### L27. 移除元素

**[题目](https://leetcode-cn.com/problems/remove-element/)**:  给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

说明:

```
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);
// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

示例：

```
示例 1：
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

示例 2：
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```


提示：

0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100



**思路1**：双指针。

由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。

如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；

如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。

整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。

这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次。

```C++
int removeElement(vector<int>& nums, int val) {
    int left=0;
    for(int right=0;right<nums.size();++right){
        if(nums[right]!=val){
            nums[left]=nums[right];
            ++left;
        }
    }
    return left;
}
```



**思路：双指针优化**

​	 如果要移除的元素恰好在数组的开头，例如序列 `[1,2,3,4,5]`，当 val 为 1 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 `[5,2,3,4]`，同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。

​	实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。

   如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。

当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。

这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。

```C++
int removeElement(vector<int>& nums, int val) {
    int left = 0, right = nums.size();
    while (left < right) {
        if (nums[left] == val) {
            nums[left] = nums[right - 1];
            right--;
        } else {
            left++;
        }
    }
    return left;
}
```



### L26. 删除有序数组中的重复项

**[题目](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)**：





### L80. 删除有序数组中的重复项 II

**[题目](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)**：





## 数组的合并和拆分



### J21. 调整数组顺序使奇数位于偶数前面

**[题目](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)**:  输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

 ```
示例：

输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
 ```


提示：

0 <= nums.length <= 50000
0 <= nums[i] <= 10000



**思路1**：首尾双指针，额外数组。

```C++
vector<int> exchange(vector<int>& nums) {
    vector<int> arr(nums.size());
    int index_o=0,index_e=nums.size()-1;
    for(int i=0;i<nums.size();++i){
        if(nums[i]%2==1){
            arr[index_o]=nums[i];
            index_o++;
        }
        else{
            arr[index_e]=nums[i];
            index_e--;
        }
    }
    return arr;
}
```



**思路2**：首尾双指针，原地交换。

```C++
vector<int> exchange(vector<int>& nums) {
    int left=0,right=nums.size()-1;
    while(left<right){
        while(left<right && nums[left]%2==1)left++;
        while(left<right && nums[right]%2==0)right--;
        std::swap(nums[left],nums[right]);
        left++;
        right--;
    }
    return nums;
}
```



**思路3**：快慢双指针。

定义快慢双指针 fast 和 low ，fast 在前， low 在后 .
fast的作用是向前搜索奇数位置，low 的作用是指向下一个奇数应当存放的位置
fast 向前移动，当它搜索到奇数时，将它和 nums[low] 交换，此时 low 向前移动一个位置 .
重复上述操作，直到 fast 指向数组末尾 .

```C++
vector<int> exchange(vector<int>& nums) {
    int low = 0, fast = 0;
    while (fast < nums.size()) {
        if (nums[fast] & 1) {
            swap(nums[low], nums[fast]);
            low ++;
        }
        fast ++;
    }
    return nums;
}
```







### L349. 两个数组的交集

**题目**: 给定两个数组，编写一个函数来计算它们的交集。 

说明：

- 输出结果中的每个元素一定是唯一的。

- 我们可以不考虑输出结果的顺序。

  

**思路1**：使用两个哈希集合，第一个哈希集合存放第一个数组的元素，第二个哈希集合存放 交集元素。最后再把第二个哈希集合转移到输出数组中。

```C++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    std::unordered_set<int> hash_set,out_set;
    std::vector<int> arr;
    for(int i=0;i<nums1.size();++i)
        hash_set.insert(nums1[i]);
    for(int i=0;i<nums2.size();++i)
        if(hash_set.count(nums2[i])>0)
            out_set.insert(nums2[i]);
    for(auto e:out_set) arr.push_back(e);
    return arr;
}
```



**思路2**： 排序+双指针。首先对两个数组进行排序，然后分别对两个数组设置一个指针，用于指向正在比较的数组的元素。对于每个指针，还需要判断去掉重复的元素。

```C++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    std::sort(nums1.begin(),nums1.end());
    std::sort(nums2.begin(),nums2.end());
    vector<int> arr;
    for(int i=0,j=0;i<nums1.size()&&j<nums2.size();){
        if(i>0 && nums1[i]==nums1[i-1]){
            ++i;
            continue;
        }
        if(j>0 && nums2[j]==nums2[j-1]){
            ++j;
            continue;
        }
        if(nums1[i]==nums2[j]){
            arr.push_back(nums1[i]);
            ++i;
            ++j;
        }
        else if(nums1[i]<nums2[j]){
            ++i;
        }
        else{
            ++j;
        }
    }
    return arr;
}
```





### L56. 合并区间

**题目**：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。



**思路1**：暴力法，双重循环比较两个之间是否重叠。该方法会“超出时间限制”。

**思路2**：（这道题第9次提交才对）首先对输入的区间数组进行排序，则重叠的区间肯定相邻。遍历一遍，对相邻重叠区间进行合并。当第i个区间与i+1个区间不相邻时，将第i个区间添加到输出数组。

```C++
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    int n=intervals.size();
    if(n==1)
        return vector<vector<int>>{intervals[0]};
    std::sort(intervals.begin(),intervals.end());
    vector<vector<int>> output;
    for(int i=0;i<intervals.size()-1;++i){
        if(intervals[i][1]>=intervals[i+1][0]){//i和i+1重叠
            intervals[i+1][0] = intervals[i][0];
            intervals[i+1][1] = std::max(intervals[i][1],intervals[i+1][1]);
        }else{
            output.push_back(intervals[i]);
        }
    }
    if(intervals[n-2][1]>=intervals[n-1][0]){//n-1和n-2重叠
        intervals[n-1][0] = intervals[n-2][0];
        intervals[n-1][1] = std::max(intervals[n-2][1],intervals[n-1][1]);
    }
    output.push_back(intervals[n-1]);
    return output;
}
```



### L228. 汇总区间

[题目](https://leetcode-cn.com/problems/summary-ranges/)：给定一个  **无重复元素** 的 **有序** 整数数组 `nums` 。

返回 ***恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表* 。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。

列表中的每个区间范围 `[a,b]` 应该按如下格式输出：

- `"a->b"` ，如果 `a != b`
- `"a"` ，如果 `a == b`

**示例 1：**

```
输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

**示例 2：**

```
输入：nums = [0,2,3,4,6,8,9]
输出：["0","2->4","6","8->9"]
解释：区间范围是：
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

**提示：**

- `0 <= nums.length <= 20`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中的所有值都 **互不相同**
- `nums` 按升序排列



**思路1**：直接判断。

遍历数组，判断某个元素是否等于 上一个元素的+1，若不相等，则添加 ->和终点。

代码如下：

```C++
vector<string> summaryRanges(vector<int>& nums) {
    if(nums.empty())
        return {};
    vector<string> output;
    int N=nums.size();
    int start = nums[0];
    output.push_back(std::to_string(nums[0]));
    for(int i=1;i<nums.size();++i){
        if(nums[i]!=nums[i-1]+1){
            if(start != nums[i-1])
                output[output.size()-1] += ("->"+std::to_string(nums[i-1]));
            output.push_back(std::to_string(nums[i]));
            start=nums[i];
        }
    }
    if(start != nums[N-1]){
        output[output.size()-1] += ("->"+std::to_string(nums[N-1]));
    }
    return output;
}
```









### L561. 数组拆分I

**题目**：给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。

返回该 最大总和 。

```
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```



**思路1**：首先进行排序，得到升序数组，0-1,2-3, 4-5 ...划分为一组。因此结果为第0个、第2个、第4个...元素的和。

```C++
int arrayPairSum(vector<int>& nums) {
    std::sort(nums.begin(),nums.end());
    int sum=0;
    for(int i=0;i<nums.size();i+=2)
        sum+=nums[i];
    return sum;
}
```





## 矩阵的搜索

### J04. 二维数组中的查找

**[题目](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)**: 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 ```
示例:
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
 ```

限制：

0 <= n <= 1000

0 <= m <= 1000



**思路1**：暴力法。

遍历二维数组，时间复杂度O(n*m)



**思路2**：线性查找法。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。

若数组为空，返回 false
初始化行下标为 0，列下标为二维数组的列数减 1
重复下列步骤，直到行下标或列下标超出边界
获得当前下标位置的元素 num
如果 num 和 target 相等，返回 true
如果 num 大于 target，列下标减 1
如果 num 小于 target，行下标加 1
循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false

```C++
bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
    if(matrix.empty()) return false;
    for(int i=0,j=matrix[0].size()-1;i<matrix.size() && j>=0;){
        if(matrix[i][j]==target)
            return true;
        else if(matrix[i][j]<target)
            ++i;
        else if(matrix[i][j]>target)
            --j;
    }
    return false;
}
```





### J29. 顺时针打印矩阵

**[题目](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)**: 同上L54

### L54. 螺旋矩阵

**[题目](https://leetcode-cn.com/problems/spiral-matrix/)**：给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 ```
示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
 ```

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
示例 2：
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

提示：

```
m == matrix.length
n == matrix[i].length
1 <= m, n <= 10
-100 <= matrix[i][j] <= 100
```



**思路1**：观察法。

观察下面的例子：

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

可知，打印的顺序为：

```
1 2 3 4
8 12
11 10 9
5
6 7
```

设矩阵的宽为cols, 高为rows，则每一圈，各步骤打印的长度为：

```
cols
rows-1
cols-1
rows-2
```

根据这个规律，得到的代码如下：

```C++
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    int rows=matrix.size(),cols=matrix[0].size();
    int size = rows*cols;
    vector<int> arr;
    int r=0,c=0;//（r,c）表示每一步的起点
    rows--;
    while(true){
        //printf("r:%d c:%d rows:%d cols:%d\n",r,c,rows,cols);
        for(int i=0;i<cols;++i)arr.push_back(matrix[r][c+i]);
        c+= cols-1;
        r++;
        cols--;
        if(arr.size()==size)break;

        for(int i=0;i<rows;++i)arr.push_back(matrix[r+i][c]);
        c--;
        r += rows-1;
        rows--;
        if(arr.size()==size)break;

        for(int i=0;i<cols;++i)arr.push_back(matrix[r][c-i]);
        c -= (cols-1);
        r--;
        cols--;
        if(arr.size()==size)break;

        for(int i=0;i<rows;++i)arr.push_back(matrix[r-i][c]);
        c++;
        r -= (rows-1);
        rows--;
        if(arr.size()==size)break;
    }
    return arr;
}
```



**思路2**：模拟螺旋矩阵的路径。

可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。

判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 \textit{visited}visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 \textit{visited}visited 中的对应位置的元素设为已访问。

如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

```C++
class Solution {
private:
    static constexpr int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0)
            return {};
        int rows = matrix.size(), columns = matrix[0].size();
        //辅助数组，标志是否访问过该元素
        vector<vector<bool>> visited(rows, vector<bool>(columns));
        int total = rows * columns;
        vector<int> order(total);
        int row = 0, column = 0;
        int directionIndex = 0;
        for (int i = 0; i < total; i++) {
            order[i] = matrix[row][column];
            visited[row][column] = true;
            //判断是否应该转换方向
            int nextRow = row + directions[directionIndex][0];
            int nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn])
                directionIndex = (directionIndex + 1) % 4;//换一个方向
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
};
```



**思路3**：按层遍历。

可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。

定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。

```
[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]
```

​	对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 (top,left)，右下角位于(bottom,right)，按照如下顺序遍历当前层的元素。从左到右遍历上侧元素，依次为 (top,left) 到(top,right)。

从上到下遍历右侧元素，依次为(top+1,right) 到 (bottom,right)。

如果 left<right 且top<bottom，则从右到左遍历下侧元素，依次为(bottom,right−1) 到 (bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到 (top+1,left)。

遍历完当前层的元素之后，将 left 和top 分别增加 11，将right 和 bottom 分别减少 11，进入下一层继续遍历，直到遍历完所有元素为止。

```c++
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    if(matrix.size()==0 || matrix[0].size()==0) return {};
    int rows=matrix.size(), cols=matrix[0].size();
    vector<int> arr;
    int left=0,right=cols-1,top=0,bottom=rows-1;
    while(left<=right && top<=bottom){
        //从左上角到右上角
        for(int i=left;i<=right;++i) arr.push_back(matrix[top][i]);
        //从右上角到右下角
        for(int i=top+1;i<=bottom;++i) arr.push_back(matrix[i][right]);
        if(left==right || top==bottom) //为了防止重复遍历
            break;
        //从右下角到左下角
        for(int i=right-1;i>=left;--i) arr.push_back(matrix[bottom][i]);
        //从左下角到左上角
        for(int i=bottom-1;i>top;--i) arr.push_back(matrix[i][left]);
        top++;
        bottom--;
        left++;
        right--;
    }
    return arr;
}
```





### L73. 矩阵置零

**[题目](https://leetcode-cn.com/problems/set-matrix-zeroes/)**：给给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

 示例 1：

![](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)

输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]



示例 2：

![](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)

输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]




提示：

```
m == matrix.length
n == matrix[0].length
1 <= m, n <= 200
-2^31 <= matrix[i][j] <= 2^31 - 1
```



**思路1**：使用标记数组，需要m+n额外空间

我们可以用两个标记数组分别记录每一行和每一列是否有零出现。

具体地，我们首先遍历该数组一次，如果某个元素为 0，那么就将该元素所在的行和列所对应标记数组的位置置为 true。最后我们再次遍历该数组，用标记数组更新原数组即可。

```C++
void setZeroes(vector<vector<int>>& matrix) {
    //暴力法：使用额外m+n的空间
    int rows=matrix.size();
    int cols=matrix[0].size();

    vector<int> row_used(rows);
    vector<int> col_used(cols);

    for(int i=0;i<rows;++i){
        for(int j=0;j<cols;++j){
            if(matrix[i][j]==0){
                row_used[i]=1;
                col_used[j]=1;
            }
        }
    }

    for(int i=0;i<rows;++i){
        for(int j=0;j<cols;++j){
            if(row_used[i]==1 || col_used[j]==1){
                matrix[i][j]=0;
            }
        }
    }
}
```



**方法2**：使用两个标记变量。

我们可以用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。

在实际代码中，我们首先预处理出两个标记变量，接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。

```C++
void setZeroes(vector<vector<int>>& matrix) {
    int m = matrix.size();
    int n = matrix[0].size();
    //两个标记变量
    int flag_col0 = false, flag_row0 = false;
    //判断第一列是否存在0
    for (int i = 0; i < m; i++) {
        if (!matrix[i][0]) 
            flag_col0 = true;
    }
    //判断第2列是否存在0
    for (int j = 0; j < n; j++) {
        if (!matrix[0][j]) 
            flag_row0 = true;
    }
    //将其它列和其它行是否有0的信息放到第一列和第一行
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (!matrix[i][j]) {
                matrix[i][0] = matrix[0][j] = 0;
            }
        }
    }
    //根据第1列和第1行的信息，清空其它区域
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (!matrix[i][0] || !matrix[0][j]) {
                matrix[i][j] = 0;
            }
        }
    }
    //根据第1行和第一列本来是否存在0，决定是否清空
    if (flag_col0) {
        for (int i = 0; i < m; i++) {
            matrix[i][0] = 0;
        }
    }
    if (flag_row0) {
        for (int j = 0; j < n; j++) {
            matrix[0][j] = 0;
        }
    }
}
```



**思路3**：使用一个标记变量

我们可以对方法二进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，我们需要从最后一行开始，倒序地处理矩阵元素。

```C++
void setZeroes(vector<vector<int>>& matrix) {
    int m = matrix.size();
    int n = matrix[0].size();
    int flag_col0 = false;
    for (int i = 0; i < m; i++) {
        if (!matrix[i][0]) 
            flag_col0 = true;
        for (int j = 1; j < n; j++) {
            if (!matrix[i][j]) 
                matrix[i][0] = matrix[0][j] = 0;
        }
    }
    for (int i = m - 1; i >= 0; i--) {
        for (int j = 1; j < n; j++) {
            if (!matrix[i][0] || !matrix[0][j]) 
                matrix[i][j] = 0;
        }
        if (flag_col0) 
            matrix[i][0] = 0;
    }
}
```





### L304. 二维区域和检索-矩阵不可变 & JII13. 二维子矩阵的和

[题目](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)：给定一个二维矩阵 `matrix`，以下类型的多个请求：

- 计算其子矩形范围内元素的总和，该子矩阵的 **左上角** 为 `(row1, col1)` ，**右下角** 为 `(row2, col2)` 。

实现 `NumMatrix` 类：

- `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化
- `int sumRegion(int row1, int col1, int row2, int col2)` 返回 **左上角** `(row1, col1)` 、**右下角** `(row2, col2)` 所描述的子矩阵的元素 **总和** 。

**示例 1：**

<img src="https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png" alt="img" style="zoom: 67%;" />

```
输入: 
["NumMatrix","sumRegion","sumRegion","sumRegion"]
[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]
输出: 
[null, 8, 11, 12]

解释:
NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)
```

 **提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 200`
- `-105 <= matrix[i][j] <= 10^5`
- `0 <= row1 <= row2 < m`
- `0 <= col1 <= col2 < n`
- 最多调用 `10^4` 次 `sumRegion` 方法



**思路1**：预计算每个元素到左上角的区域的面积和。

<img src="https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png" alt="img" style="zoom: 67%;" />

​	比如为了计算 `numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)`，可以分别计算

* 整体区域：sumRegion(0, 0, 2, 2)；
* 左边的区域：sumRegion(0, 0, 2, 0)；
* 顶部的区域：sumRegion(0, 0, 0, 2)；
* 左上区域：sumRegion(0, 0, 0, 0)；

  则结果为：ans = sumRegion(0, 0, 2, 2) - sumRegion(0, 0, 2, 0) - sumRegion(0, 0, 0, 2) + sumRegion(0, 0, 0, 0)。

```C++
class NumMatrix {
private:
    vector<vector<int>> arr;
    int rows,cols;
public:
    NumMatrix(vector<vector<int>>& matrix) {
        rows = matrix.size();
        cols = matrix[0].size();
        arr = vector<vector<int>>(rows,vector<int>(cols));

        //预计算
        arr[0][0] = matrix[0][0];
        for(int i=1;i<rows;++i)
            arr[i][0] = arr[i-1][0] + matrix[i][0];
        for(int i=1;i<cols;++i)
            arr[0][i] = arr[0][i-1] + matrix[0][i];
        for(int i=1;i<rows;++i){
            for(int j=1;j<cols;++j){
                arr[i][j] = arr[i-1][j] + arr[i][j-1] + matrix[i][j] - arr[i-1][j-1];
            }
        }

        for(int i=0;i<rows;++i){
            for(int j=0;j<cols;++j){
                cout<<arr[i][j]<<" ";
            }
            cout<<endl;
        }
    }
    
    int sumRegion(int row1, int col1, int row2, int col2) {
        int left_area=0;
        if(col1>0) left_area= arr[row2][col1-1];
        int top_area = 0;
        if(row1>0) top_area = arr[row1-1][col2];
        int left_top_area=0;
        if(row1>0 && col1>0) left_top_area = arr[row1-1][col1-1];
        int right_bottom_area = arr[row2][col2];
        return right_bottom_area - left_area - top_area + left_top_area;
    }
};
```



 [二维区域和检索 - 矩阵不可变 - 二维区域和检索 - 矩阵不可变 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/) 







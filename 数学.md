







# 数学

## 基础知识



### 质数

**质数的定义**：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x−1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)。

```C++
bool isPrime(int x) {
    for (int i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            return false;
        }
    }
    return true;
}
```



#### 所有小于非负整数 n 的质数的数量

算法：**埃氏筛**

该算法由希腊数学家厄拉多塞提出，称为厄拉多塞筛法，简称埃氏筛。

我们考虑这样一个事实：**如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数**，因此我们可以从这里入手。

我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为**合数**（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。

这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。

当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们**从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了**，例如 2 的所有倍数，3 的所有倍数等。

```C++
int countPrimes(int n) {
    vector<int> isPrime(n, 1);
    int ans = 0;
    for (int i = 2; i < n; ++i) {
        if (isPrime[i]) {
            ans += 1;
            if ((long long)i * i < n) {
                for (int j = i * i; j < n; j += i) {
                    isPrime[j] = 0;
                }
            }
        }
    }
    return ans;
}
```

时间复杂度：$O(nloglogn)$。具体证明这里不再展开，读者可以自行思考或者上网搜索，本质上是要求解 $\sum_{p}\frac{n}{p}$   的和，其中 p 为质数。当然我们可以了解这个算法一个比较松的上界 O(nlogn) 怎么计算，这个等价于考虑 $\sum_{i=1}^{n}\frac{n}{i}$

  的和，而 $O(\sum_{i=1}^{n}\frac{n}{i}) = O(n\sum_{i=1}^{n}\frac{1}{i})$，而 1 到 n 中所有数的倒数和趋近于 logn，因此 $O(n\sum_{i=1}^{n}\frac{1}{i})=O(n\log n)$
空间复杂度：O(n)。我们需要 O(n) 的空间记录每个数是否为质数。









### 最大公约数、最小公倍数、互质

参考 [知乎](https://zhuanlan.zhihu.com/p/77669220)

**最大公约数**

•几个数公有的约数，叫做这几个数的公约数，其中最大的一个叫做这几个数的最大公约数

•数学上，a和b的最大公约数记为(a, b)

•编程中，计算两个数最大公约数的方法通常记为gcd(a,b)

**最小公倍数**

•几个数公有的倍数，叫做这几个数的公倍数，其中最小的一个叫做这几个数的最小公倍数

•数学上，a和b的最小公倍数记为[a,b]

•编程中，计算两个数最小公倍数的方法通常记为lcm(a,b)

**性质**：

•a x b = gcd(a, b) * lcm(a,b)

**互质**

•如果两个数的最大公约数是1，则称这两个数互质

下面看如何求两个数的最大公约数和最小公倍数

#### 分解质因数法

例：求24和60的最大公约数与最小公倍数

每个合数都可以写成几个质数相乘的形式：

> 24=2x2x2x3
>
> 60=2x2x3x5

**最大公约数**是两个数所有公有质因数的乘积：24和60公有的质因数是2、2、3，所以24和60的最大公约数是2x2x3=12

**最小公倍数**是两个数所有公有质因数和其各自独有质因数的乘积：24和60公有的质因数是2、2、3，24的独有质因数是2，60的独有质因数是5，所以24和60的最小公倍数是2x2x3x2x5=120

#### 短除法

例：求24和60的最大公约数与最小公倍数

![](https://pic2.zhimg.com/80/v2-fca390e61e2d4cac6a239f9f924d98f5_1440w.jpg) 

24和60的最大公约数为2x2x3=12（左侧3个数之积）

24和60的最小公倍数为2x2x3x2x5=120（左侧3个数和下面2个数之积）



#### 辗转相除法（欧几里德算法）

算法步骤：

> 1.输入两个正整数m, n(m>n)
>
> 2.计算m除以n的余数r
>
> 3.m=n, n=r
>
> 4.若r＝0, 则m和n的最大公因数等于m；否则转到第2步
>
> 5.输出最大公因数m
>
> 

例：求24和60的最大公约数与最小公倍数

60 %24 = 12

24 %12 = 0

24和60的最大公约数是12

a x b = gcd(a, b) x lcm(a,b) —》 lcm(a,b) = a x b / gcd(a, b)

24和60的最小公倍数=24x60/12=120



主要代码：

递归：

```C++
int gcd(int a, int b){ 
    return (b==0) ? a : gcd(b, a%b); 
}
```

非递归：

```C++
int gcd(int a, int b){
    int t=a%b;
    while(t){
	    a=b;
    	b=t;
    	t=a%b;
    }
    return b;
}

int lcm(inta, int b){ 
    return a/gcd(a, b)*b; 
}
```



或

**辗转相除法**又叫欧几里得算法,是欧几里得最先提出来的.辗转相除法的实现,是基于下面的原理(在这里用(a,b)表示a和b的最大公因数)：

> 　　(a,b)=(a,ka+b),其中a、b、k都为自然数

　也就是说,两个数的最大公约数,将其中一个数加到另一个数上,得到的新数,其公约数不变,比如(4,6)=(4+6,6)=(4,6+2×4)=2.

​    要证明这个原理很容易：如果p是a和ka+b的公约数,p整除a,也能整除ka+b.那么就必定要整除b,所以p又是a和b的公约数,从而证明他们的最大公约数也是相等的.
　　基于上面的原理,就能实现我们的迭代相减法：

```
(78,14)=(64,14)=(50,14)=(36,14)=(22,14)=(8,14)=(8,6)=(2,6)=(2,4)=(2,2)=(0,2)=2
```

　　**基本上思路就是大数减去小数,一直减到能算出来为止**,在作为练习的时候,往往进行到某一步就已经可以看出得值.迭代相减法简单,不过步数比较多,实际上我们可以看到,在上面的过程中,由(78,14)到(8,14)完全可以一步到位,因为(78,14)=(14×5+8,14)=(8,14),由此就诞生出我们的辗转相除法.
　　用辗转相除法求(a,b).设r0=b,r1=a,反复运用除法算式,得到一系列整数qi,ri和下面的方程：
　　相当于每一步都运用原理①把数字进行缩小,上面右边就是每一步对应的缩小结果,可以看出,最后的余数rn就是a和b的公约数.迭代相减法和辗转相除法在本质上是一样的,相对来说,减法比较简单（需要10步）,但是除法步数少（仅需4步）.





## 常见知识点

### 判断两个数是否互质

```C++
///辗转相除法
bool isrp(int a, int b) {
    if (a == 1 || b == 1)     // 两个正整数中，只有其中一个数值为1，两个正整数为互质数
        return true;
    while (true) {          // 求出两个正整数的最大公约数
        int t = a % b;
        if (t == 0) {
            break;
        }
        else {
            a = b;
            b = t;
        }
    }
    if (b > 1) 
        return false;// 如果最大公约数大于1，表示两个正整数不互质
    else 
        return true;    // 如果最大公约数等于1,表示两个正整数互质
}
```



### 逆波兰表达式

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

* 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
* 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中



### 快速幂法

「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ ，我们可以按照：$x \to x^2 \to x^4 \to x^8 \to x^{16} \to x^{32} \to x^{64}$的顺序，从 x 开始，每次直接把上一次的结果进行平方，计算 66 次就可以得到 $x^{64}$ 的值，而不需要对 x 乘 63 次 x。

​	再举一个例子，如果我们要计算 $x^{77}$，我们可以按照：

 $x \to x^2 \to x^4 \to x^9 \to x^{19} \to x^{38} \to x^{77}$ 

的顺序，在 $x \to x^2，x^2 \to x^4，x^{19} \to x^{38}$ 这些步骤中，我们直接把上一次的结果进行平方，而在 $x^4 \to x^9$，$x^9 \to x^{19}$，$x^{38} \to x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。

直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：

* 当我们要计算 $x^n$ 时，我们可以先递归地计算出 $y = x^{\lfloor n/2 \rfloor}$，其中 $\lfloor a \rfloor$表示对 a 进行下取整；

* 根据递归计算的结果，如果 n 为偶数，那么 $x^n = y^2$；如果 n 为奇数，那么 $x^n = y^2 \times x$；

* 递归的边界为 n = 0，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 $O(\log n)$，算法可以在很快的时间内得到结果。

```c++
class Solution {
private:
   	double quickMul(double x, long long N) {
        if (N == 0)
            return 1.0;
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }
public:
    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```





## 数字

### L9. 回文数

**[题目](https://leetcode-cn.com/problems/palindrome-number/)**：给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

例如，121 是回文，而 123 不是。

```
示例 1：
输入：x = 121
输出：true

示例 2：
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

示例 3：
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```


提示：

-2^31 <= x <= 2^31 - 1



**思路**：翻转一半。

映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。

第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。
但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。

按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。

**算法**

首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。

现在，让我们来考虑如何反转后半部分的数字。

对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

```C++
bool isPalindrome(int x) {
    // 特殊情况：如上所述，当 x < 0 时，x 不是回文数。同样地，如果数字的最后一位是 0，为了使该数字为回文，则其第一位数字也应该是 0 只有 0 满足这一属性
    if (x < 0 || (x % 10 == 0 && x != 0)) {
        return false;
    }
    int revertedNumber = 0;
    while (x > revertedNumber) {
        revertedNumber = revertedNumber * 10 + x % 10;
        x /= 10;
    }
    // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
    // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
    // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
    return x == revertedNumber || x == revertedNumber / 10;
}
```









### L202. 快乐数

**题目**：编写一个算法来判断一个数 `n` 是不是快乐数。

「快乐数」定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果 **可以变为** 1，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。

```
输入：n = 19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```



**思路1**：通过哈希集合std::unordered_set记录每次迭代中中平方和num，若发现哈希集合中已经存在了该值，则返回false。

```C++
bool isHappy(int n) {
    if(n==1)
        return true;
    else if(n==0)
        return false;
    int num=0;
    std::unordered_set<int> hash_set;
    while(true){
        while(n>0){//split
            num += std::pow(n%10,2);
            n/=10;
        }
        if(num==1)
            return true;
        if(hash_set.count(num)>0)
            return false;
        hash_set.insert(num);
        n=num;
        num=0;
    }
    return false;
}
```

**思路2**：使用快慢指针法。通过反复调用 getNext(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 getNext(n) 函数获得。

意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。

不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。

我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。

如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。

如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。



### L507. 完美数

**[题目]( [507. 完美数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/perfect-number/) )**：对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true；否则返回 false。

```
示例 1：
输入：num = 28
输出：true
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。

示例 2：
输入：num = 7
输出：false
```


提示：

1 <= num <= 10^8



**思路1**：直接判断法。

将整数的所有正因子求和，判断是否与自身相等即可。

```C++
bool checkPerfectNumber(int num) {
    int iter_max=std::sqrt(num);
    int factor_sum=1;
    for(int i=2;i<=iter_max;++i){
        if(num%i==0){
            factor_sum+=(i+num/i);
        }
    }
    if(num==1)
        return false;
    else
        return factor_sum==num;
}
```









### L263. 丑数

**[题目](https://leetcode-cn.com/problems/ugly-number/)**：给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

 ```
示例 1：
输入：n = 6
输出：true
解释：6 = 2 × 3

示例 2：
输入：n = 8
输出：true
解释：8 = 2 × 2 × 2

示例 3：
输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。

示例 4：
输入：n = 1
输出：true
解释：1 通常被视为丑数。
 ```


提示：

-2^31 <= n <= 2^31 - 1



**分析**：

根据丑数的定义，0 和负整数一定不是丑数。

当 n>0 时，若 n 是丑数，则 n 可以写成 $n = 2^a \times 3^b \times 5^c$ 的形式，其中 a,b,c 都是非负整数。特别地，当 a,b,c 都是 0 时，n=1。

为判断 n 是否满足上述形式，可以对 n 反复除以 2,3,5 , 直到 n 不再包含质因数2,3,5。若剩下的数等于 1，则说明 n 不包含其他质因数，是丑数；否则，说明 n 包含其他质因数，不是丑数。



**思路1**：递归。

```C++
bool isUgly(int n) {
    if(n==1) 
        return true;
    else if(n%2!=0 && n%3!=0 && n%5!=0)
        return false;
    else if(n<1)
        return false;
    bool a=false,b=false,c=false;
    if(n%2==0 && isUgly(n/2)) return true;
    if(n%3==0 && isUgly(n/3)) return true;
    if(n%5==0 && isUgly(n/5)) return true;
    return false;
}
```



**思路2**：迭代。

```C++
bool isUgly(int n) {
    if (n <= 0) 
        return false;
    vector<int> factors = {2, 3, 5};
    for (int factor : factors) {
        while (n % factor == 0)
            n /= factor;
    }
    return n == 1;
}
```

时间复杂度：O(logn)。时间复杂度取决于对 n 除以 2,3,5 的次数，由于每次至少将 n 除以 2，因此除法运算的次数不会超过 O(logn)。

空间复杂度：O(1) 。





### J49. 丑数 & L264. 丑数 II

**[题目](https://leetcode-cn.com/problems/chou-shu-lcof/)**：我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

 ```
示例:
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
 ```


说明:  

1 是丑数。
n 不超过1690。



**分析**：本题的关键在于找到丑数递推的公式。

**思路1**：最小堆。

要得到从小到大的第 n 个丑数，可以使用最小堆实现。

初始时堆为空。首先将最小的丑数 1 加入堆。

每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x, 3x, 5x 也是丑数，因此将 2x, 3x, 5x 加入堆。

上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。

在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。

**时间复杂度**：O(nlogn)。得到第 n 个丑数需要进行 n 次循环，每次循环都要从最小堆中取出 1 个元素以及向最小堆中加入最多 3 个元素，因此每次循环的时间复杂度是 O(logn)，总时间复杂度是 O(nlogn)。

**空间复杂度**：O(n)。空间复杂度主要取决于最小堆和哈希集合的大小，最小堆和哈希集合的大小都不会超过 3n。

```C++
int nthUglyNumber(int n) {
    std::priority_queue<int64_t, std::vector<int64_t>, std::greater<int64_t>> small_heap;//最小堆
    std::unordered_set<int64_t> hash_set;
    small_heap.push(1);
    hash_set.insert(1);
    for(int i=1;i<n;++i){
        int64_t min = small_heap.top();//取出堆中的最小值
        small_heap.pop();
        if(int64_t tmp=min*2;hash_set.count(tmp)==0) {
            small_heap.push(tmp);
            hash_set.insert(tmp);
        }
        if(int64_t tmp=min*3;hash_set.count(tmp)==0) {
            small_heap.push(tmp);
            hash_set.insert(tmp);
        }
        if(int64_t tmp=min*5;hash_set.count(tmp)==0) {
            small_heap.push(tmp);
            hash_set.insert(tmp);
        }
    }
    return small_heap.top();
}
```



**思路2**：动态规划。

丑数的递推性质： 丑数只包含因子 2, 3, 5 ，因此有 “**丑数 == 某较小丑数 × 某因子**” （例如：10=5×2）。

设已知长度为 n 的丑数序列 $x_1, x_2, \cdots , x_n$，求第 n+1 个丑数 $x_{n+1}$ 。根根据递推性质，丑数 $x_{n+1}$  只可能是以下三种情况其中之一（索引 a, b, c为未知数）：

$$
x_{n+1} = \begin{cases} x_{a} \times 2 & ,a \in [1, n] \\ x_{b} \times 3 & ,b \in [1, n] \\ x_{c} \times 5 & ,c \in [1, n] \end{cases}
$$

	丑数递推公式： 若索引 a,b,c 满足以上条件，则下个丑数 $x_{n+1}$  为以下三种情况中的 最小值 ；

$$
x_{n+1} = \min(x_{a} \times 2, x_{b} \times 3, x_{c} \times 5)
$$
	由于 $x_{n+1}$ 是 最接近 $x_n$  的丑数，因此索引 a, b, c 需满足以下条件：

$$
\begin{cases} 
x_{a} \times 2 > x_n \geq x_{a-1} \times 2 & ，即 x_a 为首个乘以 2 后大于x_n 的丑数 \\ 
x_{b} \times 3 > x_n \geq x_{b-1} \times 3 & ，即 x_b 为首个乘以 3 后大于 x_n 的丑数 \\ 
x_{c} \times 5 > x_n \geq x_{c-1} \times 5 & ，即 x_c 为首个乘以 5 后大于 x_n 的丑数 \\ 
\end{cases}
$$

	因此，可设置指针 a,b,c 指向首个丑数（即 1 ），循环根据递推公式得到下个丑数，并每轮将对应指针执行 +1 即可。

**动态规划解析**：

* 状态定义： 设动态规划列表 dp ，dp[i] 代表第 i+1 个丑数；
* 转移方程：
  * 当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；
  * 每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 ,dp[c]×5 的大小关系，若相等则将对应索引 a , b , c 加 1 ；

$$
\begin{cases} dp[a] \times 2 > dp[i-1] \geq dp[a-1] \times 2 \\ 
dp[b] \times 3 > dp[i-1] \geq dp[b-1] \times 3 \\ 
dp[c] \times 5 > dp[i-1] \geq dp[c-1] \times 5 \\ 
\end{cases}
$$

* 初始状态： dp[0] = 1 ，即第一个丑数为 1 ；
* 返回值： dp[n−1] ，即返回第 n 个丑数；



时间复杂度 O(N)： 其中 N = n ，动态规划需遍历计算 dp 列表。
空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N) 的额外空间。

```C++
int nthUglyNumber(int n) {
    int a = 0, b = 0, c = 0;
    int dp[n];
    dp[0] = 1;
    for(int i = 1; i < n; i++) {
        int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
        dp[i] = min(min(n2, n3), n5);
        if(dp[i] == n2) a++;
        if(dp[i] == n3) b++;
        if(dp[i] == n5) c++;
    }
    return dp[n - 1];
}
```







### L306. 累计数

**[题目](https://leetcode-cn.com/problems/additive-number/)**: 编累加数 是一个字符串，组成它的数字可以形成累加序列。

一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。

给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。

说明：累加序列里的数，除数字 0 之外，不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。

```C++
示例 1：
输入："112358"
输出：true 
解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

    示例 2：
输入："199100199"
输出：true 
解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```


提示：

1 <= num.length <= 35
num 仅由数字（0 - 9）组成



**思路1**：暴力法。

首先使用二维循环找出头3个数num1，num2，num3，再使用暴力递归法寻找下一个数。

```C++
class Solution {
private:
    /**
    判断 a+b与c的大小关系
    a 数字1，输入数字均是从高位到低位排序
    b 数字2
    c 数字3
    返回值：若a+b==c,返回0;若a+b<c,返回-1;若a+b>c,返回1.
    */
    int equal(string a,string b,string c){
        if(c.size()< a.size() || c.size()<b.size())
            return 1;
        string result;
        std::reverse(a.begin(),a.end());
        std::reverse(b.begin(),b.end());

        int iter_max=max(a.size(),b.size());
        int carry=0;
        for(int i=0;i<iter_max;++i){
            int n1=i<a.size()?(a[i]-'0') : 0;
            int n2=i<b.size()?(b[i]-'0') : 0;
            int sum= n1+n2+carry;
            carry = sum/10;
            sum %= 10;
            result.push_back(sum+'0');
        }
        if(carry>0)
            result.push_back(carry+'0');

        //比较两个数
        if(result.size() > c.size()){//说明c的位数小于result的位数，c<result
            return 1;
        }
        else if(result.size() < c.size()){
            return -1;
        }
        else{//位数相等
           std::reverse(result.begin(),result.end());
            for(int i=0;i<c.size();++i){
                if(result[i]>c[i])
                    return 1;
                else if(result[i]<c[i])
                    return -1;
            }
        }
        return 0;
    }

    
    /**
    寻找下一个数。
    start:第三个数的开始位置
    */
    bool find(string &num,string &num1,string &num2,int start){
        //切到了终点，递归出口
        if(start >= num.size()){
            return true;
        }
        
        int N=num.size()-start;//剩余需要判断的长度
        int len1=num1.size();
        int len2=num2.size();
        
        //首先假设num3的长度=max(len1,len2)
        int len3 = max(len1,len2);
        string num3 = num.substr(start,len3);
        if(len3>N)  return false;
        if(len3>1 && num3[0]=='0') return false;
        
        int flag = equal(num1,num2,num3);
        //cout<<num1<<" "<<num2<<" "<<num3<<" flag:"<<flag<<endl;
        if(flag==0){
            bool b=find(num,num2,num3,start+len3);
            if(b) return true;
        }
        //num1+num2可能进位了，len3+1位再试一下
        else if(flag>0){ 
            len3+=1;
            string num3 = num.substr(start,len3);
            if(len3>N)  return false;
            if(len3>1 && num3[0]=='0') return false;
            
            int flag = equal(num1,num2,num3);
           //cout<<"carry:"<<num1<<" "<<num2<<" "<<num3<<" flag:"<<flag<<endl;
            if(flag==0){
                bool b=find(num,num2,num3,start+len3);
                if(b) return true;
            }
        }
        return false;
    }


public:
    bool isAdditiveNumber(string num) {
        //首先找到前两个数
        int N=num.size();
        for(int i=1;i<=N/2;++i){//第一个数的长度
            for(int j=1; N-i-j >= max(i,j); ++j){
                string num1 = num.substr(0,i);
                string num2 = num.substr(i,j);
                if(num1[0]=='0' && i>1) continue;//不能以001开头
                if(num2[0]=='0' && j>1) continue;

                int len3 = max(i,j);
                if(i+j+len3>N)  break;
                string num3 = num.substr(i+j,len3);
                int flag = equal(num1,num2,num3);
                //cout<<num1<<" "<<num2<<" "<<num3<<" flag:"<<flag<<endl;
                if(flag==0){
                    bool b=find(num,num2,num3,i+j+len3);
                    if(b) return true;
                }
                else if(flag>0){ //num1+num2可能进位了，因此result+1位再试一下
                    len3+=1;
                    if(i+j+len3>N) break;;
                    string num3 = num.substr(i+j,len3);
                    int flag = equal(num1,num2,num3);
                    //cout<<"carry:"<<num1<<" "<<num2<<" "<<num3<<" flag:"<<flag<<endl;

                    if(flag==0){
                        bool b=find(num,num2,num3,i+j+len3);
                        if(b) return true;
                    }

                }
            }
        }

        return false;
    }
};
```



官方解答：方法一：穷举累加序列第一个数字和第二个数字的所有可能性
思路及解法

一个累加序列，当它的第一个数字和第二个数字以及总长度确定后，这整个累加序列也就确定了。根据这个性质，我们可以穷举累加序列的第一个数字和第二个数字的所有可能性，对每个可能性，进行一次合法性的判断。当出现一次合法的累加序列后，即可返回 true。当所有可能性都遍历完仍无法找到一个合法的累加序列时，返回 false。

记字符串 num 的长度为 n，序列最新确定的两个数中，位于前面的数字为 first，first 的最高位在 num 中的下标为 firstStart，first 的最低位在 num 中的下标为firstEnd。记序列最新确定的两个数中，位于后面的数字为 second，second 的最高位在 num 中的下标为 secondStart，second 的最低位在 num 中的下标为 secondEnd。在穷举第一个数字和第二个数字的过程中，容易得到以下两个结论： firstStart=0，firstEnd+1=secondStart。因此，我们只需要用两个循环来遍历 secondStart 和 secondEnd 所有可能性的组合即可。

在判断累加序列的合法性时，用字符串的加法来算出 first 与 second 之和 third。将 third 与 num 接下来紧邻的相同长度的字符串进行比较。当 third 过长或者与接下来的字符串不相同时，则说明这不是一个合法的累加序列。当相同时，则我们为这个序列新确定了一个数字。如果 third 刚好抵达 num 的末尾时，则说明这是一个合法的序列。当 num 还有多余的字符时，则需要更新 firstStart，firstEnd，secondStart，secondEnd， 继续进行合法性的判断。

当输入规模较小时，这题可以直接使用整形或者长整型的数字的相加。而我们这里使用了字符串的加法，因此也能处理溢出的过大的整数输入。

仍需要注意的是，当某个数字长度大于等于 2 时，这个数字不能以 0 开头，这部分的判断可以在两层循环体的开头完成。

```C++
class Solution {
public:
    bool isAdditiveNumber(string num) {
        int n = num.size();
        for (int secondStart = 1; secondStart < n - 1; ++secondStart) {
            if (num[0] == '0' && secondStart != 1)
                break;
            for (int secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {
                if (num[secondStart] == '0' && secondStart != secondEnd)
                    break;
                if (valid(secondStart, secondEnd, num))
                    return true;
            }
        }
        return false;
    }

    bool valid(int secondStart, int secondEnd, string num) {
        int n = num.size();
        int firstStart = 0, firstEnd = secondStart - 1;
        while (secondEnd <= n - 1) {
            //计算第三个数
            string third = stringAdd(num, firstStart, firstEnd, secondStart, secondEnd);
            int thirdStart = secondEnd + 1;
            int thirdEnd = secondEnd + third.size();
            //判断计算结果和字符串中的第三个数是否相等
            if (thirdEnd >= n || !(num.substr(thirdStart, thirdEnd - thirdStart + 1) == third)) 
                break;
            if (thirdEnd == n - 1)
                return true;
            firstStart = secondStart;
            firstEnd = secondEnd;
            secondStart = thirdStart;
            secondEnd = thirdEnd;
        }
        return false;
    }

    string stringAdd(string s, int firstStart, int firstEnd, int secondStart, int secondEnd) {
        string third;
        int carry = 0, cur = 0;
        while (firstEnd >= firstStart || secondEnd >= secondStart || carry != 0) {
            cur = carry;
            if (firstEnd >= firstStart) {
                cur += s[firstEnd] - '0';
                --firstEnd;
            }
            if (secondEnd >= secondStart) {
                cur += s[secondEnd] - '0';
                --secondEnd;
            }
            carry = cur / 10;
            cur %= 10;
            third.push_back(cur + '0');
        }
        reverse(third.begin(), third.end());
        return third;
    }
};
```



### L728. 自除数

**[题目](https://leetcode-cn.com/problems/self-dividing-numbers/)**：自除数 是指可以被它包含的每一位数整除的数。

例如，128 是一个 自除数 ，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
自除数 不允许包含 0 。

给定两个整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。

```
示例 1：
输入：left = 1, right = 22
输出：[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]

示例 2:
输入：left = 47, right = 85
输出：[48,55,66,77]
```


提示：

1 <= left <= right <= 10^4



**思路1**：暴力法。

遍历范围 [left,right] 内的所有整数，分别判断每个整数是否为自除数。

根据自除数的定义，如果一个整数不包含 0 且能被它包含的每一位数整除，则该整数是自除数。判断一个整数是否为自除数的方法是遍历整数的每一位，判断每一位数是否为 0 以及是否可以整除该整数。

遍历整数的每一位的方法是，每次将当前整数对 10 取模即可得到当前整数的最后一位，然后将整数除以 10。重复该操作，直到当前整数变成 0 时即遍历了整数的每一位。

```C++
vector<int> selfDividingNumbers(int left, int right) {
    auto isSDN = [](int num){
        int tmp=num;
        while(num>0){
            int a=num%10;
            num/=10;
            if(a==0 || tmp%a !=0)
                return false;
        }
        return true;
    };
    
    vector<int> output;
    for(int i=left;i<=right;++i){
        if(isSDN(i))
            output.push_back(i);
    }
    return output;
}
```





## 求幂



### L231. 2的幂

**[题目](https://leetcode-cn.com/problems/power-of-two/)**：给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。

```
示例 1：
输入：n = 1
输出：true
解释：20 = 1

示例 2：
输入：n = 16
输出：true
解释：24 = 16

示例 3：
输入：n = 3
输出：false

示例 4：
输入：n = 4
输出：true

示例 5：
输入：n = 5
输出：false
```

提示：

-2^31 <= n <= 2^31 - 1



**思路1**：将数字不断除以2，直到得到奇数。

若剩下的奇数为1，则为2的幂

```C++
bool isPowerOfTwo(int n) {
    if(n<=0){
        return false;
    }
    else{
        while(n%2==0)
            n=n/2;
        if(n==1)
            return true;
        else
            return false;
    }
}
```



**思路2**：二进制表示。

一个数 n 是 2 的幂，当且仅当 n 是正整数，并且 n 的二进制表示中仅包含 1 个 1。

因此我们可以考虑使用位运算，将 n 的二进制表示中最低位的那个 1 提取出来，再判断剩余的数值是否为 0 即可。下面介绍两种常见的与「二进制表示中最低位」相关的位运算技巧。

第一个技巧是 `n & (n - 1)`。其中 & 表示按位与运算。该位运算技巧可以直接将 n 二进制表示的最低位 1 移除，它的原理如下：

> 假设 n 的二进制表示为 $(a 10\cdots 0)_2$  ，其中 a 表示若干个高位，1 表示最低位的那个 1，0⋯0 表示后面的若干个 0，那么 n−1 的二进制表示为： $(a 01\cdots1)_2$ 。我们将 $(a 10\cdots 0)_2$  与 $(a 01\cdots1)_2$   进行按位与运算，高位 a 不变，在这之后的所有位都会变为 0，这样我们就将最低位的那个 1 移除了。因此，如果 n 是正整数并且 n & (n - 1) = 0，那么 n 就是 2 的幂。

第二个技巧是 `n & (-n)` , 其中 −n 是 n 的相反数，是一个负数。该位运算技巧可以直接获取 n 二进制表示的最低位的 1。由于负数是按照补码规则在计算机中存储的，−n 的二进制表示为 n 的二进制表示的每一位取反再加上 1，因此它的原理如下：

> 假设 n 的二进制表示为 $(a 10\cdots 0)_2$  ，其中 a 表示若干个高位，1 表示最低位的那个 1，$0\cdots 0$  表示后面的若干个 0，那么 −n 的二进制表示为：
> $$
> (\bar{a} 01\cdots1)_2 + (1)_2 = (\bar{a} 10\cdots0)_2
> $$
> 其中 $\bar{a}$    表示将 a 每一位取反。我们将 $(a 10\cdots 0)_2$  与 $(\bar{a} 10\cdots0)_2$   进行按位与运算，高位全部变为 0，最低位的 1 以及之后的所有 0 不变，这样我们就获取了 n 二进制表示的最低位的 1。
>
> 因此，如果 n 是正整数并且 n & (-n) = n，那么 n 就是 2 的幂。

在一些语言中，位运算的优先级较低，需要注意运算顺序。

```C++
bool isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
或
bool isPowerOfTwo(int n) {
    return n > 0 && (n & -n) == n;
}
```

复杂度分析

时间复杂度：O(1)。

空间复杂度：O(1)。





### L326. 3的幂

**[题目]()**：给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3^x

```
示例 1：
输入：n = 27
输出：true

示例 2：
输入：n = 0
输出：false

示例 3：
输入：n = 9
输出：true

示例 4：
输入：n = 45
输出：false
```


提示：

-2^31 <= n <= 2^31 - 1



**思路1**：试除法。

将数字除以3，直到无法被3整除，判断结果是否为1即可。

```C++
bool isPowerOfThree(int n) {
    if(n<=0){
        return false;
    }
    else{
        while(n%3==0)
            n/=3;
        if(n==1)
            return true;
        else
            return false;
    }
}
```



**思路2**：判断是否为最大 3 的幂的约数
我们还可以使用一种较为取巧的做法。

在题目给定的 32 位有符号整数的范围内，最大的 3 的幂为 3^{19} = 11622614673 。我们只需要判断 n 是否是 3^19  的约数即可。与方法一不同的是，这里需要特殊判断 n 是负数或 0 的情况。

```C++
bool isPowerOfThree(int n) {
    return n > 0 && 1162261467 % n == 0;
}
```



### L342. 4的幂

**[题目](https://leetcode-cn.com/problems/power-of-four/)**：给给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x

```
示例 1：
输入：n = 16
输出：true

示例 2：
输入：n = 5
输出：false

示例 3：
输入：n = 1
输出：true
```


提示：

-2^31 <= n <= 2^31 - 1


进阶：你能不使用循环或者递归来完成本题吗？

**思路1**：循环整除4，直到不能被4整除为止。

```C++
bool isPowerOfFour(int n) {
    if(n<=0){
        return false;
    }
    else{
        while(n%4==0){
            n/=4;
        }
        if(n==1)
            return true;
        else
            return false;
    }
}
```



**思路2**：取模的性质。

如果 n 是 4 的幂，那么 n 一定也是 2 的幂。因此我们可以首先判断 n 是否是 2 的幂，在此基础上再判断 n 是否是 4 的幂。

判断 n 是否是 2 的幂可以参考「231. 2的幂的官方题解」。由于这一步的方法有很多种，在下面的题解中，我们使用
$$
n \& (n - 1)
$$
如果 n 是 4 的幂，那么它可以表示成 $4^x$  的形式，我们可以发现它除以 3 的余数一定为 1，即：
$$
4^x \equiv (3+1)^x \equiv 1^x \equiv 1 \quad (\bmod ~3)
$$
如果 n 是 2 的幂却不是 4 的幂，那么它可以表示成 $4^x \times 2$   的形式，此时它除以 3 的余数一定为 2。

因此我们可以通过 n 除以 3 的余数是否为 1 来判断 n 是否是 4 的幂。

```C++
bool isPowerOfFour(int n) {
    return n > 0 && (n & (n - 1)) == 0 && n % 3 == 1;
}
```



**思路3**：二进制表示中 1 的位置

如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1，并且这个 1 出现在从低位开始的第偶数个二进制位上（这是因为这个 1 后面必须有偶数个 0）。这里我们规定最低位为第 0 位，例如 n=16 时，n 的二进制表示为

$$
(10000)_2
$$
唯一的 1 出现在第 4 个二进制位上，因此 n 是 4 的幂。

由于题目保证了 n 是一个 32 位的有符号整数，因此我们可以构造一个整数 mask，它的所有偶数二进制位都是 0，所有奇数二进制位都是 1。这样一来，我们将 n 和 mask 进行按位与运算，如果结果为 0，说明 n 二进制表示中的 1 出现在偶数的位置，否则说明其出现在奇数的位置。

根据上面的思路，mask 的二进制表示为：
$$
\textit{mask} = (10101010101010101010101010101010)_2
$$
我们也可以将其表示成 16 进制的形式，使其更加美观：
$$
\textit{mask} = (\text{AAAAAAAA})_{16}
$$
代码

```C++
bool isPowerOfFour(int n) {
    return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;
}
```

时间复杂度：O(1)。

空间复杂度：O(1)。





### L50. Pow(x,n)  &  J16. 数值的整数次方

**[题目](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)**:  实现 pow(x, n) ，即计算 x 的 n 次幂函数（即x^n）。不得使用库函数，同时不需要考虑大数问题。

 ```
示例 1：

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
示例 3：

输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
 ```


提示：

-100.0 < x < 100.0
-2^31 <= n <= 2^31-1
-10^4 <= x^n <= 10^4



**思路1**：暴力法。（超时）



**思路2**：提前计算$x^{2^{i}}$。

当n很大时，需要能以$log_2(n)$的时间复杂度计算结果。因此，首先计算$x^{2^{i}}$，如$x,x^2,x^4,x^8,x^{16},...$。将结果存放到数组中。

我的实现：

```C++
class Solution {
public:
    double myPow(double x, int n) {
        //异常值处理
        if(n==0) return 1;
        int flag=n>0?1:-1;
        int64_t number=int64_t(n)*flag;
        //预计算
        int max_n = std::log((double)number)/std::log(2.) ;
        vector<double> arr(max_n+1);//arr[i]= x^(2^i)
        vector<int> indexs(max_n+1);
        arr[0]=x;
        indexs[0]=1;
        for(int i=1;i<=max_n;++i){
            arr[i]=arr[i-1]*arr[i-1];
            indexs[i]=2*indexs[i-1];
        }
        //正式计算
        double result=1;
        int index=max_n;
        while(number>0){
            while(number < indexs[index])index--;
            result *= arr[index];
            number-=indexs[index];
        }
        if(flag==-1)result=1./result;
        return result;
    }
};
```



**思路3**：快速幂法。

「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ ，我们可以按照：$x \to x^2 \to x^4 \to x^8 \to x^{16} \to x^{32} \to x^{64}$的顺序，从 x 开始，每次直接把上一次的结果进行平方，计算 66 次就可以得到 $x^{64}$ 的值，而不需要对 x 乘 63 次 x。再举一个例子，如果我们要计算 $x^{77}$，我们可以按照：

$x \to x^2 \to x^4 \to x^9 \to x^{19} \to x^{38} \to x^{77}$的顺序，在 $x \to x^2，x^2 \to x^4，x^{19} \to x^{38}$这些步骤中，我们直接把上一次的结果进行平方，而在 $x^4 \to x^9$，$x^9 \to x^{19}$，$x^{38} \to x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。

直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：

* 当我们要计算 $x^n$ 时，我们可以先递归地计算出 $y = x^{\lfloor n/2 \rfloor}$，其中 $\lfloor a \rfloor$表示对 a 进行下取整；

* 根据递归计算的结果，如果 n 为偶数，那么 $x^n = y^2$；如果 n 为奇数，那么 $x^n = y^2 \times x$；

* 递归的边界为 n = 0，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 $O(\log n)$，算法可以在很快的时间内得到结果。

```c++
class Solution {
private:
   	double quickMul(double x, long long N) {
        if (N == 0)
            return 1.0;
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }
public:
    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```





由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 x。但我们不妨找一找规律，看看哪些地方额外乘了 x，并且它们对答案产生了什么影响。我们还是以 $x^{77}$ 作为例子：

$x \to x^2 \to x^4 \to^+ x^9 \to^+ x^{19} \to x^{38} \to^+ x^{77}$
并且把需要额外乘 x 的步骤打上了 + 标记。可以发现：

* $x^{38} \to^+ x^{77}$  中额外乘的 x 在 $x^{77}$中贡献了 x；

* $x^9 \to^+ x^{19}$中额外乘的 x 在之后被平方了 2 次，因此在 $x^{77}$中贡献了 $x^{2^2} = x^4$；

* $x^4 \to^+ x^9$ 中额外乘的 xx 在之后被平方了 3 次，因此在 $x^{77}$中贡献了 $x^{2^3} = x^8$；

* 最初的 x 在之后被平方了 6 次，因此在 $x^{77}$中贡献了 $x^{2^6} = x^{64}$。

我们把这些贡献相乘，$x \times x^4 \times x^8 \times x^{64}$  恰好等于 $x^{77}$。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 x 在之后都会被平方若干次。**而这些指数 1，4，8 和 64，恰好就对应了 77 的二进制表示 $(1001101)_2$中的每个 1！**

因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 n 的二进制拆分为$n = 2^{i_0} + 2^{i_1} + \cdots + 2^{i_k}$, 那么$x^n = x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}$
这样以来，我们从 x 开始不断地进行平方，得到 $x^2, x^4, x^8, x^{16}, \cdots$,如果 n 的第 k 个（从右往左，从 0 开始计数）二进制位为 1，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。

```C++
class Solution {
public:
    double quickMul(double x, long long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```





## 题目



### L118. 杨辉三角

**[题目](https://leetcode-cn.com/problems/pascals-triangle/) **:  给给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

```C++
示例 1:
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

示例 2:
输入: numRows = 1
输出: [[1]]
```

提示:

1 <= numRows <= 30



**思路1**：数学递推。

杨辉三角，是二项式系数在三角形中的一种几何排列。它是中国古代数学的杰出研究成果之一，它把二项式系数图形化，把组合数内在的一些代数性质直观地从图形中体现出来，是一种离散型的数与形的结合。

杨辉三角具有以下性质：

>每行数字左右对称，由 1 开始逐渐变大再变小，并最终回到 1。
>
>第 n 行（从 0 开始编号）的数字有 n+1 项，前 n 行共有 $\frac{n(n+1)}{2}$ 个数。
>
>第 n 行的第 m 个数（从 0 开始编号）可表示为可以被表示为组合数 $\mathcal{C}(n,m)$，记作 $\mathcal{C}_n^m$  或 $\binom{n}{m}$ ，即为从 n 个不同元素中取 m 个元素的组合数。我们可以用公式来表示它：$\mathcal{C}_n^m=\dfrac{n!}{m!\times (n-m)!}$ 
>每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n 行的第 i 个数等于第 n−1 行的第 i−1 个数和第 i 个数之和。这也是组合数的性质之一，即 $\mathcal{C}_n^i=\mathcal{C}_{n-1}^i+\mathcal{C}_{n-1}^{i-1}$ 。
>
>$(a+b)^n$   的展开式（二项式展开）中的各项系数依次对应杨辉三角的第 n 行中的每一项。

依据性质 4，我们可以一行一行地计算杨辉三角。每当我们计算出第 i 行的值，我们就可以在线性时间复杂度内计算出第 i+1 行的值。

```C++
vector<vector<int>> generate(int numRows) {
    vector<vector<int>> ret(numRows);
    for (int i = 0; i < numRows; ++i) {
        ret[i].resize(i + 1);
        ret[i][0] = ret[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            ret[i][j] = ret[i - 1][j] + ret[i - 1][j - 1];
        }
    }
    return ret;
}
```







### L119. 杨辉三角 II

**[题目](https://leetcode-cn.com/problems/pascals-triangle-ii/)**:  给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

```C++
示例 1:
输入: rowIndex = 3
输出: [1,3,3,1]

示例 2:
输入: rowIndex = 0
输出: [1]

示例 3:
输入: rowIndex = 1
输出: [1,1]
```

提示:

0 <= rowIndex <= 33



**思路1**：滚动数组。

```C++
vector<int> getRow(int rowIndex) {
    vector<int> last_row(rowIndex+1);
    vector<int> curr_row(rowIndex+1);
    last_row[0]=1;
    for(int i=1;i<=rowIndex;++i){
        for(int j=0;j<=i;++j){
            if(j==0){//第一个
                curr_row[j]=last_row[j];
            }
            else if(j==i){//最后一个
                curr_row[j]=last_row[j-1];
            }
            else{
                curr_row[j]=last_row[j-1]+last_row[j];
            }
        }
        last_row=curr_row;
    }
    return last_row;
}
```







### L66.加一

**[题目](https://leetcode-cn.com/problems/plus-one/)**:  实现 p给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

 ```
示例 1：
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。

示例 2：
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。

示例 3：
输入：digits = [0]
输出：[1]
 ```


提示：

1 <= digits.length <= 100
0 <= digits[i] <= 9



**思路1**：设置一个进位标志位carry，一开始设置carry为1.

```C++
vector<int> plusOne(vector<int>& digits) {
    bool carry=true;
    for(int j=digits.size()-1;j>=0;--j){
        if(carry){
            if(digits[j]==9){
                digits[j]=0;
            }
            else{
                ++digits[j];
                carry=false;
            }
        }
    }
    if(carry){
        digits.insert(digits.begin(),1);
    }
    return digits;
}
```



**思路2**：找出最长的后缀 9

​	当我们对数组 digits 加一时，我们只需要关注 digits 的末尾出现了多少个 9 即可。我们可以考虑如下的三种情况：

* 如果 digits 的末尾没有 9，例如 [1,2,3]，那么我们直接将末尾的数加一，得到 [1, 2, 4] 并返回；

* 如果 digits 的末尾有若干个 9，例如 [1,2,3,9,9]，那么我们只需要找出从末尾开始的第一个不为 9 的元素，即 3，将该元素加一，得到 [1,2,4,9,9]。随后将末尾的 9 全部置零，得到 [1,2,4,0,0] 并返回。

* 如果 digits 的所有元素都是 9，例如 9,9,9,9,9]，那么答案为 [1,0,0,0,0,0]。我们只需要构造一个长度比digits 多 1 的新数组，将首元素置为 1，其余元素置为 0 即可。

**算法**：只需要对数组 digits 进行一次逆序遍历，找出第一个不为 9 的元素，将其加一并将后续所有元素置零即可。如果 digits 中所有的元素均为 9，那么对应着「思路」部分的第三种情况，我们需要返回一个新的数组。

```C++
vector<int> plusOne(vector<int>& digits) {
    int n = digits.size();
    for (int i = n - 1; i >= 0; --i) {
        if (digits[i] != 9) {
            ++digits[i];
            for (int j = i + 1; j < n; ++j)
                digits[j] = 0;
            return digits;
        }
    }
    // digits 中所有的元素均为 9
    vector<int> ans(n + 1);
    ans[0] = 1;
    return ans;
}
```



### L400. 第 N 位数字 & J44. 数字序列中某一位的数字

**[题目](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)**：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

 ```
示例 1：
输入：n = 3
输出：3

示例 2：
输入：n = 11
输出：0
 ```


限制：

0 <= n < 2^31



**思路1**：找规律。

根据题目，可知：

```C++
//0-9 长度 10
//0-99 长度10 + 2*90 =190
//0-999 长度 190 + 3*900 = 2890

因此：
arr[0]=10;
for(int i=1;i<N;++i) 
	arr[i]=arr[i-1]+ (i+1)*(9*std::pow(10,i));
```

因此，可以跟判断输入数字n属于的数字number是几位数的，比如对于n=200，可知对应的number的范围在100-999之间，因此n有3位数。

对于数字n，对应的数字为number，number的位数为digits。首先将n减去比n小一个级别的长度，比如对于n=200，大于0-99对应的190，则有res = n-190 =10。

number的计算：number = res/digits

n在number的第几位的计算： idx = res % digits

代码如下：

```C++
int findNthDigit(int n) {
    if(n<=9) return n;//0-9特殊处理
    int index=0;
    int start=10;
    for(int i=1;i<9;++i){//判断n是属于几次方的，比如n=200，大于0-99对应的190，此时得index=1
        long long count = start + (i+1LL)*(9LL*std::pow(10,i));
        if(n<count){
            index=i;
            break;
        }
        start=count;
    }
    int res = n - start;//比如对于n=200, 减去190后，得res=10
    int digits = index+1;//表示几位数，对于n=200，其对应的数字number的位数为3
    int number = res/digits+std::pow(10,index);//number表示n对应的数字
    int idx=res%(digits);//idx表示n对应于num第几位数
    return std::to_string(number)[idx]-'0';
}
```



**思路2**：官方的实现。

已知 `x` 位数共有 $9 \times 10^{x - 1}$ 个，所有 `x` 位数的位数之和是 $x \times 9 \times 10^{x - 1}$。使用 `d` 和 `count` 分别表示当前遍历到的位数和当前位数下的所有整数的位数之和，初始时 `d = 1`，`count=9`。每次将 `n` 减去 $d×count$，然后将 `d` 加 1，将 `count` 乘以 10，直到 $n \le d \times \textit{count}$，此时的 `d` 是目标数字所在整数的位数，`n` 是所有 `d` 位数中从第一位到目标数字的位数。

为了方便计算目标数字，使用目标数字在所有 d 位数中的下标进行计算，下标从 0 开始计数。令 `index=n−1`，则 `index` 即为目标数字在所有 d 位数中的下标，`index` 的最小可能取值是 0。

得到下标 `index` 之后，即可使用方法一的做法得到无限整数序列中的第 `n` 位数字。

```C++
int findNthDigit(int n) {
    int d = 1, count = 9;
    while (n > (long) d * count) {//计算位数d和当下位数所有整数的位数和count
        n -= d * count;
        d++;
        count *= 10;
    }
    int index = n - 1;//为目标数字在所有 d 位数中的下标
    int start = (int) pow(10, d - 1);//d位数的首数字
    int num = start + index / d;//n对应的数字num
    int digitIndex = index % d;//n在num中的索引
    int digit = (num / (int) (pow(10, d - digitIndex - 1))) % 10;//获得数字
    return digit;
}
```





**思路3**：二分查找。







### J57. 和为s的连续正数序列

**[题目](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)**：输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 ```
示例 1：
输入：target = 9
输出：[[2,3,4],[4,5]]

示例 2：
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
 ```


限制：

1 <= target <= 10^5



**思路1**：滑动窗口，暴力枚举。

遍历从1到`target/2`的每个值`i`，计算以`i`作为起点的连续序列的和，当和等于`target`时，表示找到一个序列。当和大于`target`时，表示以`i`作为起点的连续序列的和不等于`target`。

```C++
vector<vector<int>> findContinuousSequence(int target) {
    vector<vector<int>> result;
    //滑动窗口法
    for(int i=1;i<=target/2;++i){
        int sum=i;
        for(int j=i+1;j<target;++j){//计算以i为起点的窗口大小
            sum+=j;
            if(sum==target){
                vector<int> tmp(j-i+1);
                std::iota(tmp.begin(), tmp.end(), i); //生成递增序列
                result.push_back(tmp);
            }
            else if(sum>target){
                break;
            }
        }
    }
    return result;
}
```



**思路2**：双指针。

我们用两个指针 `l` 和 `r` 表示当前枚举到的以 `l` 为起点到 `r` 的区间，`sum`表示 `[l,r]` 的区间和，由求和公式可 O(1) 求得为 $\textit{sum}=\frac{(l+r) \times (r-l+1)}{2}$  ，起始 `l=1,r=2`。

一共有三种情况：

* 如果 `sum<target` 则说明指针 r 还可以向右拓展使得 sum 增大，此时指针 r 向右移动，即 r+=1
* 如果 `sum>target` 则说明以 l 为起点不存在一个 r 使得 sum=target ，此时要枚举下一个起点，指针 ll 向右移动，即l+=1
* 如果 `sum==target` 则说明我们找到了以 `l` 为起点得合法解 `[l,r]` ，我们需要将 `[l,r]` 的序列放进答案数组，且我们知道以 `l` 为起点的合法解最多只有一个，所以需要枚举下一个起点，指针 `l` 向右移动，即 `l+=1`
  终止条件即为 `l>=r` 的时候，这种情况的发生指针 `r` 移动到了$\lfloor\frac{\textit{target}}{2}\rfloor+1$ 的位置，导致 `l<r` 的时候区间和始终大于 `target` 。

此方法其实是对方法一的优化，因为方法一是没有考虑区间与区间的信息可以复用，只是单纯的枚举起点，然后从起点开始累加，而该方法就是考虑到了如果已知 `[l,r]` 的区间和等于 `target` ，那么枚举下一个起点的时候，区间 `[l+1,r]` 的和必然小于 `target` ，我们就不需要再从 `l+1` 再开始重复枚举，而是从 `r+1` 开始枚举，充分的利用了已知的信息来优化时间复杂度。

```C++
vector<vector<int>> findContinuousSequence(int target) {
    vector<vector<int>> output;
    //双指针
    int left=1,right=2;
    while(left<=target/2){
        int n = right-left+1;
        int sum= (left+right)*(right-left+1)/2;
        //cout<<left<<":"<<right<<" ,"<<sum<<endl;
        if(sum == target){
            vector<int> tmp(right-left+1);
            std::iota(tmp.begin(),tmp.end(),left);
            output.push_back(tmp);
            left++;
        }
        else if(sum > target){
            left++;
        }
        else{
            right++;
        }
    }
    return output;
}
```

时间复杂度：由于两个指针移动均单调不减，且最多移动 $\lfloor\frac{\textit{target}}{2}\rfloor$次，即方法一提到的枚举的上界，所以时间复杂度为 O(target) 。

空间复杂度：O(1) ，除了答案数组只需要常数的空间存放若干变量。

另一个实现：

```C++
vector<vector<int>> findContinuousSequence(int target) {
    vector<vector<int>>vec;
    vector<int> res;
    for (int l = 1, r = 2; l < r;){
        int sum = (l + r) * (r - l + 1) / 2;//求和公式
        if (sum == target) {
            res.clear();
            for (int i = l; i <= r; ++i) 
                res.emplace_back(i);
            vec.emplace_back(res);
            l++;
        } else if (sum < target) {
            r++;
        } else {
            l++;
        }
    }
    return vec;
}
```



### J62. 圆圈中最后剩下的数字

**[题目](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)**：0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 ```
示例 1：
输入: n = 5, m = 3
输出: 3

示例 2：
输入: n = 10, m = 17
输出: 2
 ```


限制：

1 <= n <= 10^5
1 <= m <= 10^6



**思路1**：数学关系。

著名的**约瑟夫环**问题，是有数学解法的！
因为数据是放在数组里，所以我在数组后面加上了数组的复制，以体现是环状的。我们先忽略图片里的箭头：
【下图中第一轮后面的数字应该是[0, 1, 2 ,3 ,4]】

![](https://pic.leetcode-cn.com/9dda886441be8d249abb76e35f53f29fd6e780718d4aca2ee3c78f947fb76e75-image.png)


很明显我们每次删除的是第 m 个数字，我都标红了。

第一轮是 [0, 1, 2, 3, 4] ，所以是 [0, 1, 2, 3, 4] 这个数组的多个复制。这一轮 2 删除了。

第二轮开始时，从 3 开始，所以是 [3, 4, 0, 1] 这个数组的多个复制。这一轮 0 删除了。

第三轮开始时，从 1 开始，所以是 [1, 3, 4] 这个数组的多个复制。这一轮 4 删除了。

第四轮开始时，还是从 1 开始，所以是 [1, 3] 这个数组的多个复制。这一轮 1 删除了。

最后剩下的数字是 3。

图中的绿色的线指的是新的一轮的开头是怎么指定的，每次都是固定地向前移位 m 个位置。

然后我们从最后剩下的 3 倒着看，我们可以反向推出这个数字在之前每个轮次的位置。

最后剩下的 3 的下标是 0。

第四轮反推，补上 m 个位置，然后模上当时的数组大小 2，位置是(0 + 3) % 2 = 1。

第三轮反推，补上 m 个位置，然后模上当时的数组大小 3，位置是(1 + 3) % 3 = 1。

第二轮反推，补上 m 个位置，然后模上当时的数组大小 4，位置是(1 + 3) % 4 = 0。

第一轮反推，补上 m 个位置，然后模上当时的数组大小 5，位置是(0 + 3) % 5 = 3。

所以最终剩下的数字的下标就是3。因为数组是从0开始的，所以最终的答案就是3。

总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。



```C++
int lastRemaining(int n, int m) {
    if(n==1)//序列长度为1，肯定是0
        return 0;
    int index = lastRemaining(n-1,m);//从下一轮保留的位置
    int result = (index+m)%n;//反推公式
    return result;
}
```



### L29. 两数相除

**[题目](https://leetcode-cn.com/problems/divide-two-integers/)**：给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

```
示例 1:
输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = truncate(3.33333..) = truncate(3) = 3

示例 2:
输入: dividend = 7, divisor = -3
输出: -2
解释: 7/-3 = truncate(-2.33333..) = -2
```


提示：

被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。



**思路1**： [朴素的想法，没有位运算，没有移位操作 - 两数相除 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/divide-two-integers/solution/po-su-de-xiang-fa-mei-you-wei-yun-suan-mei-you-yi-/) 

```C++
class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend == 0) return 0;
        if(divisor == 1) return dividend;
        if(divisor == -1){
            if(dividend>INT_MIN) return -dividend;// 只要不是最小的那个整数，都是直接返回相反数就好啦
            return INT_MAX;// 是最小的那个，那就返回最大的整数啦
        }
        //设置符号
        long a = dividend;
        long b = divisor;
        int sign = 1; 
        if((a>0&&b<0) || (a<0&&b>0)){
            sign = -1;
        }
        a = a>0?a:-a;
        b = b>0?b:-b;
        //递归地进行除法
        long res = div(a,b);
        //输出结果
        if(sign>0)
            return res>INT_MAX?INT_MAX:res;
        return -res;
    }
    
    //返回正整数 a/b 的结果
    //简单概括为： 60/8 = (60-32)/8 + 4 = (60-32-16)/8 + 2 + 4 = 1 + 2 + 4 = 7
    int div(long a, long b){  
        if(a<b) return 0;
        long count = 1;
        long tb = b; // 在后面的代码中不更新b
        while((tb+tb)<=a){
            count = count + count; // 最小解翻倍
            tb = tb+tb; // 当前测试的值也翻倍
        }
        return count + div(a-tb,b);
    }
};
```





**思路2**：官方解答：二分查找+快速乘法。

**分析**：

如果除法结果溢出，那么我们需要返回 $2^{31} - 1$ 作为答案。因此在编码之前，我们可以首先对于溢出或者容易出错的边界情况进行讨论：

* 当被除数为 32 位有符号整数的最小值 $-2^{31}$  时：
  * 如果除数为 1，那么我们可以直接返回答案 $-2^{31}$ ；
  * 如果除数为 −1，那么答案为 $2^{31}$ ，产生了溢出。此时我们需要返回 $2^{31} - 1$ 。

* 当除数为 32 位有符号整数的最小值 $-2^{31}$ 时：
  * 如果被除数同样为 $-2^{31} $ ，那么我们可以直接返回答案 1；
  * 对于其余的情况，我们返回答案 0。

* 当被除数为 0 时，我们可以直接返回答案 0。

  对于一般的情况，根据除数和被除数的符号，我们需要考虑 4 种不同的可能性。因此，为了方便编码，我们可以将被除数或者除数取相反数，使得它们符号相同。

如果我们将被除数和除数都变为正数，那么可能会导致溢出。例如当被除数为 $-2^{31}$ 时，它的相反数 $2^{31}$  产生了溢出。因此，我们可以考虑将被除数和除数都变为负数，这样就不会有溢出的问题，在编码时只需要考虑 1 种情况了。

如果我们将被除数和除数的其中（恰好）一个变为了正数，那么在返回答案之前，我们需要对答案也取相反数。

**思路**：根据上面的讨论，我们记被除数为 X，除数为 Y，并且 X 和 Y 都是负数。我们需要找出 X/Y 的结果 Z。Z 一定是正数或 0。

根据除法以及余数的定义，我们可以将其改成乘法的等价形式，即：

$Z \times Y \geq X > (Z+1) \times Y$
    因此，我们可以使用二分查找的方法得到 Z，即找出最大的 Z 使得 Z×Y≥X 成立。

由于我们不能使用乘法运算符，因此我们需要使用「快速乘」算法得到 Z×Y 的值。「快速乘」算法与「快速幂」类似，前者通过加法实现乘法，后者通过乘法实现幂运算。「快速幂」算法可以参考「50. Pow(x, n)」的官方题解，「快速乘」算法只需要在「快速幂」算法的基础上，将乘法运算改成加法运算即可。

由于我们只能使用 32 位整数，因此二分查找中会有很多细节。

首先，二分查找的下界为 1，上界为 $2^{31}-1$ 。唯一可能出现的答案为 $2^{31}$  的情况已经被我们在「前言」部分进行了特殊处理，因此答案的最大值为 $2^{31} - 1$。如果二分查找失败，那么答案一定为 0。

在实现「快速乘」时，我们需要使用加法运算，然而较大的 Z 也会导致加法运算溢出。例如我们要判断 A+B 是否小于 C 时（其中 A,B,C 均为负数），A+B 可能会产生溢出，因此我们必须将判断改为 A<C−B 是否成立。由于任意两个负数的差一定在 $[-2^{31} + 1, 2^{31} - 1]$范围内，这样就不会产生溢出。

```C++
class Solution {
private:
    // 快速乘
    // x 和 y 是负数，z 是正数
    bool quickAdd(int y, int z, int x) {
        // 需要判断 z * y >= x 是否成立
        int result = 0, add = y;
        while (z) {
            if (z & 1) {
                if (result < x - add) // 需要保证 result + add >= x
                    return false;
                result += add;
            }
            if (z != 1) {
                if (add < x - add) // 需要保证 add + add >= x
                    return false;
                add += add;
            }
            z >>= 1;// 不能使用除法
        }
        return true;
    }
    
public:
    int divide(int dividend, int divisor) {
        ///判断特殊情况
        if (dividend == INT_MIN) {// 考虑被除数为最小值的情况
            if (divisor == 1)
                return INT_MIN;
            if (divisor == -1) 
                return INT_MAX;
        }
        if (divisor == INT_MIN) // 考虑除数为最小值的情况
            return dividend == INT_MIN ? 1 : 0;
        if (dividend == 0) // 考虑被除数为 0 的情况
            return 0;
        
        // 一般情况，使用二分查找
        // 将所有的正数取相反数，这样就只需要考虑一种情况
        bool rev = false;
        if (dividend > 0) {
            dividend = -dividend;
            rev = !rev;
        }
        if (divisor > 0) {
            divisor = -divisor;
            rev = !rev;
        }
		///进行二分查找
        int left = 1, right = INT_MAX, ans = 0;
        while (left <= right) {
            // 注意溢出，并且不能使用除法
            //(right - left) >> 1等于(right - left)/2
            int mid = left + ((right - left) >> 1);
            bool check = quickAdd(divisor, mid, dividend);
            if (check) {
                ans = mid;
                if (mid == INT_MAX) // 注意溢出
                    break;
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }

        return rev ? -ans : ans;
    }
};
```







### L169. 多数元素 & J39. 数组中出现次数超过一半的数字

**题目**：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 
你可以假设数组是非空的，并且给定的数组总是存在多数元素。



**思路1**：采用哈希表（简单粗暴）

```C++
int majorityElement(vector<int>& nums) {
std::unordered_map<int,int> d;
for(int i=0;i<nums.size();++i){
    if(d.find(nums[i])==d.end())
	d.insert({nums[i],1});
    else
	d[nums[i]]++;
}
for(auto [num,count]:d){
    if(count>std::floor(nums.size()/2))
	return num;
}
return 0;
}
```



**思路2**：先排序，排序后数组的中间值肯定是众数。



**思路3**：分治算法。
如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。 
我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l / 2 + r / 2 次，
其中 l 和 r 分别是左半部分和右半部分的长度。由于 l / 2 + r / 2 <= (l + r) / 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。  
这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。  



**思路4**：Boyer-Moore 投票算法（重要）
	Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤： 
我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0； 
我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x： 
如果 x 与 candidate 相等，那么计数器 count 的值增加 1；
如果 x 与 candidate 不等，那么计数器 count 的值减少 1。 
在遍历完成后，candidate 即为整个数组的众数。

```C++
int majorityElement(vector<int>& nums) 
{
    int condidate=nums[0];
    int count=0;
    for(int i=1;i<nums.size();++i){
        if(condidate==nums[i])
            count++;
        else
            count--;
        if(count<0){
            condidate=nums[i];
            count=0;
        }
    }
    return condidate;
}
```





### L229. 求众数 II

**[题目](https://leetcode-cn.com/problems/majority-element-ii/)**：给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

```
示例 1：
输入：[3,2,3]
输出：[3]

示例 2：
输入：nums = [1]
输出：[1]

示例 3：
输入：[1,1,1,3,3,2,2,2]
输出：[1,2]
```

提示：

1 <= nums.length <= 5 * 10^4
-10^9 <= nums[i] <= 10^9


进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。



**思路1**：哈希表统计数字出现的次数。

空间复杂度O(n),时间复杂度O(n)



**思路2**：Boyer-Moore 投票算法





### L204. 计算质数

[题目](https://leetcode-cn.com/problems/count-primes/) ：给定整数 `n` ，返回 *所有小于非负整数 `n` 的质数的数量* 。 

**示例 1：**

```
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

**示例 2：**

```
输入：n = 0
输出：0
```

**示例 3：**

```
输入：n = 1
输出：0
```

**提示：**

- `0 <= n <= 5 * 10^6`



**思路1**：暴力法（超时）



**思路2**：埃氏筛。

枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞提出，称为厄拉多塞筛法，简称埃氏筛。

我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。

我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。

这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。

当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。

```C++
int countPrimes(int n) {
    if(n<=2) return 0;
    vector<int> prime(n,1);
    prime[0]=0;
    prime[1]=0;
    int cnt=0;
    for(int i=2;i<n;++i){
        if(!prime[i])
            continue;
        cnt++;
        ///将i的倍数设置为true
        prime[i]=0;
        unsigned long curr=i;
        unsigned long k=curr;
        while(k*i<n){
            prime[k*i]=0;
            k++;
        }
    }
    return cnt;
}
```

或：

```C++
class Solution {
public:
    int countPrimes(int n) {
        vector<int> isPrime(n, 1);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i]) {
                ans += 1;
                if ((long long)i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = 0;
                    }
                }
            }
        }
        return ans;
    }
};
```





### L223. 矩形面积

[**题目**](https://leetcode-cn.com/problems/rectangle-area/)：给你 **二维** 平面上两个 **由直线构成且边与坐标轴平行/垂直** 的矩形，请你计算并返回两个矩形覆盖的总面积。

每个矩形由其 **左下** 顶点和 **右上** 顶点坐标表示：

- 第一个矩形由其左下顶点 `(ax1, ay1)` 和右上顶点 `(ax2, ay2)` 定义。
- 第二个矩形由其左下顶点 `(bx1, by1)` 和右上顶点 `(bx2, by2)` 定义。

**示例 1：**

![Rectangle Area](https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png)

```
输入：ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
输出：45
```

**示例 2：**

```
输入：ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2
输出：16
```

 **提示：**

- `-10^4 <= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 <= 10^4`



**思路1**：计算重叠面积

​	两个矩形覆盖的总面积等于两个矩形的面积之和减去两个矩形的重叠部分的面积。由于两个矩形的左下顶点和右上顶点已知，因此两个矩形的面积可以直接计算。如果两个矩形重叠，则两个矩形的重叠部分也是矩形，重叠部分的面积可以根据重叠部分的边界计算。

​	两个矩形的水平边投影到 x 轴上的线段分别为 $[\textit{ax}_1, \textit{ax}_2]$  和 $[\textit{bx}_1, \textit{bx}_2]$ 竖直边投影到 y 轴上的线段分别为 $[\textit{ay}_1, \textit{ay}_2]$ 和 $[\textit{by}_1, \textit{by}_2]$如果两个矩形重叠，则重叠部分的水平边投影到 x 轴上的线段为 $[\max(\textit{ax}_1, \textit{bx}_1), \min(\textit{ax}_2, \textit{bx}_2)]$，竖直边投影到 y 轴上的线段为 $[\max(\textit{ay}_1, \textit{by}_1), \min(\textit{ay}_2, \textit{by}_2)]$，根据重叠部分的水平边投影到 xx 轴上的线段长度和竖直边投影到 yy 轴上的线段长度即可计算重叠部分的面积。只有当两条线段的长度都大于 0 时，重叠部分的面积才大于 0，否则重叠部分的面积为 0。

```C++
int computeArea(int ax1, int ay1, int ax2, int ay2, 
                int bx1, int by1, int bx2, int by2) {
    //两个矩形的面积
    int area_a = (ax2-ax1) * (ay2-ay1);
    int area_b = (bx2-bx1) * (by2-by1);

    int area_insect=0;
    if(ax2 <= bx1 || bx2<=ax1 || ay2<=by1 || by2<=ay1) // 不相交
        area_insect=0;
    else{
        int right_x = std::min(ax2,bx2);
        int right_y = std::min(ay2,by2);
        int left_x = std::max(ax1,bx1);
        int left_y = std::max(ay1,by1);
        area_insect = (right_x-left_x) * (right_y-left_y);
    }
    return area_a + area_b - area_insect;
}
```

或

```C++
int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
    int area1 = (ax2 - ax1) * (ay2 - ay1);
    int area2 = (bx2 - bx1) * (by2 - by1);
    int overlapWidth = min(ax2, bx2) - max(ax1, bx1);
    int overlapHeight = min(ay2, by2) - max(ay1, by1);
    int overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0);
    return area1 + area2 - overlapArea;
}
```













